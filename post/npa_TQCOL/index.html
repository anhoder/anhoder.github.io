<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="anhoder的进阶日志">
<meta name="description" content="一川烟草，满城风絮。">
<meta name="theme-color" content="#000">
<title>又一个命令行版网易云音乐——musicfox | anhoder的进阶日志</title>
<link rel="shortcut icon" href="/favicon.ico?v=1618994179935">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/green/pace-theme-minimal.css" rel="stylesheet" />

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-161423102-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-161423102-1');
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?bdf14d3cd277bc2dfa9f84d19b36a686";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="又一个命令行版网易云音乐——musicfox" />
  <meta name="keywords" content="musicfox,musicbox,其它" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>anhoder的进阶日志</span>
            </a>  
          
        </div>
        
          <p class="subtitle">一川烟草，满城风絮。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/" target="_self">
                    <i class="fa fa-home"></i> 首页
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/archives/" target="_self">
                    <i class="fa fa-archive"></i> 归档
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/tags/" target="_self">
                    <i class="fa fa-tags"></i> 标签
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/post/about/" target="_self">
                    <i class="fa fa-user"></i> 关于
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="https://github.com/anhoder/" target="_blank">
                    <i class="fa fa-github"></i> GitHub
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/media/excalidraw/" target="_self">
                    <i class="fa fa-picture-o"></i> 制作手绘图
                  </a>
                
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">anhoder</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">85</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">24</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">24</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/anhoder">
              <i class="fa fa-github-alt" title="GitHub"></i>
            </a>
          
            <a href="https://twitter.com/Alan_Albert_">
              <i class="fa fa-twitter" title="Twitter"></i>
            </a>
          
            <a href="https://weibo.com/u/5794659803">
              <i class="fa fa-weibo" title="Weibo"></i>
            </a>
          
            <a href="mailto:anhoder@88.com">
              <i class="fa fa-envelope" title="Email"></i>
            </a>
          
            <a href="https://stackoverflow.com/users/9723854/alan">
              <i class="fa fa-stack-overflow" title="StackOverflow"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="/media/images/custom-array-imgSocials-1617614181832-socialImg.png" />
              <i class="fa fa-weixin" title="微信公众号" ></i>
            </a>
          
        
      </div>
    </div>
  

  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE">一、为什么做这个项目</a></li>
<li><a href="#%E4%BA%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8dart">二、为什么使用Dart</a></li>
<li><a href="#%E4%B8%89-%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88">三、效果预览</a></li>
<li><a href="#%E5%9B%9B-%E5%AE%89%E8%A3%85">四、安装</a>
<ul>
<li><a href="#mac">Mac</a></li>
<li><a href="#linuxubuntu">Linux(Ubuntu)</a></li>
<li><a href="#windows">Windows</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD">五、通知功能</a>
<ul>
<li><a href="#mac-2">Mac</a></li>
<li><a href="#linux">Linux</a></li>
<li><a href="#windows-2">Windows</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E4%BD%BF%E7%94%A8">六、使用</a></li>
<li><a href="#%E4%B8%83-todo">七、TODO</a></li>
<li><a href="#%E5%85%AB-%E4%BC%B4%E7%94%9F%E9%A1%B9%E7%9B%AE">八、伴生项目</a></li>
<li><a href="#%E4%B9%9D-%E6%84%9F%E8%B0%A2">九、感谢</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="post/npa_TQCOL/">
      又一个命令行版网易云音乐——musicfox
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-07-12 20:01:18">2020-07-12</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="tag/4DtRgZzLu/">
        <span>musicfox</span>
      </a>、
      
      
      
      <a href="tag/9ERhdVc7a8/">
        <span>musicbox</span>
      </a>、
      
      
      
      <a href="tag/Yxu2y8I-l/">
        <span>其它</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>5<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1122<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>musicfox是一款使用Dart编写的网易云音乐命令行程序。</p>
<p><img src="https://badgen.net/github/release/anhoder/musicfox" alt="last release" loading="lazy"><img src="https://badgen.net/github/license/anhoder/musicfox" alt="GitHub" loading="lazy"><img src="https://badgen.net/github/tag/anhoder/musicfox" alt="Last Tag" loading="lazy"><img src="https://badgen.net/github/stars/anhoder/musicfox" alt="Star" loading="lazy"><img src="https://badgen.net/github/last-commit/anhoder/musicfox" alt="GitHub last commit" loading="lazy"></p>
<!-- more -->
<h2 id="一-为什么做这个项目">一、为什么做这个项目</h2>
<p>在开始这个项目的之前，其实是已经有一个基于命令行的网易云音乐项目——<a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a>。</p>
<p>我也使用它听了很长一段时间的歌了，其中还贡献过一些代码，修复几个小问题。那为什么还要重新造一个轮子呢？</p>
<blockquote>
<ol>
<li>musicbox缺少一些我特别想要的功能</li>
<li>musicbox使用python进行编写，我对python并不是很熟悉，所以修改或者新增功能时比较麻烦</li>
</ol>
</blockquote>
<h2 id="二-为什么使用dart">二、为什么使用Dart</h2>
<ul>
<li>Dart的语法极像Java，我本身也学过Java，因此学习成本较低；</li>
<li>Dart可以将代码编译成能在三大平台（Windows、Linux、Mac）上直接运行的可执行程序。</li>
</ul>
<h2 id="三-效果预览">三、效果预览</h2>
<figure data-type="image" tabindex="1"><img src="/post-images/1617678066308.png" alt="欢迎界面" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1617678078304.png" alt="主界面1" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="/post-images/1617678089104.png" alt="主界面2" loading="lazy"></figure>
<h2 id="四-安装">四、安装</h2>
<p>依赖mpg123，<strong>必须先安装mpg123</strong></p>
<h3 id="mac">Mac</h3>
<p>提供两种方式安装：</p>
<ol>
<li>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.mac文件，在iTerm或Terminal中运行</li>
<li>使用brew安装：</li>
</ol>
<pre><code class="language-sh">brew tap anhoder/musicfox &amp;&amp; brew install musicfox
</code></pre>
<h3 id="linuxubuntu">Linux(Ubuntu)</h3>
<p>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.ubuntu文件，在终端中运行。</p>
<blockquote>
<p>本人没有Linux系统，该执行文件是在WSL2(Ubuntu 2004)下打包的，不确定其他Linux系统是否也能正常使用</p>
</blockquote>
<h3 id="windows">Windows</h3>
<p>下载<a href="./bin/musicfox.exe" title="Windows可执行文件">Windows可执行文件</a>，在命令行(推荐Windows Terminal)中运行即可。</p>
<p><strong>Windows下存在几个已知问题，暂时没有解决方法：</strong></p>
<ol>
<li>暂停时会延迟几秒，播放时不会延迟</li>
<li>登录或搜索输入时，会吞掉第一个字符</li>
<li>上、下、左、右及ESC键无法监听，只能使用字母代替这些操作</li>
<li>命令行窗口大小发生变化后，UI会变乱（因为Windows不支持resize事件）</li>
</ol>
<p><em>因为存在以上问题，所以推荐在WSL下使用，WSL的声音转发可以参考我的另一个<a href="https://github.com/anhoder/wsl-audio-musicbox" title="项目">项目</a></em>。</p>
<h2 id="五-通知功能">五、通知功能</h2>
<h3 id="mac-2">Mac</h3>
<p>Mac下默认使用<code>AppleScript</code>发送通知。如下：</p>
<figure data-type="image" tabindex="4"><img src="/post-images/1617678108326.png" alt="AppleScript" loading="lazy"></figure>
<p>如果想要更好的通知体验，可以安装<code>terminal-notifier</code>:</p>
<pre><code class="language-sh">brew install terminal-notifier
</code></pre>
<p>效果如下：</p>
<figure data-type="image" tabindex="5"><img src="/post-images/1617678123055.png" alt="terminal-notifier" loading="lazy"></figure>
<h3 id="linux">Linux</h3>
<p>Linux可以安装<code>libnotify-bin</code>来使用通知功能（未经测试）</p>
<h3 id="windows-2">Windows</h3>
<p>Windows下可以安装<code>notifu</code>实现通知，体验不太好（没找到其他更好的通知工具）</p>
<blockquote>
<p>当然，如果你有更好的命令行通知程序，你也可以自己实现INotifier接口达到你想要的效果：</p>
<pre><code class="language-dart">abstract class INotifier {
  // 检查该通知程序是否可用
  bool isAvailable();

  // 发送消息
  void send(String message, {String title, String subtitle, String soundName, String groupID, String activateID, String appIcon, String contentImage, String openURL, String executeCmd});
}
</code></pre>
</blockquote>
<h2 id="六-使用">六、使用</h2>
<pre><code class="language-sh">$ musicfox
</code></pre>
<p><strong>按键：</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td>Windows只能使用<code>h</code></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td>Windows只能使用<code>l</code></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td>Windows只能使用<code>k</code></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td>Windows只能使用<code>j</code></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td>Windows只能使用<code>q</code></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td>Windows只能使用<code>n</code></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td>Windows只能使用<code>b</code></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td>Windows只能使用<code>w</code></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td>Windows下使用<code>o</code></td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td>Windows下使用<code>;</code></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td>Windows下使用<code>'</code></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td>Windows下使用<code>\</code></td>
</tr>
</tbody>
</table>
<h2 id="七-todo">七、TODO</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5404958"><label class="task-list-item-label" for="task-item-5404958"> 我的歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8809478"><label class="task-list-item-label" for="task-item-8809478"> 每日推荐歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1403934"><label class="task-list-item-label" for="task-item-1403934"> 每日推荐歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7939705"><label class="task-list-item-label" for="task-item-7939705"> 私人FM</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3758193"><label class="task-list-item-label" for="task-item-3758193"> 歌词显示</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3983759"><label class="task-list-item-label" for="task-item-3983759"> 欢迎界面</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2393858"><label class="task-list-item-label" for="task-item-2393858"> 搜索</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6896166"><label class="task-list-item-label" for="task-item-6896166"> 按歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3978659"><label class="task-list-item-label" for="task-item-3978659"> 按歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7465361"><label class="task-list-item-label" for="task-item-7465361"> 按歌词</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4981876"><label class="task-list-item-label" for="task-item-4981876"> 按歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2488303"><label class="task-list-item-label" for="task-item-2488303"> 按专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6909541"><label class="task-list-item-label" for="task-item-6909541"> 按用户</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1628652"><label class="task-list-item-label" for="task-item-1628652"> 排行榜</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7896952"><label class="task-list-item-label" for="task-item-7896952"> 精选歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1792411"><label class="task-list-item-label" for="task-item-1792411"> 最新专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-974991"><label class="task-list-item-label" for="task-item-974991"> 热门歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1740444"><label class="task-list-item-label" for="task-item-1740444"> 云盘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8336615"><label class="task-list-item-label" for="task-item-8336615"> 播放方式切换</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9989566"><label class="task-list-item-label" for="task-item-9989566"> 喜欢/取消喜欢</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2467415"><label class="task-list-item-label" for="task-item-2467415"> 心动模式/智能模式</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-702152"><label class="task-list-item-label" for="task-item-702152"> 音乐电台</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9784043"><label class="task-list-item-label" for="task-item-9784043"> 将部分设置转化为文件可配置</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1197187"><label class="task-list-item-label" for="task-item-1197187"> 欢迎界面的欢迎语</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-258147"><label class="task-list-item-label" for="task-item-258147"> 欢迎界面时长</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5408746"><label class="task-list-item-label" for="task-item-5408746"> 主题色</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9996738"><label class="task-list-item-label" for="task-item-9996738"> 歌词显示行数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9187268"><label class="task-list-item-label" for="task-item-9187268"> ...</label></li>
</ul>
</li>
</ul>
<h2 id="八-伴生项目">八、伴生项目</h2>
<p>在该项目的开发过程中，我将一些通用的功能模块单独抽离出来，做成了几个伴生项目：</p>
<ol>
<li><a href="https://github.com/anhoder/mp3_player" title="mp3_player">mp3_player</a>: dart命令行调用mpg123播放音乐</li>
<li><a href="https://github.com/anhoder/netease_music_request" title="netease_music_request">netease_music_request</a>: Dart实现的网易云音乐接口库，使用Dio发起请求，CookieJar管理Cookie信息</li>
<li><a href="https://github.com/anhoder/colorful_cmd" title="colorful_cmd">colorful_cmd</a>: 使用dart实现的一些命令行UI组件，如：WindowUI命令行窗口应用UI、RainbowProgress彩虹进度条、NotifierProxy三大平台通知代理、ColorText颜色文本...<br>
<img src="/post-images/1617678161539.png" alt="command" loading="lazy"><br>
<img src="/post-images/1617678173841.png" alt="rainbow_progress" loading="lazy"><br>
<img src="/post-images/1617678188194.png" alt="window_ui" loading="lazy"><br>
<img src="/post-images/1617678202350.png" alt="window_ui2" loading="lazy"></li>
</ol>
<h2 id="九-感谢">九、感谢</h2>
<p>感谢以下项目及其贡献者们（不限于）：</p>
<ul>
<li><a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a></li>
<li><a href="https://github.com/Binaryify/NeteaseCloudMusicApi" title="NeteaseCloudMusicApi">NeteaseCloudMusicApi</a></li>
<li><a href="https://github.com/DirectMyFile/console.dart" title="console.dart">console.dart</a></li>
</ul>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      anhoder
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="post/npa_TQCOL/" title="又一个命令行版网易云音乐——musicfox">post/npa_TQCOL/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="tag/4DtRgZzLu/"># musicfox</a>
    
      <a href="tag/9ERhdVc7a8/"># musicbox</a>
    
      <a href="tag/Yxu2y8I-l/"># 其它</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="PHP扩展开发中常用的宏函数" href="post/y_zVEbs0X/">PHP扩展开发中常用的宏函数</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="PHP扩展开发中常用的宏函数" href="post/y_zVEbs0X/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="使用laravel的方式管理imi的路由" href="post/O4IVHtR2w/">使用laravel的方式管理imi的路由</a>
        <a class="nav-mobile-next" title="使用laravel的方式管理imi的路由" href="post/O4IVHtR2w/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '8254f894b17fffeef6e2',
    clientSecret: 'aa345603999774a44649ad73ef7fe72ee45a021b',
    repo: 'personal-blog-comments',
    owner: 'anhoder',
    admin: ['anhoder'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="poweredby">
      © Authored by <a href="https://github.com/anhoder">anhoder</a> since 2019.
    </div>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 100%px;bottom: 100%px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/anhoder/source-for-blog@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'plt'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			} else if (chooseLive2d === 'plt') {
				AIimgSrc.push(message_Path + "model/plt/moc/plt.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						} else if (chooseLive2d === 'plt') {
							model = message_Path + "model/plt/model.json?v=1617466520";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    if (image.classList.contains('no-fancybox')) {
      return;
    }

    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/YMhNrwxuT/"" data-c="
          &lt;p&gt;工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于&lt;code&gt;otp&lt;/code&gt;封装了一个utools插件——&lt;code&gt;hashids&lt;/code&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;utools是什么就不多说了，这里主要说一下&lt;code&gt;hashids&lt;/code&gt;插件的使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GitHub地址: &lt;a href=&#34;https://github.com/anhoder/utools-hashids&#34;&gt;https://github.com/anhoder/utools-hashids&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;添加hashids配置&#34;&gt;添加hashids配置&lt;/h2&gt;
&lt;p&gt;hashids加解密需要配置salt及最小长度，可以使用以下关键字进去添加配置的步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hadd&lt;/li&gt;
&lt;li&gt;hash-add&lt;/li&gt;
&lt;li&gt;hash添加配置&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617624599510.png&#34; alt=&#34;添加配置&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;进入之后，依次输入&lt;code&gt;名称&lt;/code&gt;-&lt;code&gt;salt&lt;/code&gt;-&lt;code&gt;最小长度&lt;/code&gt;即可保存配置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果有多个环境配置，多次添加即可，&lt;strong&gt;名称不可重复&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hashids加密&#34;&gt;hashids加密&lt;/h2&gt;
&lt;p&gt;hashids加密有两种方式进入，一种是使用关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;haen&lt;/li&gt;
&lt;li&gt;hash-encode&lt;/li&gt;
&lt;li&gt;hash编码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入之后，输入你想要加密的ID，列表中会显示你已有配置的加密结果，回车即可复制，如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;/post-images/1617626324547.png&#34; alt=&#34;hashids加密&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另外一种方法是直接在&lt;code&gt;utools&lt;/code&gt;的主输入框内输入需要加密的ID，选择&lt;code&gt;hash编码&lt;/code&gt;进入，回车即可复制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果你开启了utools的右键超级面板，就更方便了，只需要长按右键你的ID，选择&lt;code&gt;hash编码&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;如果你需要删除配置，在进入之后使用&lt;code&gt;control&lt;/code&gt;+&lt;code&gt;enter&lt;/code&gt;或&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;enter&lt;/code&gt;即可删除选中的配置项。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hashids解密&#34;&gt;hashids解密&lt;/h2&gt;
&lt;p&gt;解密和加密差不多，就不赘述了，关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hade&lt;/li&gt;
&lt;li&gt;hash-decode&lt;/li&gt;
&lt;li&gt;hash解码&lt;/li&gt;
&lt;/ul&gt;
">一个utools插件——hasids加解密</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/O933qcq8E/"" data-c="
          &lt;p&gt;这里主要介绍一些我知道的PHP的使用技巧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-php内置的web-server&#34;&gt;1、PHP内置的Web Server&lt;/h2&gt;
&lt;p&gt;首先，有个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你需要快速启动一个HTTP服务来调试PHP代码，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;启动php-fpm或php-cgi进程监听9000端口，然后使用Nginx将Http请求通过FastCGI接口转发给php-fpm或php-cgi进程？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这不失为一种方法，但是并不算方便。&lt;/p&gt;
&lt;p&gt;其实，PHP 5.4.0后就提供了一个内置的Web服务器，你可以执行这个命令来启动它:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php -S 127.0.0.1:8080 a.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就通过 http://127.0.0.1:8080 来进行访问了。&lt;/p&gt;
&lt;h2 id=&#34;2-执行php代码时生成debug信息&#34;&gt;2、执行PHP代码时生成debug信息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在执行PHP代码时，你会用什么方法进行调试？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;var_dump、print_r直接输出？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;除了直接输出，你还可以使用debug模式配合IDE来进行调试。在执行PHP代码时，加上&lt;code&gt;-e&lt;/code&gt;参数，同时IDE开启debug监听（需要安装xdebug或yasd等调试类扩展，推荐yasd，它可以调试swoole协程）:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php -e a.php

php -e artisan test:test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样你就可以使用IDE的debug功能来调试你的PHP命令了。除此之外，还可以配合PHP的内置Web服务器一起使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php -e -S 127.0.0.1:8080 a.php
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-数组迭代&#34;&gt;3、数组迭代&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需要获取这个数组所有层级的子元素，你会怎么做？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$arr = [
  &#39;key1&#39; =&amp;gt; &#39;value1&#39;,
  &#39;key2&#39; =&amp;gt; [
      &#39;key3&#39; =&amp;gt; &#39;value2&#39;,
      &#39;key4&#39; =&amp;gt; [
          &#39;value3&#39;,
          &#39;value4&#39;,
      ]
  ],
  &#39;key5&#39; =&amp;gt; &#39;value5&#39;
];
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;使用递归？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;没错，可以使用递归。你也可以选择另外一种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$arr = [
    &#39;key1&#39; =&amp;gt; &#39;value1&#39;,
    &#39;key2&#39; =&amp;gt; [
        &#39;key3&#39; =&amp;gt; &#39;value2&#39;,
        &#39;key4&#39; =&amp;gt; [
            &#39;value3&#39;,
            &#39;value4&#39;,
        ]
    ],
    &#39;key5&#39; =&amp;gt; &#39;value5&#39;
];

$it = new RecursiveArrayIterator($arr);
$recursiveIt = new RecursiveIteratorIterator($it);
foreach ($recursiveIt as $v) {
    var_dump($v);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-目录迭代&#34;&gt;4、目录迭代&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需要获取一个目录下所有层级的所有文件，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;这样使用dir迭代？&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function test($dir) {
    $dirHandle = dir($dir);
    while ($item = $dirHandle-&amp;gt;read()) {
        if ($item == &#39;.&#39; || $item == &#39;..&#39;) continue;
        $path = &amp;quot;{$dir}/{$item}&amp;quot;;
        if (is_dir($path)) {
            test($path);
        } else {
            var_dump($item);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你还可以用更简单的方法，同样也是PHP内置的迭代器:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$it = new RecursiveDirectoryIterator(&#39;./&#39;);
$reIt = new RecursiveIteratorIterator($it);

foreach ($reIt as $value) {
    var_dump($value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-访问对象的私有属性&#34;&gt;5、访问对象的私有属性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用一个库的对象时，想要访问该对象的私有属性，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;Closure&lt;/code&gt;类的静态方法&lt;code&gt;bind&lt;/code&gt;或非静态方法&lt;code&gt;bindTo&lt;/code&gt;将函数绑定到该类的作用域下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class A {
    private $name = &#39;The name of A&#39;;
}

$a = new A();

// 方法一
$closure = Closure::bind(function () use ($a) {
    var_dump($a-&amp;gt;name);
}, null, A::class);

// 方法二，通过this访问
//$closure = Closure::bind(function () {
//    var_dump($this-&amp;gt;name);
//}, $a, A::class);

$closure();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-fastcgi_request_finish&#34;&gt;6、fastcgi_request_finish&lt;/h2&gt;
&lt;p&gt;fastcgi_request_finish函数是PHP提供的在CGI模式下可用的方法。&lt;/p&gt;
&lt;p&gt;调用此方法会将响应数据立即发送给用户，但不中断后续代码执行。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;echo 123;
echo 456;

fastcgi_finish_request(); // 此时将响应发送给用户

echo 789;

file_put_contents(&#39;a.txt&#39;, &#39;789&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码在CGI模式下执行，你会得到123456的响应数据，并且会生成a.txt文件，内容为789。&lt;/p&gt;
&lt;p&gt;这个方法的主要用途就是跳过与响应无关的数据处理，提前返回数据给客户端，提高用户体验。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅在CGI模式下可用，其他模式下会报方法不存在的错误&lt;/p&gt;
&lt;p&gt;Laravel中Response的send方法也是用到了这个函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-续&#34;&gt;7、续...&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;后续补充...&lt;/em&gt;&lt;/p&gt;
">PHP中一些好用的技巧</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/8QqIK9WTM/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;excalidraw&#34;&gt;Excalidraw&lt;/h2&gt;
&lt;p&gt;Excalidraw是一个开源的、用于绘制手绘风格草图的项目，GitHub地址为&lt;a href=&#34;https://github.com/excalidraw/excalidraw&#34;&gt;https://github.com/excalidraw/excalidraw&lt;/a&gt;，用它制作的草图效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617677708342.png&#34; alt=&#34;草图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;看起来还不错，但是由于这个项目诞生于国外，所以并不支持中文字体：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;/post-images/1617677730364.png&#34; alt=&#34;草图2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;几个汉字可以说是格格不入了😂。&lt;/p&gt;
&lt;h2 id=&#34;替换字体&#34;&gt;替换字体&lt;/h2&gt;
&lt;p&gt;于是，我找了一些免费的手写字体尝试替换进去，最后找到一个效果还不错的——沐瑶随心手写体。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;/post-images/1617677746929.png&#34; alt=&#34;草图3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;沐瑶随心手写体是完全免费，即使是商用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沐瑶是作者女儿的名字 WoW&lt;br&gt;
字体下载地址: &lt;a href=&#34;https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html&#34;&gt;https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;如果你想要使用的话，可以访问: &lt;a href=&#34;https://danlanhai.gitee.io/excalidraw/&#34;&gt;https://danlanhai.gitee.io/excalidraw/&lt;/a&gt;或&lt;a href=&#34;https://anhoder.github.io/excalidraw/&#34;&gt;https://anhoder.github.io/excalidraw/&lt;/a&gt;。&lt;/p&gt;
">中文手写体Excalidraw</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/dm-3SDHLz/"" data-c="
          &lt;p&gt;PHP8发布已经有一段时间了，新增了不少特性，其中我觉得比较好用的：一个是函数可以指定参数名传参，另外一个就是&lt;strong&gt;注解Attribute&lt;/strong&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;注解&#34;&gt;注解&lt;/h2&gt;
&lt;p&gt;在PHP8之前，PHP语法上是不支持注解的，只能通过反射来获取类、方法或属性的注释，然后通过解析注释来获取需要的元数据。最具代表性的就是注解包&lt;a href=&#34;https://github.com/doctrine/annotations&#34;&gt;doctrine/annotations&lt;/a&gt;，很多框架都有在用。&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Doctrine\Common\Annotations\Annotation\Attribute;
use Doctrine\Common\Annotations\Annotation\Attributes;
use Doctrine\Common\Annotations\Annotation\Target;

/**
 * @Annotation
 * @Target(&amp;quot;CLASS&amp;quot;)
 * @Attributes({
 *     @Attribute(&amp;quot;name&amp;quot;, type=&amp;quot;string&amp;quot;, required=true),
 *     @Attribute(&amp;quot;age&amp;quot;, type=&amp;quot;int&amp;quot;)
 * })
 */
class Student
{
    /**
     * @var string
     */
    private $name;
    
    /**
     * @var int
     */
    private $age
}

/**
 * @Student(name=&amp;quot;anhoder&amp;quot;, age=18)
 */
class Anhoder
{
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在PHP8中，注解Attribute是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;#[Attribute(Attribute::TARGET_CLASS)]
class Student
{
    public function __construct(private string $name, private int $age)
    {
    }
}

#[Student(&#39;anhoder&#39;, 18)]
class Anhoder
{

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;收集注解attribute&#34;&gt;收集注解Attribute&lt;/h2&gt;
&lt;p&gt;PHP8的Attribute数据也需要通过反射来手动获取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$reflection = new ReflectionClass(Anhoder::class);
var_dump($reflection-&amp;gt;getAttributes());
// array(1) {
//   [0]=&amp;gt;
//   object(ReflectionAttribute)#3 (0) {
//   }
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以实现一个Attribute收集器，用于自动收集项目中或其他composer包中的注解信息。&lt;/p&gt;
&lt;h3 id=&#34;1-获取所有包的根目录及namespace&#34;&gt;1. 获取所有包的根目录及namespace&lt;/h3&gt;
&lt;p&gt;通过composer提供的ClassLoader自动加载类，我们获取到所有包的命名空间及对应的根目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 获取Composer的自动加载类
function getComposerLoader()
{
    $loaders = spl_autoload_functions();

    foreach ($loaders as $loader) {
        if (is_array($loader) &amp;amp;&amp;amp; isset($loader[0]) &amp;amp;&amp;amp; $loader[0] instanceof ClassLoader) {
            return $loader[0];
        }
    }
    
    throw new NotFoundException(&#39;Composer class loader&#39;);
}

$composerLoader = getComposerLoader();

// 获取命令空间及目录
$composerLoader-&amp;gt;getPrefixesPsr4();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-加载每个包下的annotationconfig类&#34;&gt;2. 加载每个包下的AnnotationConfig类&lt;/h3&gt;
&lt;p&gt;我们约定：在每个需要收集注解的包下，都放一个AnnotationConfig类，并实现AnnotationConfigInterface接口。用于获取该包下需要扫描的目录及命名空间。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class AnnotationConfig implements AnnotationConfigInterface
{

    /**
     * @inheritDoc
     */
    public static function getAnnotationConfigs(): array
    {

        return [
            &#39;scanDirs&#39; =&amp;gt; [
                __NAMESPACE__ =&amp;gt; __DIR__,
            ],
        ];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上约定条件下，我们需要遍历第一步获取到的根目录，判断其目录下是否有AnnotationConfig类，若有则调用getAnnotationConfigs方法获取其配置。&lt;/p&gt;
&lt;h3 id=&#34;3-解析-收集注解&#34;&gt;3. 解析、收集注解&lt;/h3&gt;
&lt;p&gt;最后一步，就是遍历每个目录下的文件及其对应的类，然后通过反射获取到类、方法、属性及常量的注解信息，并将这些信息存入容器数组中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$namespace = rtrim($namespace, &#39;\\&#39;);
$iterator = new RecursiveDirectoryIterator($dir);

foreach ($iterator as $splFileInfo) {
    $basename = $splFileInfo-&amp;gt;getBasename();
    
    if (!$splFileInfo-&amp;gt;isFile() || $splFileInfo-&amp;gt;getExtension() != &#39;php&#39;) {
        // not php file
        continue;
    }

    // PHP File
    $className = $splFileInfo-&amp;gt;getBasename(&#39;.&#39; . $splFileInfo-&amp;gt;getExtension());
    $class = &amp;quot;{$namespace}\\{$className}&amp;quot;;
    if (class_exists($class)) {
        $reflection = new ReflectionClass($class);
        $attributes = $reflection-&amp;gt;getAttributes();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;封装为composer包&#34;&gt;封装为composer包&lt;/h2&gt;
&lt;p&gt;以上代码都是简单的示例，实际还需要考虑更多，所以我将其做成了一个composer包——&lt;a href=&#34;https://github.com/anhoder/annotations-collector&#34;&gt;anhoder/annotations-collector&lt;/a&gt;。简单的使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;composer require anhoder/annotations-collector
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 &lt;code&gt;AnnotationConfig.php&lt;/code&gt; 文件到你项目的根目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class AnnotationConfig implements AnnotationConfigInterface
{

    public static function getAnnotationConfigs(): array
    {
        return [
            // The dirs need to be scanned
            &#39;scanDirs&#39; =&amp;gt; [
                __NAMESPACE__ =&amp;gt; __DIR__,
            ],
        ];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加Annotation及AnnotationHandler.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Annotation
#[Attribute(Attribute::TARGET_CLASS)]
class ClassAnnotation
{
    public const TEST = &#39;test&#39;;

    private string $test;

    public function __construct(string $test)
    {
        $this-&amp;gt;test = $test;
    }
}

// AnnotationHandler
#[AnnotationHandler(ClassAnnotation::class)]
class ClassAnnotationHandler extends AbstractAnnotationHandler
{
    public function handle()
    {
        // Your logic.
        var_dump($this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;AnnotationHelper::scan();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;附&#34;&gt;附&lt;/h2&gt;
&lt;p&gt;由于注解需要配合反射来使用，其相比正常代码性能较差，而且在php-fpm模式下，每次请求都需要重新获取注解信息，所以&lt;strong&gt;不推荐在php-fpm下使用注解&lt;/strong&gt;，其&lt;strong&gt;更适合一些常驻内存型的项目&lt;/strong&gt;，例如：Swoole、WorkerMan等。&lt;/p&gt;
">自己写个包——PHP8 Attribute收集器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/e-qWPg1ij/"" data-c="
          &lt;p&gt;最近在公司使用swoft写了一个定时爬取数据的项目，上线后跟踪线上日志发现swoft的worker进程会&lt;strong&gt;出现周期性的内存溢出&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Fatal error: Uncaught ErrorException: Allowed memory size of 268435456 bytes exhausted (tried to allocate 262144 bytes)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-分析&#34;&gt;一、分析&lt;/h2&gt;
&lt;p&gt;观察到线上worker进程的内存占用是随时间增长而逐渐上升的，所以排除单次执行导致内存溢出的情况，基本可以确定是项目中的某处代码&lt;strong&gt;存在内存泄漏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，解决问题的关键就在于&lt;strong&gt;如何定位到项目中产生内存泄漏的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二-定位内存泄漏&#34;&gt;二、定位内存泄漏&lt;/h2&gt;
&lt;h3 id=&#34;1-swoole-tracker&#34;&gt;1、Swoole Tracker&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://business.swoole.com/tracker/index&#34;&gt;Swoole Tracker&lt;/a&gt;是Swoole官方提供的分析工具，可以用来检测项目中的内存泄漏问题（&lt;a href=&#34;https://mp.weixin.qq.com/s/oAyToE4aNyU3-_PQ5ii3aw&#34;&gt;使用方法&lt;/a&gt;）。&lt;/p&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;p&gt;Swoole Tracker的安装比较简单，因为它本身就是一个php的扩展，而且是已经编译好的，我们只需要将编译好的动态链接库文件(.so)放到php的扩展目录下，然后在php.ini中加上配置即可。&lt;/p&gt;
&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;
&lt;p&gt;安装完Swoole Tracker扩展后，在相应的代码中加入Swoole Tracker提供的Hook函数，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function onPipeMessage(Server $server, int $srcWorkerId, $message): void
{
    trackerHookMalloc();
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着启动服务，运行一段时间后，在docker容器内执行&lt;code&gt;php -r &amp;quot;trackerAnalyzeLeak();&amp;quot;&lt;/code&gt;即可获取到服务运行时的内存申请信息、内存释放信息以及可能存在内存泄漏的位置。&lt;/p&gt;
&lt;h4 id=&#34;检测结果&#34;&gt;检测结果&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;/post-images/memory_leak.txt&#34;&gt;memory_leak.txt&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件中含命令行颜色代码，可以在命令行使用&lt;code&gt;cat memory_leak.txt&lt;/code&gt;查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是检测结果中可能存在内存泄漏的代码位置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt; The Possible Leak As Malloc Size Keep Growth:
 /var/www/swoft_marketing_engine/vendor/swoft/server/src/Server.php:544 =&amp;gt;  Growth Times : [29];  Growth Size : [181440]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:959 =&amp;gt;  Growth Times : [8];  Growth Size : [2784]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:997 =&amp;gt;  Growth Times : [12];  Growth Size : [17920]
 /var/www/swoft_marketing_engine/vendor/swoft/bean/src/Container.php:413 =&amp;gt;  Growth Times : [24];  Growth Size : [10752]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Database.php:252 =&amp;gt;  Growth Times : [24];  Growth Size : [1536]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Connection/Connection.php:370 =&amp;gt;  Growth Times : [24];  Growth Size : [4608]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据结果，&lt;strong&gt;发现是Swoft框架本身某个位置存在内存泄漏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，检测结果中只有产生内存申请时的代码位置，还不能确定具体是什么地方未释放内存。&lt;/p&gt;
&lt;p&gt;因此，只能换一种思路。&lt;/p&gt;
&lt;h3 id=&#34;2-valgrind&#34;&gt;2、Valgrind&lt;/h3&gt;
&lt;p&gt;尝试另外一款内存泄漏分析神器——valgrind。&lt;/p&gt;
&lt;p&gt;使用后发现分析报告中只会出现相关的C/C++代码，无法定位到具体的PHP代码位置，放弃。&lt;/p&gt;
&lt;h3 id=&#34;3-memory_get_usage&#34;&gt;3、memory_get_usage()&lt;/h3&gt;
&lt;p&gt;使用几种内存泄漏分析工具都无果后，尝试使用最原始的方式——PHP的内置函数&lt;code&gt;memory_get_usage()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大致思路就是在需要调用的函数上下，加上&lt;code&gt;memory_get_usage()&lt;/code&gt;函数，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;var_dump(memory_get_usage());
test();
var_dump(memory_get_usage());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为，正常情况下，在函数调用完成后，Zend引擎会将对应的函数栈销毁，相应的内存会被释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用时，有一些需要注意的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;memory_get_usage()&lt;/code&gt;支持一个布尔类型的参数&lt;code&gt;real_usage&lt;/code&gt;，表示是否获取真实内存大小，其中包括未被使用的内存空间。因为PHP引擎在申请内存时，会一次申请一大块内存，用于后续使用，以减少系统调用的次数。所以，在这里&lt;strong&gt;不要将它设置为true&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果函数中存在循环引用（如：Swoft中ORM的join方法），在函数执行完成后，变量并不会被及时释放，输出内存占用会增加，但是这是正常的。因为当待释放变量达到一定数量或内存达到一定阈值时，PHP的GC才会统一释放掉这些的内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;检查结果&#34;&gt;检查结果&lt;/h4&gt;
&lt;p&gt;这种方法虽然费时费力，但效果还算不错。经过一段时间排查，成功定位到了两处内存泄漏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在协程中使用Redis时，Swoft未在协程结束后释放相应的Redis连接信息；&lt;/li&gt;
&lt;li&gt;Swoft在处理pipeMessage事件结束后未触发协程结束事件，导致协程数据（MySQL、Redis连接信息等）未被释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-解决方案&#34;&gt;三、解决方案&lt;/h2&gt;
&lt;p&gt;既然已经定位到内存泄漏的原因了，解决办法就不难了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协程结束后，手动unset Redis的连接信息；&lt;/li&gt;
&lt;li&gt;在pipeMessgae事件结束后，手动触发协程结束事件，销毁对应协程产生的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-后续&#34;&gt;四、后续&lt;/h2&gt;
&lt;p&gt;经过以上处理后，&lt;strong&gt;截至目前，线上swoft项目的内存占用稳定在50M左右，未出现内存溢出错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此外，针对这两个问题，我在GitHub上向Swoft团队提交了两个相应的issue及修复PR，目前代码已被合并到master。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617677953995.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;/post-images/1617677966544.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;五-总结&#34;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;其实，内存溢出、内存泄漏的情况并不容易发生（单次运行直接爆内存的除外emmm...），只要你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不轻易使用全局变量、静态变量；&lt;/li&gt;
&lt;li&gt;如果不可避免的需要使用到全局变量、静态变量，一定要在用完后unset掉相应的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，在排查过程中，用到的一个挺好用的查看内存占用的工具——smem，可以查看程序的USS、PSS、RSS👍。&lt;/p&gt;
&lt;/blockquote&gt;
">Swoft内存泄漏排查</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/B6gBPbA-S/"" data-c="
          &lt;h2 id=&#34;php函数相关&#34;&gt;PHP函数相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
zend_parse_parameters()     // 解析函数参数
// 例如，s表示字符串, 解析一个字符串类型的参数到name, 及其长度到name_len: 
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &amp;quot;s&amp;quot;, &amp;amp;name, &amp;amp;name_len) == FAILURE) {
    RETURN_NULL();
}

/* 解析参数时的类型代码 */
b: 布尔类型（对应c类型: zend_bool）
l: 整型（long）
d: 浮点型（double）
s: 字符串（char*, int）
r: 资源型（zval*）
a: 数组（zval*）
o: 对象（zval*）
z: zval（zval*）
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：&lt;br&gt;
&lt;img src=&#34;/post-images/1617678458821.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数组操作&#34;&gt;数组操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;array_init(arr)                         // 初始化数组
add_next_index_null(zval*)              // 向数字索引的数组增加null
add_next_index_long(zval*, long)        // ...添加long类型
add_next_index_bool(zval*, 0|1)         // ...添加bool类型
add_next_index_double(zval*, double)  
add_next_index_string(zval*, char*, zend_bool)
add_next_index_zval(zval*, zval*)
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多操作数组的函数: &lt;a href=&#34;https://www.php.net/manual/en/internals2.variables.arrays.php&#34;&gt;https://www.php.net/manual/en/internals2.variables.arrays.php&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
&lt;/blockquote&gt;
">PHP扩展开发中常用的函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/y_zVEbs0X/"" data-c="
          &lt;h2 id=&#34;zval类型相关&#34;&gt;zval类型相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
Z_TYPE(zval)        // 获取zval的类型
Z_TYPE_P(*zval)     // 获取*zval的类型
Z_TYPE_PP(**zval)   // 获取**zval的类型

/* zval类型相关常量 */
IS_NULL         // null 
IS_BOOL         // 布尔
IS_LONG         // 整型
IS_DOUBLE       // 浮点型
IS_STRING       // 字符串
IS_ARRAY        // 数组
IS_OBJECT       // 对象
IS_RESOURCE     // 资源

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;zval值相关&#34;&gt;zval值相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//操作整数的
#define Z_LVAL(zval)			(zval).value.lval
#define Z_LVAL_P(zval_p)		Z_LVAL(*zval_p)
#define Z_LVAL_PP(zval_pp)		Z_LVAL(**zval_pp)

//操作IS_BOOL布尔型的
#define Z_BVAL(zval)			((zend_bool)(zval).value.lval)
#define Z_BVAL_P(zval_p)		Z_BVAL(*zval_p)
#define Z_BVAL_PP(zval_pp)		Z_BVAL(**zval_pp)

//操作浮点数的
#define Z_DVAL(zval)			(zval).value.dval
#define Z_DVAL_P(zval_p)		Z_DVAL(*zval_p)
#define Z_DVAL_PP(zval_pp)		Z_DVAL(**zval_pp)

//操作字符串的值和长度的
#define Z_STRVAL(zval)			(zval).value.str.val
#define Z_STRVAL_P(zval_p)		Z_STRVAL(*zval_p)
#define Z_STRVAL_PP(zval_pp)		Z_STRVAL(**zval_pp)

#define Z_STRLEN(zval)			(zval).value.str.len
#define Z_STRLEN_P(zval_p)		Z_STRLEN(*zval_p)
#define Z_STRLEN_PP(zval_pp)		Z_STRLEN(**zval_pp)

#define Z_ARRVAL(zval)			(zval).value.ht
#define Z_ARRVAL_P(zval_p)		Z_ARRVAL(*zval_p)
#define Z_ARRVAL_PP(zval_pp)		Z_ARRVAL(**zval_pp)

//操作对象的
#define Z_OBJVAL(zval)			(zval).value.obj
#define Z_OBJVAL_P(zval_p)		Z_OBJVAL(*zval_p)
#define Z_OBJVAL_PP(zval_pp)		Z_OBJVAL(**zval_pp)

#define Z_OBJ_HANDLE(zval)		Z_OBJVAL(zval).handle
#define Z_OBJ_HANDLE_P(zval_p)		Z_OBJ_HANDLE(*zval_p)
#define Z_OBJ_HANDLE_PP(zval_p)		Z_OBJ_HANDLE(**zval_p)

#define Z_OBJ_HT(zval)			Z_OBJVAL(zval).handlers
#define Z_OBJ_HT_P(zval_p)		Z_OBJ_HT(*zval_p)
#define Z_OBJ_HT_PP(zval_p)		Z_OBJ_HT(**zval_p)

#define Z_OBJCE(zval)			zend_get_class_entry(&amp;amp;(zval) TSRMLS_CC)
#define Z_OBJCE_P(zval_p)		Z_OBJCE(*zval_p)
#define Z_OBJCE_PP(zval_pp)		Z_OBJCE(**zval_pp)

#define Z_OBJPROP(zval)			Z_OBJ_HT((zval))-&amp;gt;get_properties(&amp;amp;(zval) TSRMLS_CC)
#define Z_OBJPROP_P(zval_p)		Z_OBJPROP(*zval_p)
#define Z_OBJPROP_PP(zval_pp)		Z_OBJPROP(**zval_pp)

#define Z_OBJ_HANDLER(zval, hf) 	Z_OBJ_HT((zval))-&amp;gt;hf
#define Z_OBJ_HANDLER_P(zval_p, h)	Z_OBJ_HANDLER(*zval_p, h)
#define Z_OBJ_HANDLER_PP(zval_p, h)		Z_OBJ_HANDLER(**zval_p, h)

#define Z_OBJDEBUG(zval,is_tmp)		(Z_OBJ_HANDLER((zval),get_debug_info)?	\
						Z_OBJ_HANDLER((zval),get_debug_info)(&amp;amp;(zval),&amp;amp;is_tmp TSRMLS_CC): \
						(is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) 
#define Z_OBJDEBUG_P(zval_p,is_tmp)	Z_OBJDEBUG(*zval_p,is_tmp) 
#define Z_OBJDEBUG_PP(zval_pp,is_tmp)	Z_OBJDEBUG(**zval_pp,is_tmp)

//操作资源的
#define Z_RESVAL(zval)			(zval).value.lval
#define Z_RESVAL_P(zval_p)		Z_RESVAL(*zval_p)
#define Z_RESVAL_PP(zval_pp)		Z_RESVAL(**zval_pp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建zval&#34;&gt;创建zval&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ALLOC_ZVAL              // PHP 7中移除
ALLOC_INIT_ZVAL         // PHP 7中移除
MAKE_STD_ZVAL           // PHP 7中移除
// 例如：
zval *val; MAKE_STD_ZVAL(val);

ZVAL_LONG(*zval, long)      // 将整型值赋给*zval
ZVAL_NULL(*zval)            // null
ZVAL_BOOL(*zval, int)       // bool
ZVAL_TRUE(*zval)            // true
ZVAL_FALSE(*zval)           // false
ZVAL_LONG(*zval, long)      // long
ZVAL_DOUBLE(*zval, double)  // double
ZVAL_STRINGL(*zval,str,len,dup); // string with length
ZVAL_STRING(*zval, str, dup)     // string, dup指明了该字符串是否需要被复制。 值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv， 为 0 时则是直接把str的地址赋值给zval。
ZVAL_RESOURCE(*zval, res);       // resource
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数相关&#34;&gt;函数相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_NUM_ARGS()             // 获取函数参数的数量

RETVAL_STRING(s)            // 函数返回字符串
RETURN_STRING(s)            // 函数返回字符串, #define RETURN_STRING(s) { RETVAL_STRING(s); return; }
RETURN_NULL()               // 函数返回null
RETURN_TRUE()               // 函数返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：&lt;br&gt;
&lt;img src=&#34;media/16078683686223/16078723189095.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;数组操作&#34;&gt;数组操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_HASH_FOREACH_VAL(ht, val)
ZEND_HASH_FOREACH_KEY(ht, h, key) 
ZEND_HASH_FOREACH_PTR(ht, ptr)
ZEND_HASH_FOREACH_NUM_KEY(ht, h) 
ZEND_HASH_FOREACH_STR_KEY(ht, key)
ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)
ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)

// 例如：
ZEND_HASH_FOREACH_KEY_VAL(arr_hash, num_key, key, val) {
    //if (key) { //HASH_KEY_IS_STRING
    //}
    PHPWRITE(Z_STRVAL_P(val), Z_STRLEN_P(val));
    php_printf(&amp;quot;\n&amp;quot;);
}ZEND_HASH_FOREACH_END();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;符号表&#34;&gt;符号表&lt;/h2&gt;
&lt;p&gt;PHP的变量存储在符号表中，不同作用域有不同的符号表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _zend_executor_globals {
    ...
    HashTable symbol_table;         // 全局符号表
    HashTable *active_symbol_table; // 当前作用域符号表
    ...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;EG(active_symbol_table)
EG(symbol_table)
ZEND_SET_SYMBOL(symbol, var_name, val)  // 设置变量到符号表
// 例如：
ZEND_SET_SYMBOL( EG(active_symbol_table) ,  &amp;quot;foo&amp;quot; , fooval);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
&lt;/blockquote&gt;
">PHP扩展开发中常用的宏函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/npa_TQCOL/"" data-c="
          &lt;p&gt;musicfox是一款使用Dart编写的网易云音乐命令行程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://badgen.net/github/release/anhoder/musicfox&#34; alt=&#34;last release&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://badgen.net/github/license/anhoder/musicfox&#34; alt=&#34;GitHub&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://badgen.net/github/tag/anhoder/musicfox&#34; alt=&#34;Last Tag&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://badgen.net/github/stars/anhoder/musicfox&#34; alt=&#34;Star&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://badgen.net/github/last-commit/anhoder/musicfox&#34; alt=&#34;GitHub last commit&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-为什么做这个项目&#34;&gt;一、为什么做这个项目&lt;/h2&gt;
&lt;p&gt;在开始这个项目的之前，其实是已经有一个基于命令行的网易云音乐项目——&lt;a href=&#34;https://github.com/darknessomi/musicbox&#34; title=&#34;musicbox&#34;&gt;musicbox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我也使用它听了很长一段时间的歌了，其中还贡献过一些代码，修复几个小问题。那为什么还要重新造一个轮子呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;musicbox缺少一些我特别想要的功能&lt;/li&gt;
&lt;li&gt;musicbox使用python进行编写，我对python并不是很熟悉，所以修改或者新增功能时比较麻烦&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二-为什么使用dart&#34;&gt;二、为什么使用Dart&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dart的语法极像Java，我本身也学过Java，因此学习成本较低；&lt;/li&gt;
&lt;li&gt;Dart可以将代码编译成能在三大平台（Windows、Linux、Mac）上直接运行的可执行程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-效果预览&#34;&gt;三、效果预览&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617678066308.png&#34; alt=&#34;欢迎界面&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;/post-images/1617678078304.png&#34; alt=&#34;主界面1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;/post-images/1617678089104.png&#34; alt=&#34;主界面2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;四-安装&#34;&gt;四、安装&lt;/h2&gt;
&lt;p&gt;依赖mpg123，&lt;strong&gt;必须先安装mpg123&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;mac&#34;&gt;Mac&lt;/h3&gt;
&lt;p&gt;提供两种方式安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入到&lt;a href=&#34;https://github.com/anhoder/musicfox/releases/latest&#34; title=&#34;Release&#34;&gt;Release&lt;/a&gt;下载musicfox.mac文件，在iTerm或Terminal中运行&lt;/li&gt;
&lt;li&gt;使用brew安装：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew tap anhoder/musicfox &amp;amp;&amp;amp; brew install musicfox
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;linuxubuntu&#34;&gt;Linux(Ubuntu)&lt;/h3&gt;
&lt;p&gt;进入到&lt;a href=&#34;https://github.com/anhoder/musicfox/releases/latest&#34; title=&#34;Release&#34;&gt;Release&lt;/a&gt;下载musicfox.ubuntu文件，在终端中运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本人没有Linux系统，该执行文件是在WSL2(Ubuntu 2004)下打包的，不确定其他Linux系统是否也能正常使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;
&lt;p&gt;下载&lt;a href=&#34;./bin/musicfox.exe&#34; title=&#34;Windows可执行文件&#34;&gt;Windows可执行文件&lt;/a&gt;，在命令行(推荐Windows Terminal)中运行即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows下存在几个已知问题，暂时没有解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂停时会延迟几秒，播放时不会延迟&lt;/li&gt;
&lt;li&gt;登录或搜索输入时，会吞掉第一个字符&lt;/li&gt;
&lt;li&gt;上、下、左、右及ESC键无法监听，只能使用字母代替这些操作&lt;/li&gt;
&lt;li&gt;命令行窗口大小发生变化后，UI会变乱（因为Windows不支持resize事件）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;因为存在以上问题，所以推荐在WSL下使用，WSL的声音转发可以参考我的另一个&lt;a href=&#34;https://github.com/anhoder/wsl-audio-musicbox&#34; title=&#34;项目&#34;&gt;项目&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;五-通知功能&#34;&gt;五、通知功能&lt;/h2&gt;
&lt;h3 id=&#34;mac-2&#34;&gt;Mac&lt;/h3&gt;
&lt;p&gt;Mac下默认使用&lt;code&gt;AppleScript&lt;/code&gt;发送通知。如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;/post-images/1617678108326.png&#34; alt=&#34;AppleScript&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果想要更好的通知体验，可以安装&lt;code&gt;terminal-notifier&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install terminal-notifier
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;/post-images/1617678123055.png&#34; alt=&#34;terminal-notifier&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;
&lt;p&gt;Linux可以安装&lt;code&gt;libnotify-bin&lt;/code&gt;来使用通知功能（未经测试）&lt;/p&gt;
&lt;h3 id=&#34;windows-2&#34;&gt;Windows&lt;/h3&gt;
&lt;p&gt;Windows下可以安装&lt;code&gt;notifu&lt;/code&gt;实现通知，体验不太好（没找到其他更好的通知工具）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，如果你有更好的命令行通知程序，你也可以自己实现INotifier接口达到你想要的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;abstract class INotifier {
  // 检查该通知程序是否可用
  bool isAvailable();

  // 发送消息
  void send(String message, {String title, String subtitle, String soundName, String groupID, String activateID, String appIcon, String contentImage, String openURL, String executeCmd});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;六-使用&#34;&gt;六、使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ musicfox
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;按键：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;h/H/LEFT&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;h&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l/L/RIGHT&lt;/td&gt;
&lt;td&gt;右&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;l&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k/K/UP&lt;/td&gt;
&lt;td&gt;上&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;k&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;j/J/DOWN&lt;/td&gt;
&lt;td&gt;下&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;j&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q/Q&lt;/td&gt;
&lt;td&gt;退出&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;q&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;space&lt;/td&gt;
&lt;td&gt;暂停/播放&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;
&lt;td&gt;上一曲&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;]&lt;/td&gt;
&lt;td&gt;下一曲&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减小音量&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;加大音量&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n/N/ENTER&lt;/td&gt;
&lt;td&gt;进入选中的菜单&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b/B/ESC&lt;/td&gt;
&lt;td&gt;返回上级菜单&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w/W&lt;/td&gt;
&lt;td&gt;退出并退出登录&lt;/td&gt;
&lt;td&gt;Windows只能使用&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;切换播放方式&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;心动模式(仅在歌单中时有效)&lt;/td&gt;
&lt;td&gt;Windows下使用&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;喜欢当前播放歌曲&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;喜欢当前选中歌曲&lt;/td&gt;
&lt;td&gt;Windows下使用&lt;code&gt;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;当前播放歌曲移除出喜欢&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;当前选中歌曲移除出喜欢&lt;/td&gt;
&lt;td&gt;Windows下使用&lt;code&gt;&#39;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;标记当前播放歌曲为不喜欢&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;标记当前选中歌曲为不喜欢&lt;/td&gt;
&lt;td&gt;Windows下使用&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;七-todo&#34;&gt;七、TODO&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5404958&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5404958&#34;&gt; 我的歌单&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8809478&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8809478&#34;&gt; 每日推荐歌曲&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1403934&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1403934&#34;&gt; 每日推荐歌单&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7939705&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7939705&#34;&gt; 私人FM&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3758193&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3758193&#34;&gt; 歌词显示&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3983759&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3983759&#34;&gt; 欢迎界面&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2393858&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2393858&#34;&gt; 搜索&lt;/label&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6896166&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6896166&#34;&gt; 按歌曲&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3978659&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3978659&#34;&gt; 按歌手&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7465361&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7465361&#34;&gt; 按歌词&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4981876&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4981876&#34;&gt; 按歌单&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2488303&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2488303&#34;&gt; 按专辑&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6909541&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6909541&#34;&gt; 按用户&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1628652&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1628652&#34;&gt; 排行榜&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7896952&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7896952&#34;&gt; 精选歌单&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1792411&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1792411&#34;&gt; 最新专辑&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-974991&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-974991&#34;&gt; 热门歌手&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1740444&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1740444&#34;&gt; 云盘&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8336615&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8336615&#34;&gt; 播放方式切换&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9989566&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9989566&#34;&gt; 喜欢/取消喜欢&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2467415&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2467415&#34;&gt; 心动模式/智能模式&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-702152&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-702152&#34;&gt; 音乐电台&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9784043&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9784043&#34;&gt; 将部分设置转化为文件可配置&lt;/label&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1197187&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1197187&#34;&gt; 欢迎界面的欢迎语&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-258147&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-258147&#34;&gt; 欢迎界面时长&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5408746&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5408746&#34;&gt; 主题色&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9996738&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9996738&#34;&gt; 歌词显示行数&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9187268&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9187268&#34;&gt; ...&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;八-伴生项目&#34;&gt;八、伴生项目&lt;/h2&gt;
&lt;p&gt;在该项目的开发过程中，我将一些通用的功能模块单独抽离出来，做成了几个伴生项目：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/anhoder/mp3_player&#34; title=&#34;mp3_player&#34;&gt;mp3_player&lt;/a&gt;: dart命令行调用mpg123播放音乐&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/anhoder/netease_music_request&#34; title=&#34;netease_music_request&#34;&gt;netease_music_request&lt;/a&gt;: Dart实现的网易云音乐接口库，使用Dio发起请求，CookieJar管理Cookie信息&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/anhoder/colorful_cmd&#34; title=&#34;colorful_cmd&#34;&gt;colorful_cmd&lt;/a&gt;: 使用dart实现的一些命令行UI组件，如：WindowUI命令行窗口应用UI、RainbowProgress彩虹进度条、NotifierProxy三大平台通知代理、ColorText颜色文本...&lt;br&gt;
&lt;img src=&#34;/post-images/1617678161539.png&#34; alt=&#34;command&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/post-images/1617678173841.png&#34; alt=&#34;rainbow_progress&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/post-images/1617678188194.png&#34; alt=&#34;window_ui&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/post-images/1617678202350.png&#34; alt=&#34;window_ui2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;九-感谢&#34;&gt;九、感谢&lt;/h2&gt;
&lt;p&gt;感谢以下项目及其贡献者们（不限于）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/darknessomi/musicbox&#34; title=&#34;musicbox&#34;&gt;musicbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Binaryify/NeteaseCloudMusicApi&#34; title=&#34;NeteaseCloudMusicApi&#34;&gt;NeteaseCloudMusicApi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/DirectMyFile/console.dart&#34; title=&#34;console.dart&#34;&gt;console.dart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">又一个命令行版网易云音乐——musicfox</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/O4IVHtR2w/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;1-imi是什么&#34;&gt;1、imi是什么&lt;/h2&gt;
&lt;p&gt;imi与Swoft、Hyperf一样，是一个基于Swoole的PHP框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同之处在于，Swoft与Hyperf是主要针对微服务推出的框架，而imi致力于单体应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外，imi还支持代码热更新，只要监听的文件发生了更改，imi就会在很短的时间内重启服务。大体实现是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 在worker进程的启动事件onWorkerStart中，载入相应的PHP文件。&lt;/p&gt;
&lt;p&gt;② 当监听到代码更新后，向swoole发送一个SIGUSR1信号，swoole会重启所有的worker进程，并触发onWorkerStart事件，重新载入相应的PHP文件。此时，worker进程就是最新的代码了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这个功能对于线上服务没有很大的帮助，但是却可以大大提高开发时效率。&lt;/p&gt;
&lt;h2 id=&#34;2-imi的路由管理&#34;&gt;2、imi的路由管理&lt;/h2&gt;
&lt;h3 id=&#34;注解&#34;&gt;注解&lt;/h3&gt;
&lt;p&gt;imi路由的管理方式与Swoft框架类似。使用&lt;strong&gt;注解&lt;/strong&gt;来管理路由，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace Test;
 
use Imi\Controller\HttpController;
use Imi\Server\Route\Annotation\Route;
use Imi\Server\Route\Annotation\Action;
use Imi\Server\Route\Annotation\Controller;
 
/**
 * @Controller(prefix=&amp;quot;home&amp;quot;)
 */
class Index extends HttpController
{
    /**
     * @Action
     * @Route(url=&amp;quot;/index&amp;quot;)
     */
    public function index()
    {
        // 使用/index可以访问到
        return $this-&amp;gt;response-&amp;gt;write(&#39;hello imi!&#39;);
    }
    
    /**
     * @Action
     * @Route(url=&amp;quot;test&amp;quot;)
     */
    public function test()
    {
        // 使用/home/test可以访问到
        return $this-&amp;gt;response-&amp;gt;write(&#39;hello test!&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码中，&lt;code&gt;Index&lt;/code&gt;类上添加了&lt;code&gt;@Controller&lt;/code&gt;注解，标识该类为一个控制器，并设置路由前缀为&lt;code&gt;home&lt;/code&gt;；&lt;code&gt;index&lt;/code&gt;及&lt;code&gt;test&lt;/code&gt;方法上添加了&lt;code&gt;Action&lt;/code&gt;、&lt;code&gt;Route&lt;/code&gt;注解，并分别为它们设置路由为&lt;code&gt;/home&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用注解管理路由可以很直观地将控制器的方法和路由对应起来，但是它也会带来一些缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当路由越来越多时，路由的管理就变得很复杂。例如：我们需要为一批路由添加一个中间件，此时，就需要修改很多文件。&lt;/li&gt;
&lt;li&gt;路由结构不够清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;当然，imi也支持使用配置的方式管理路由：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;return [
    &#39;route&#39; =&amp;gt; [
        [
            &#39;controller&#39; =&amp;gt; \ImiDemo\HttpDemo\MainServer\Controller\Test::class,
            &#39;method&#39; =&amp;gt; &#39;index&#39;,
            &#39;route&#39; =&amp;gt; [
                &#39;url&#39; =&amp;gt; &#39;/test&#39;,
                // &#39;method&#39;    =&amp;gt;    &#39;PUT&#39;,
                // &#39;method&#39;    =&amp;gt;    [&#39;GET&#39;, &#39;POST&#39;],
                // &#39;domain&#39;    =&amp;gt;    &#39;{name}.xxx.com&#39;,
            ],
        ],
     ]
];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，这种方式存在多重嵌套，可读性并不高。&lt;/p&gt;
&lt;p&gt;既然如此，还有什么其他路由管理方式呢？🤔&lt;/p&gt;
&lt;h2 id=&#34;3-imi-route&#34;&gt;3、imi-route&lt;/h2&gt;
&lt;p&gt;我认为laravel的路由管理方式是很方便且易读的，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::group([&#39;middleware&#39; =&amp;gt; [&#39;auth&#39;]], function () {
    Route::get(&#39;/auth/userinfo&#39;, &#39;AuthController@getUser&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，我编写了一个组件——&lt;a href=&#34;https://github.com/anhoder/imi-route&#34;&gt;&lt;code&gt;imi-route&lt;/code&gt;&lt;/a&gt;，希望可以将laravel路由管理的基本功能应用到在imi框架中去。&lt;/p&gt;
&lt;h3 id=&#34;基本实现思路&#34;&gt;基本实现思路&lt;/h3&gt;
&lt;p&gt;首先，我们需要知道imi框架在启动时是如何加载相关路由的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析应用目录下的所有文件，通过反射获取所有类的注释&lt;/li&gt;
&lt;li&gt;注释通过字符串解析后得到相应注解，例如：路由注解为&lt;code&gt;RouteAnnotation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将所有的路由注解添加到HttpRoute中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的流程都是在服务启动时进行处理，得到路由结果会常驻内存。&lt;/p&gt;
&lt;p&gt;而**&lt;code&gt;imi-route&lt;/code&gt;就是在服务启动时，将存储的路由转化为路由注解，添加到HttpRoute中。**&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;1、使用composer安装依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;composer require alanalbert/imi-route
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、将下列代码添加到项目根目录的&lt;code&gt;Main.php&lt;/code&gt;文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
namespace ImiApp;

use Imi\Main\AppBaseMain;
  
class Main extends AppBaseMain
{
  public function __init()
  {
      \Alan\ImiRoute\Route::init(); // Add this line
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、在项目根目录下，创建&lt;code&gt;route/route.php&lt;/code&gt;目录及文件，在&lt;code&gt;route.php&lt;/code&gt;文件中，你就可以管理你的路由了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;/**
 * @var $router Route
 */

use Alan\ImiRoute\Route;
use ImiApp\ApiServer\Controller\IndexController;
use ImiApp\ApiServer\Middleware\Test2Middleware;
use ImiApp\ApiServer\Middleware\TestMiddleware;

$router-&amp;gt;group([&#39;middleware&#39; =&amp;gt; TestMiddleware::class], function (Route $router) {

    $router-&amp;gt;group(
        [
            &#39;middleware&#39; =&amp;gt; Test2Middleware::class, 
            &#39;ignoreCase&#39; =&amp;gt; true, 
            &#39;prefix&#39; =&amp;gt; &#39;prefix&#39;
        ], function (Route $router) {
        $router-&amp;gt;get(&#39;hi&#39;, &#39;ImiApp\ApiServer\Controller\IndexController@index&#39;);
    });

    $router-&amp;gt;any(&#39;/hi/api/abc&#39;, [IndexController::class, &#39;index&#39;]);

    $router-&amp;gt;any(&#39;/hi/api/{time}&#39;, [IndexController::class, &#39;api&#39;]);

});

$router-&amp;gt;group([&#39;prefix&#39; =&amp;gt; &#39;prefix&#39;], function (Route $router) {
    $router-&amp;gt;get(&#39;/TEST/{time}&#39;, [IndexController::class, &#39;api&#39;]);
});
&lt;/code&gt;&lt;/pre&gt;
">使用laravel的方式管理imi的路由</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/1Es4mN1Hn/"" data-c="
          &lt;p&gt;主要实现思路是使用pulseaudio进行音频转发，&lt;a href=&#34;https://github.com/anhoder/wsl-audio-musicbox&#34;&gt;wsl-audio-musicbox&lt;/a&gt;项目主要是为了简化WSL与Windows之间通信转发的配置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以实现在WSL中使用musicbox播放歌曲（&lt;strong&gt;给个Star吧~~&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;项目依赖&#34;&gt;项目依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于WSL2，WSL1未进行测试&lt;/li&gt;
&lt;li&gt;基于ubuntu1804，其他需要修改代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;使用pulseaudio软件将音频数据信号转发到Windows上，本项目只是将繁杂的配置进行自动化处理，并可以实现开机自启动&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows下安装pulseaudio软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载或clone本项目，将auto、etc目录移动或覆盖到pulseaudio的根目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动WSL，安装pulseaudio: &lt;code&gt;sudo apt install pulseaudio&lt;/code&gt;，如果没有php环境，执行&lt;code&gt;sudo apt install php-cli&lt;/code&gt;进行安装。&lt;strong&gt;确保/etc/wsl.conf中有配置项&lt;/strong&gt;：&lt;code&gt;generateResolvConf = true&lt;/code&gt;（如果没有，需要添加上，并&lt;strong&gt;重启电脑&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows回到pulseaudio根目录，手动运行&lt;code&gt;auto&lt;/code&gt;目录下的&lt;code&gt;start.bat&lt;/code&gt;，出现&lt;code&gt;成功&lt;/code&gt;表明一切顺利。（&lt;strong&gt;如果你在WSL中使用的不是zsh，则需要打开&lt;code&gt;auto/start.bat&lt;/code&gt;文件，将ubuntu1804.exe run &amp;quot;./start.php &lt;code&gt;echo ~/.zshrc&lt;/code&gt; &amp;amp;&amp;amp; source ~/.zshrc&amp;quot;中的&lt;code&gt;~/.zshrc&lt;/code&gt;修改为你正在使用的环境变量文件，例如&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关闭WSL并重新打开&lt;/strong&gt;，运行&lt;code&gt;paplay -p /mnt/c/Windows/Media/Alarm04.wav&lt;/code&gt;，如果有美妙的声音播放出来，恭喜你，音频转发成功了！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你不想每次开机都手动执行一次&lt;code&gt;start.bat&lt;/code&gt;，可以打开&lt;code&gt;auto/start.vbs&lt;/code&gt;文件，将其中的&lt;code&gt;.\start.bat&lt;/code&gt;替换为你电脑&lt;code&gt;start.bat&lt;/code&gt;文件的&lt;strong&gt;绝对路径&lt;/strong&gt;，并将start.vbs移动到Windows的自启动目录下（win+R运行&lt;code&gt;shell:startup&lt;/code&gt;即可打开该目录）。重启试试看吧~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用musicbox&#34;&gt;使用musicbox&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;只需要根据musicbox项目的Linux系统安装指引进行安装即可~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617678267320.png&#34; alt=&#34;musicbox&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Windows的WSL音频解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/bm-uHUKS-/"" data-c="
          &lt;p&gt;最近总觉得我的博客主题有点丑，于是趁着假期优化一下（&lt;em&gt;&lt;strong&gt;调样式真的累，特别是对于强迫症患者。。。😭&lt;/strong&gt;&lt;/em&gt;）&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;mweb是什么&#34;&gt;MWeb是什么&lt;/h2&gt;
&lt;p&gt;MWeb是Mac OS上的一个Markdown编辑器，其具备很多功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布图片到图床&lt;/li&gt;
&lt;li&gt;直接发布文章到WordPress、印象笔记、语雀等站点&lt;/li&gt;
&lt;li&gt;Markdown导出为图片、PDF、富文本、HTML等&lt;/li&gt;
&lt;li&gt;设置页面主题&lt;/li&gt;
&lt;li&gt;将Markdown编译为静态站点&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，MWeb是一款很优质的Markdown编辑器，搭配上Github Pages及Gitee Pages，简直不要太爽。&lt;/p&gt;
&lt;h2 id=&#34;atheme主题&#34;&gt;Atheme主题&lt;/h2&gt;
&lt;p&gt;本文介绍的Atheme就是一款基于MWeb编辑器的可配置的静态站点主题。它是我在MWeb自带主题——&lt;strong&gt;BulmaCSS&lt;/strong&gt;的基础上进行添加、修改、优化而出现的产物。以下主要介绍这个主题的主要功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网站菜单&lt;/li&gt;
&lt;li&gt;站长信息及联系方式&lt;/li&gt;
&lt;li&gt;公告、分类及标签&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;随机图片&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暗黑模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用Github评论&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;看板娘&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google Analysis、Baidu Analysis&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;span style=&#34;color: #F4635F;&#34;&gt;
&lt;p&gt;&lt;strong&gt;！多图预警！&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;！！多图预警！！&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;！！！多图预警！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/span&gt;
&lt;h3 id=&#34;1-网站菜单&#34;&gt;1、网站菜单&lt;/h3&gt;
&lt;p&gt;网站菜单是出现在站点头部的导航条，它是MWeb提供的基础功能，可以在&lt;code&gt;偏好设置-&amp;gt;网站扩展-&amp;gt;网站菜单&lt;/code&gt;中进行个性化设置。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617678301142.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;站点效果&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;/post-images/1617678310288.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-联系方式及站长信息&#34;&gt;2、联系方式及站长信息&lt;/h3&gt;
&lt;p&gt;联系方式、站长信息是出现在Header中的内容：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;/post-images/1617678319092.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;它们是Atheme主题提供的个性化功能，可以在&lt;code&gt;偏好设置-&amp;gt;网站扩展-&amp;gt;网站扩展设置&lt;/code&gt;中进行配置，支持的配置项有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;站长名&lt;/li&gt;
&lt;li&gt;站长首页&lt;/li&gt;
&lt;li&gt;站点icon&lt;/li&gt;
&lt;li&gt;站长的头像&lt;/li&gt;
&lt;li&gt;微博主页&lt;/li&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;li&gt;Github&lt;/li&gt;
&lt;li&gt;Facebook&lt;/li&gt;
&lt;li&gt;Instagram&lt;/li&gt;
&lt;li&gt;YouTube&lt;/li&gt;
&lt;li&gt;Stack Overflow&lt;/li&gt;
&lt;li&gt;email&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-公告-分类及标签&#34;&gt;3、公告、分类及标签&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;公告也是Atheme主题提供的配置功能，可以在&lt;code&gt;偏好设置-&amp;gt;网站扩展-&amp;gt;网站扩展设置&lt;/code&gt;进行自定义配置。&lt;/li&gt;
&lt;li&gt;分类及标签则是根据具体文章的分类、标签进行生成&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;/post-images/1617678329601.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-随机图片&#34;&gt;4、随机图片&lt;/h3&gt;
&lt;p&gt;随机图片，是在博客列表中针对每篇博客随机获取一张图片进行展示，随机图片的API也支持配置，我目前使用的有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://picsum.photos/1024/&lt;/li&gt;
&lt;li&gt;https://source.unsplash.com/random/1024x&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，这个API必须支持设置图片的大小，并设置宽度为1024&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;/post-images/1617678345063.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-暗黑模式&#34;&gt;5、暗黑模式&lt;/h3&gt;
&lt;p&gt;暗黑模式暂不支持配置，目前是根据浏览器的外观偏好进行自动调整&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;/post-images/1617678352018.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;/post-images/1617678357950.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-使用github评论&#34;&gt;6、使用Github评论&lt;/h3&gt;
&lt;p&gt;使用Github账号进行评论是集成了utteranc插件，在使用之前需要准备一个Github仓库用于存放评论内容，并在配置(utteranc repo)中填入仓库名，例如：anhoder/blog-comment。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;/post-images/1617678363855.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;该模块主题也会根据日间、暗黑模式在github-light及github-dark之间进行切换。&lt;/p&gt;
&lt;p&gt;Github头像👥可能会因为国内网络原因加载失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-看板娘&#34;&gt;7、看板娘&lt;/h3&gt;
&lt;p&gt;看板娘是出现在站点右下角，悬浮着的小人物或宠物。目前支持两种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;血小板plt&lt;/li&gt;
&lt;li&gt;黑猫或白猫&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;/post-images/1617678371333.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;8-google-analysis-baidu-analysis&#34;&gt;8、Google Analysis、Baidu Analysis&lt;/h3&gt;
&lt;p&gt;该功能主要用于统计用户访问数，分析用户。你只需要在设置中配置Google Analysis ID及Baidu分析ID即可，也可以同时使用两个统计方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百度分析ID为：&lt;code&gt;https://hm.baidu.com/hm.js?&lt;/code&gt;后面的一串字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总述&#34;&gt;总述&lt;/h2&gt;
&lt;p&gt;以上就是Atheme主题目前的核心功能介绍，预览站点：&lt;code&gt;https://danlanhai.gitee.io&lt;/code&gt;或&lt;code&gt;https://anhoder.github.io&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果以上内容对你有帮助或让你很感兴趣，&lt;strong&gt;请点击左下角「&lt;span style=&#34;color:#028cca;&#34;&gt;阅读原文&lt;/span&gt;」，给个Star吧~~&lt;/strong&gt;&lt;/p&gt;
">Atheme——基于MWeb的静态站点主题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/lzFgc_WHb/"" data-c="
          &lt;p&gt;使用Docker Compose将之前使用Docker搭建的PHP开发环境进行编排。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是docker-compose&#34;&gt;什么是Docker Compose？&lt;/h2&gt;
&lt;p&gt;Docker Compose是Docker官方编排项目之一，可以快速部署应用。&lt;/p&gt;
&lt;p&gt;其使用一个单独的YAML文件（docker-compose.yml）来定义一组相关联的应用容器为一个项目。&lt;/p&gt;
&lt;p&gt;Docker Compose不是必须使用的，你也可以只使用Docker来构建项目。Docker Compose只是提供一种更简单方便的方式来管理应用容器。&lt;/p&gt;
&lt;h2 id=&#34;编排php开发环境&#34;&gt;编排PHP开发环境&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;

## 网络
networks:
    frontend:
        driver: bridge
    backend:
        driver: bridge

services:
    ## PHP-FPM
    php-fpm:
        container_name: alan_php-fpm # 容器名
        build: 
            context: ./php-fpm
        volumes: 
            - ${WEBSITES_DIR}:/home/www # 站点目录
            - ${PHP_FPM_LOG_DIR}:/var/log/php-fpm # php-fpm日志
            - ${PHP_FPM_INI}:/usr/local/etc/php # php-fpm配置文件
        ports: 
            - &amp;quot;${PHP_FPM_PORT}:9000&amp;quot; # php-fpm端口
            - &amp;quot;${SWOFT_PORT}:18306&amp;quot;  # 预留swoft端口
        networks:
            - backend 

        
    ## Nginx
    nginx:
        container_name: alan_nginx # 容器名
        build:
            context: ./nginx 
        volumes: 
            - ${WEBSITES_DIR}:/home/www # 站点目录
            - ${NGINX_LOG_DIR}:/var/log/nginx # Nginx日志
            - ${NGINX_CONF}:/etc/nginx/conf.d # Nginx配置文件
        ports: 
            - &amp;quot;${NGINX_PORT}:80&amp;quot; # Nginx端口
        depends_on:
            - php-fpm # 依赖与php-fpm
        networks:
            - frontend
            - backend

    
    ## MySQL
    mysql:
        container_name: alan_mysql # 容器名
        build: 
            context: ./mysql
        volumes: 
            - ${MYSQL_DATA}:/var/lib/mysql # MySQL数据存储位置
            - ${MYSQL_CONF}:/etc/mysql/conf.d # MySQL配置文件
        ports: 
            - &amp;quot;${MYSQL_PORT}:3306&amp;quot; # MySQL端口
        environment:
            MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} # MySQL的root密码
            MYSQL_USER: ${MYSQL_USER} # MySQL用户
            MYSQL_PASSWORD: ${MYSQL_PASSWORD} # MySQL密码
            MYSQL_ALLOW_EMPTY_PASSWORD: ${MYSQL_ALLOW_EMPTY_PASSWORD} # 是否允许空密码
        networks:
            - backend

    
    ## Redis
    redis:
        container_name: alan_redis #容器名
        build: 
            context: ./redis
        ports: 
            - &amp;quot;${REDIS_PORT}:6379&amp;quot; # Redis端口
        networks:
            - backend

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的变量（例如：${REDIS_PORT}）可以在.env文件中进行自定义。&lt;/p&gt;
&lt;h2 id=&#34;env环境变量文件示例&#34;&gt;ENV环境变量文件示例&lt;/h2&gt;
&lt;p&gt;.env配置文件的样例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-env&#34;&gt;# web站点目录
WEBSITES_DIR=./www


## PHP-FPM
# PHP-FPM日志
PHP_FPM_LOG_DIR=./logs/php-fpm

# PHP-FPM配置
PHP_FPM_INI=./php-fpm/php

# PHP-FPM端口
PHP_FPM_PORT=9000

# SWOFT端口
SWOFT_PORT=18306


## Nginx
# Nginx日志
NGINX_LOG_DIR=./logs/nginx

# Nginx配置
NGINX_CONF=./nginx/sites

# Nginx端口
NGINX_PORT=8081


## MySQL
# MySQL数据
MYSQL_DATA=./data

# MySQL配置
MYSQL_CONF=./mysql/conf.d

# MySQL端口
MYSQL_PORT=3306


## Redis
# Redis端口
REDIS_PORT=6379
&lt;/code&gt;&lt;/pre&gt;
">初探Docker---使用Docker Compose编排容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/oHxfCQ20G/"" data-c="
          &lt;p&gt;使用Dockerfile搭建PHP开发环境（之后添加docker-compose），项目地址见&lt;strong&gt;原文链接&lt;/strong&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-编写dockerfile&#34;&gt;一、编写Dockerfile&lt;/h2&gt;
&lt;h3 id=&#34;1-php-fpm&#34;&gt;1. PHP-FPM&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM php:7.2-fpm

LABEL maintainer=&amp;quot;AlanAlbert&amp;quot; version=&amp;quot;1.0&amp;quot; description=&amp;quot;php-fpm(php 7.2)&amp;quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 复制php配置文件、php-fpm配置文件
COPY php.ini /usr/local/etc/php/
COPY php-fpm.conf /usr/local/etc/
COPY php-fpm.d/* /usr/local/etc/php-fpm.d/

# 安装PHP扩展——swoole、redis、pdo_mysql、mysqli
RUN docker-php-ext-install pdo_mysql mysqli \
    &amp;amp;&amp;amp; pecl install redis swoole \
    &amp;amp;&amp;amp; docker-php-ext-enable redis swoole

# 挂载站点目录、php-fpm日志目录为匿名卷
VOLUME /home/www /var/log/php-fpm

# 添加www用户及切换站点目录所有者
RUN useradd www \
    &amp;amp;&amp;amp; chown -R www /home/www

# 切换工作目录为根目录
WORKDIR /

# 容器启动时执行命令
CMD [&amp;quot;/usr/local/sbin/php-fpm&amp;quot;]

# 声明使用9000端口
EXPOSE 9000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-nginx&#34;&gt;2. Nginx&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM nginx

LABEL maintainer=&amp;quot;AlanAlbert&amp;quot; version=&amp;quot;1.0&amp;quot; description=&amp;quot;nginx&amp;quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 复制Nginx配置
COPY nginx.conf /etc/nginx/
COPY sites/*.conf /etc/nginx/conf.d/

# 挂载站点、Nginx日志为匿名卷
VOLUME /home/www /var/log/nginx

# 添加www用户、更换站点目录所有者
RUN useradd www \
    &amp;amp;&amp;amp; chown -R www /home/www

# 设置工作目录
WORKDIR /home/www

# 设置容器启动时执行的命令
CMD [&amp;quot;/usr/sbin/nginx&amp;quot;]

# 声明使用的端口
EXPOSE 80 443
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-mysql&#34;&gt;3. MySQL&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM mysql:5.7

LABEL maintainer=&amp;quot;AlanAlbert&amp;quot; version=&amp;quot;1.0&amp;quot; description=&amp;quot;mysql&amp;quot;

# 设置环境变量
ENV MYSQL_ALLOW_EMPTY_PASSWORD=true \
    MYSQL_ROOT_PASSWORD=&amp;quot;&amp;quot; \
    TZ=Asia/Shanghai

# 复制MySQL配置
COPY my.cnf /etc/mysql/

# 挂载MySQL数据目录为匿名卷
VOLUME /var/lib/mysql

# 声明使用的端口
EXPOSE 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-redis&#34;&gt;4. Redis&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM redis

LABEL maintainer=&amp;quot;AlanAlbert&amp;quot; version=&amp;quot;1.0&amp;quot; description=&amp;quot;redis&amp;quot;

# 设置时区
ENV TZ=Asia/Shanghai

# 声明需要使用的端口
EXPOSE 6379
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-编写shell脚本管理容器&#34;&gt;二、编写shell脚本管理容器&lt;/h2&gt;
&lt;p&gt;因为暂时没有使用docker-compose，而docker命令较长，很复杂，所以编写脚本来管理容器&lt;/p&gt;
&lt;h3 id=&#34;1-build&#34;&gt;1. build&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# 发生错误，中断执行
set -e

echo &amp;quot;开始构建...&amp;quot;
echo &amp;quot;正在构建PHP-FPM...&amp;quot;

# 构建PHP-FPM镜像，并设置名称为alan/php-fpm
docker build -t alan/php-fpm php-fpm

# 创建PHP-FPM容器。
# 1. -p: 将容器9000端口映射到物理机9000端口；
# 2. --name: 指定名称为alan_php-fpm；
# 3. -i: 开启容器标准输入
# 4. -t: 分配一个伪输入终端
# 5. -v: 挂载www目录到/home/www、logs/php-fpm目录到/car/log/php-fpm
# 6. --network: 连接到alan_php_env网络
docker create -p 9000:9000 --name alan_php-fpm -it -v `pwd`/www:/home/www -v `pwd`/logs/php-fpm:/var/log/php-fpm --network alan_php_env alan/php-fpm

echo &amp;quot;PHP-FPM构建完成.&amp;quot;
echo &amp;quot;正在构建Nginx...&amp;quot;

# 构建Nginx镜像，设置名称为alan/nginx
docker build -t alan/nginx nginx

# 创建Nginx容器。
# 1. -p: 映射端口
# 2. --name: 设置镜像名称
# 3. -i: 开启标准输入
# 4. -t: 分配伪输入终端
# 5. -v: 挂载目录
# 6. --network: 连接网络
docker create -p 80:80 --name alan_nginx -it -v `pwd`/www:/home/www -v `pwd`/logs/nginx:/var/log/nginx --network alan_php_env alan/nginx

echo &amp;quot;Nginx构建完成.&amp;quot;
echo &amp;quot;正在构建MySQL...&amp;quot;

# 构建MySQL镜像
docker build -t alan/mysql mysql

# 创建MySQL容器
docker create -p 3306:3306 --name alan_mysql -it -v `pwd`/data:/var/lib/mysql --network alan_php_env alan/mysql

echo &amp;quot;MySQL构建完成.&amp;quot;
echo &amp;quot;正在构建Redis...&amp;quot;

# 构建Redis镜像
docker build -t alan/redis redis

# 创建Redis容器
# --requirepass: 设置Redis密码
docker create -p 6379:6379 --name alan_redis -it --network alan_php_env alan/redis --requirepass &amp;quot;&amp;quot;

echo &amp;quot;Redis构建完成.&amp;quot;
echo &amp;quot;正在创建网络...&amp;quot;

# 创建bridge网络
docker network create -d bridge alan_php_env

echo &amp;quot;网络创建完成.&amp;quot;
echo &amp;quot;构建完成.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-start&#34;&gt;2. start&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
set -e

echo &amp;quot;正在启动...&amp;quot;

# 启动所有容器
docker start alan_php-fpm alan_nginx alan_mysql alan_redis

echo &amp;quot;启动完成.&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-stop&#34;&gt;3. stop&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

echo &amp;quot;正在停止...&amp;quot;

# 停止所有容器
docker stop alan_redis alan_mysql alan_nginx alan_php-fpm

echo &amp;quot;已停止.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-restart&#34;&gt;4. restart&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
set -e

echo &amp;quot;正在重启...&amp;quot;

# 重启所有镜像
docker restart alan_redis alan_mysql alan_nginx alan_php-fpm

echo &amp;quot;重启完成.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-uninstall&#34;&gt;5. uninstall&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# 停止所有容器 &amp;amp;&amp;amp; 删除所有容器 &amp;amp;&amp;amp; 删除所有镜像 &amp;amp;&amp;amp; 删除网络

echo &amp;quot;正在卸载...&amp;quot;
echo &amp;quot;正在停止运行容器...&amp;quot;

docker stop alan_redis alan_mysql alan_nginx alan_php-fpm

echo &amp;quot;已停止.&amp;quot;
echo &amp;quot;正在删除容器...&amp;quot;

docker rm alan_redis alan_mysql alan_nginx alan_php-fpm

echo &amp;quot;已删除容器.&amp;quot;
echo &amp;quot;正在删除镜像...&amp;quot;

docker rmi alan/redis alan/mysql alan/nginx alan/php-fpm

echo &amp;quot;已删除镜像.&amp;quot;
echo &amp;quot;正在删除网络...&amp;quot;

docker network rm alan_php_env

echo &amp;quot;已删除网络.&amp;quot;
echo &amp;quot;卸载完成.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">初探Docker---编写Dockerfile搭建PHP开发环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/FoUON4LwO/"" data-c="
          &lt;p&gt;学习Docker过程中自己的一些理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是Docker、Dockerfile？&lt;/li&gt;
&lt;li&gt;怎么使用Docker？&lt;/li&gt;
&lt;li&gt;如何编写Dockerfile？&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-镜像&#34;&gt;1. 镜像&lt;/h2&gt;
&lt;p&gt;镜像是一种特殊的文件系统，包含所需要的程序、资源、库、配置等文件，还有一些为运行时准备的配置参数。Docker镜像并不是一个文件，而是由多层文件系统联合组成的。镜像是一层一层构建的，而且删除前一层文件的操作并不是真的删除文件，而是将其标记为该文件已删除。&lt;/p&gt;
&lt;h2 id=&#34;2-容器&#34;&gt;2. 容器&lt;/h2&gt;
&lt;p&gt;容器是使用镜像来创建的，其类似于&lt;code&gt;类&lt;/code&gt;与&lt;code&gt;对象&lt;/code&gt;的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像是&lt;code&gt;类&lt;/code&gt;，是静态的定义；&lt;/li&gt;
&lt;li&gt;容器是实例化的&lt;code&gt;对象&lt;/code&gt;，是动态运行时的实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-仓库&#34;&gt;3. 仓库&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;仓库（Repository）&lt;strong&gt;是一个集中存储、分发镜像的场所，例如：存放Ubuntu镜像的仓库是Ubuntu仓库。另一个概念是&lt;/strong&gt;注册服务器（Registry）&lt;/strong&gt;，注册服务器是存放仓库的地方。&lt;/p&gt;
&lt;h2 id=&#34;4-docker命令列表&#34;&gt;4. docker命令列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker help&lt;/code&gt;: 获取帮助信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec&lt;/code&gt;: 在正在运行的容器中运行命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker pull&lt;/code&gt;: 从服务器提取镜像或存储库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker ps&lt;/code&gt;: 列出容器信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker images&lt;/code&gt;: 列出所有镜像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt;: 通过Dockerfile构建镜像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker create IMAGE&lt;/code&gt;: 创建一个新的容器但不启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run IMAGE [COMMAND]&lt;/code&gt;: 创建一个新容器并运行一个命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker restart CONTAINER&lt;/code&gt;: 重启容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker start CONTAINER&lt;/code&gt;: 启动一个或多个容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker stop CONTAINER&lt;/code&gt;: 停止容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker top CONTAINER&lt;/code&gt;: 查看容器中运行的进程信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker rm&lt;/code&gt;: 删除容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker rmi&lt;/code&gt;: 删除镜像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker volume&lt;/code&gt;: 数据卷管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker network&lt;/code&gt;: 网络管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker commit&lt;/code&gt;: 从当前更改的容器状态创建新镜像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker search&lt;/code&gt;: 在服务器中搜索镜像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker version&lt;/code&gt;: 查看docker版本信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker attach&lt;/code&gt;: 将本地输入、输出、错误流附加到正在运行的容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker history&lt;/code&gt;: 查看镜像历史记录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker info&lt;/code&gt;: 显示设备信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker inspect&lt;/code&gt;: 获取容器/镜像的元数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker login&lt;/code&gt;: 登录到服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker pause CONTAINER&lt;/code&gt;: 暂停容器中所有的进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker unpause CONTAINER&lt;/code&gt;: 恢复容器中的所有进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker kill CONTAINER&lt;/code&gt;: 杀掉一个运行中的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-dockerfile&#34;&gt;5. Dockerfile&lt;/h2&gt;
&lt;p&gt;Dockerfile中提供了很多指令，以下将会提到这些指令的作用和用法。&lt;/p&gt;
&lt;h3 id=&#34;from&#34;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指定&lt;strong&gt;基础镜像&lt;/strong&gt;。如: nginx, ubunu等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以使用空白镜像(&lt;code&gt;scratch&lt;/code&gt;)作为基础镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;FROM nginx&lt;/code&gt;，或指定版本&lt;code&gt;FROM ubuntu:stretch&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;run&#34;&gt;&lt;code&gt;RUN&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运行命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以运行可执行文件：&lt;code&gt;RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;RUN echo &#39;测试&#39; &amp;gt; a.txt&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;copy&#34;&gt;&lt;code&gt;COPY&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;复制文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用通配符：&lt;code&gt;COPY *.txt /var/www/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以指定复制后文件的所属用户及组：&lt;code&gt;COPY --chown=name a.txt /var/www/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;COPY a.txt /var/www/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;add&#34;&gt;&lt;code&gt;ADD&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高级的&lt;code&gt;COPY&lt;/code&gt;指令，可以指定URL。从URL下载的文件默认权限为600。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该命令可以用&lt;code&gt;RUN&lt;/code&gt;指令执行&lt;code&gt;wget&lt;/code&gt;或&lt;code&gt;curl&lt;/code&gt;替换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不推荐使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;cmd&#34;&gt;&lt;code&gt;CMD&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Docker容器启动时执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与RUN指令一样，该指令也支持exec、shell两种写法：&lt;code&gt;CMD &amp;lt;命令&amp;gt;&lt;/code&gt;、 &lt;code&gt;CMD [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;...]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Dockerfile只能有一个CMD命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用: &lt;code&gt;CMD [&amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;https://dogedoge.com&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;entrypoint&#34;&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与&lt;code&gt;CMD&lt;/code&gt;指令一样，用于指定容器启动程序及参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样支持exec及shell写法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与CMD指令的区别在于：command会作为参数传递给ENTRYPOINT指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;ENTRYPOINT [&amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;https://dogedoge.com&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;env&#34;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设置环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 或 &lt;code&gt;ENV &amp;lt;key1&amp;gt;=&amp;lt;value1&amp;gt; &amp;lt;key2&amp;gt;=&amp;lt;value2&amp;gt; ...&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;arg&#34;&gt;&lt;code&gt;ARG&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;与ENV指令效果一样，都是设置环境变量。但ARG设置的环境变量在容器运行时是不会存在的&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;ARG name=Alan&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;volume&#34;&gt;&lt;code&gt;VOLUME&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;挂载匿名卷(volume)。为了防止用户在运行时忘记将动态文件所在的文件挂载为卷(docker -v)，我们可以事先在Dockerfile中指定挂载某些目录为匿名卷。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Docker运行时应保持容器存储层不发生写操作，容器存储层的数据在容器停止后不会持续存在。所以将数据写入到卷中，可以持久化存储数据，提高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;VOLUME /var/data&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;expose&#34;&gt;&lt;code&gt;EXPOSE&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明打算使用的端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与&lt;code&gt;docker -p &amp;lt;宿主端口&amp;gt;:&amp;lt;容器端口&amp;gt;&lt;/code&gt;不同，&lt;code&gt;EXPOSE&lt;/code&gt;只是声明打算使用的端口，并不会自动做端口映射&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;EXPOSE 8080&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;workdir&#34;&gt;&lt;code&gt;WORKDIR&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指定当前工作目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;WORKDIR /var/data&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;user&#34;&gt;&lt;code&gt;USER&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指定当前用户，&lt;code&gt;USER &amp;lt;用户名&amp;gt;:&amp;lt;用户组&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;USER php&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;healthcheck&#34;&gt;&lt;code&gt;HEALTHCHECK&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查容器的健康状况&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;HEALTHCHECK [选项] CMD [命令]&lt;/code&gt; 或 &lt;code&gt;HEALTHCHECK NONE&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;onbuild&#34;&gt;&lt;code&gt;ONBUILD&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当该镜像作为基础镜像被其他镜像使用时才会被执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用：&lt;code&gt;ONBUILD RUN [&amp;quot;npm&amp;quot;, &amp;quot;install&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">初探Docker---Docker及Dockerfile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/pofq8AycT/"" data-c="
          &lt;p&gt;很久没更新博客了，最近在下班时间写了一个简单的PHP库——&lt;a href=&#34;https://github.com/anhoder/php-async&#34;&gt;php-async&lt;/a&gt;及&lt;a href=&#34;https://github.com/anhoder/php-async-manager&#34;&gt;php-async-manager&lt;/a&gt;，以实现PHP中的简单异步回调。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;0-前言&#34;&gt;0. 前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;最近遇到个问题，PHP的异步回调怎么实现？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Workman、Swoole、fastcgi_finish_request？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Workman、Swoole这些框架虽然对异步回调实现的很好，但是如果只需要简单的异步回调就上这些未免大材小用。&lt;/li&gt;
&lt;li&gt;而fastcgi_finish_request虽然使用方面，但毕竟只能在php-fpm模式下使用，而且一次请求只能使用一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后就一直在思考：能不能自己实现一个PHP可用的简单异步回调呢？最初出现在我脑海的有几个方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写PHP扩展，使用C/C++创建守护进程进程，用于监听是否有异步任务到来，如果有任务到来，则执行任务及回调函数。而PHP进程则将异步任务传递给该监听进程，从而实现异步。&lt;/li&gt;
&lt;li&gt;使用pcntl扩展创建子进程，并让子进程脱离父进程的控制，成为守护进程。子进程用于处理耗时的异步任务，父进程处理HTTP请求及返回响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于第二种方案更简单，因此选择使用第二种方案进行实现。&lt;/p&gt;
&lt;h2 id=&#34;1-实现原理及思路&#34;&gt;1. 实现原理及思路&lt;/h2&gt;
&lt;p&gt;实现原理比较简单：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在当前进程中创建子进程，父进程处理耗时较短的HTTP业务逻辑；子进程处理耗时较长的任务，例如邮件发送等。&lt;/li&gt;
&lt;li&gt;创建子进程后，让子进程脱离父进程的控制，成为守护进程。&lt;/li&gt;
&lt;li&gt;父进程通过设置&lt;code&gt;Callable&lt;/code&gt;或&lt;code&gt;Closure&lt;/code&gt;函数，让子进程执行异步任务及回调函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个异步任务都需要两个关键元素组成：异步任务本身、回调函数。所以设计了JobInterface接口，该接口要求实现两个方法：job、callback，分别对应异步任务及回调函数。具体代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;interface JobInterface
{
    /**
     * 异步任务
     *
     * @return void
     */
    public function job();

    /**
     * 回调函数
     *
     * @return void
     */
    public function callback();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-遇到的问题及解决方法&#34;&gt;2. 遇到的问题及解决方法&lt;/h2&gt;
&lt;p&gt;在CLI模式下开发运行十分顺利，没遇到什么较大的问题。但是，一切开发完成之后，在php-fpm模式下测试，遇到以下几个问题：&lt;/p&gt;
&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建的子进程由php-fpm管理进程控制&lt;/strong&gt;，当子进程执行完成后，因为php-fpm没有给该异步进程“收尸”，&lt;strong&gt;导致其成为僵尸进程，占用系统资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因为在php-fpm模式下，进程受php-fpm管理进程的控制，因此猜测&lt;strong&gt;异步进程的数量可能受php-fpm配置的进程数限制&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对于“僵尸进程”的问题，让父进程忽略子进程的结束，从而将子进程的回收权移交给系统的init进程，由init进程回收创建的子进程：&lt;code&gt;pcntl_signal(SIGCHLD, SIG_IGN);&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;php-fpm配置的进程数限制，经过测试（将php-fpm配置文件中的最大进程数改为5，并使用静态模式）发现，并未出现猜想中的创建子进程被限制的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-最后结果&#34;&gt;3. 最后结果&lt;/h2&gt;
&lt;p&gt;最后实现的结果为: &lt;a href=&#34;https://github.com/anhoder/php-async&#34;&gt;php-async&lt;/a&gt;。在CLI和php-fpm模式下都没有发现问题。&lt;/p&gt;
&lt;p&gt;之后，我还基于symfony/console开发了一个用于查看异步任务的命令行工具——&lt;a href=&#34;https://github.com/anhoder/php-async-manager&#34;&gt;php-async-manager&lt;/a&gt;，可以用于查看异步任务运行状态、停止正在运行的任务等。&lt;/p&gt;
&lt;h2 id=&#34;4-后续拓展&#34;&gt;4. 后续拓展&lt;/h2&gt;
&lt;p&gt;该异步实现方案还存在一个很大的问题，即，每执行一个异步任务就要创建一个进程，当处理的请求数量比较多时，就需要创建太多的进程。&lt;/p&gt;
&lt;p&gt;之后了解了NodeJS的异步实现原理，其底层使用libuv库，以事件为驱动，libuv负责将来自操作系统的事件收集起来，或者监视其他来源的事件。这样，用户就可以注册回调函数，回调函数会在事件发生的时候被调用。event-loop会一直保持运行状态。&lt;/p&gt;
&lt;p&gt;因此，最好的异步实现方案还是使用C语言开发一个PHP的扩展😂。&lt;/p&gt;
"> PHP实现异步回调的总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/iB_w9Dzch/"" data-c="
          &lt;p&gt;自己在学习PHP底层时的一些笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;阅读&lt;a href=&#34;https://github.com/huanghantao/study-note/blob/master/PHP/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.md&#34;&gt;https://github.com/huanghantao/study-note/blob/master/PHP/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.md&lt;/a&gt;的笔记&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-php-config&#34;&gt;1. php-config&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;php-config&lt;/code&gt;是一个简单的命令行脚本，&lt;strong&gt;用于获取PHP的安装及配置信息&lt;/strong&gt;。当安装多个PHP版本时，可以使用&lt;code&gt;--with-php-config&lt;/code&gt;来指定使用哪个版本的PHP来进行编译。&lt;/p&gt;
&lt;h2 id=&#34;2-php的扩展类型&#34;&gt;2. PHP的扩展类型&lt;/h2&gt;
&lt;p&gt;PHP的扩展可分为静态扩展和动态扩展两类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态扩展是与PHP源码一起进行编译安装的，编译PHP时通过指定参数&lt;code&gt;--enable&lt;/code&gt;和&lt;code&gt;--with&lt;/code&gt;来启用扩展。&lt;/li&gt;
&lt;li&gt;动态扩展是直接编译扩展的源代码，生成&lt;code&gt;.so&lt;/code&gt;(Linux)或&lt;code&gt;.dll&lt;/code&gt;(Windows)的动态链接库，然后在php.ini配置文件中开启。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在静态编译PHP时，enable 是启用 PHP 源码包自带，但是默认不启用的扩展，比如 ftp 和 exif 扩展。with 是指定扩展依赖的资源库的位置，如果是默认位置，就可以留空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-php函数的底层实现&#34;&gt;3. PHP函数的底层实现&lt;/h2&gt;
&lt;p&gt;PHP的函数分为两种，一种为内置函数&lt;code&gt;zend_internal_function&lt;/code&gt;，另一种为用户函数&lt;code&gt;zend_user_function&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置函数在PHP的内核实现，通过c/c++进行编写&lt;/li&gt;
&lt;li&gt;用户函数是用户使用PHP自定义的函数，这种函数会被ZE(Zend Engine)编译为opcode来执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PHP在编译阶段将用户自定义的函数编译为独立的opcodes,保存在EG(function_table)中,调用时重新分配新的zend_execute_data(相当于运行栈),然后执行函数的opcodes,调用完再还原到旧的zend_execute_data，即原来的函数，继续执行。&lt;/p&gt;
&lt;p&gt;zend_function的结构中的op_array存储了该函数中所有的操作,当函数被调用时,ZE就会将这个op_array中的opline一条条顺次执行, 并将最后的返回值返回。 从VLD扩展中查看的关于函数的信息可以看出,函数的定义和执行是分开的,一个函数可以作为一个独立的运行单元而存在。&lt;/p&gt;
&lt;h2 id=&#34;4-php的线程安全&#34;&gt;4. PHP的线程安全&lt;/h2&gt;
&lt;p&gt;配置编译PHP时加参数&lt;code&gt;--enable-maintainer-zts&lt;/code&gt;则编译出的php为Zend线程安全（ZTS），否则不是线程安全（NTS）。&lt;/p&gt;
&lt;p&gt;当&lt;strong&gt;使用pthread（POSIX threads）扩展时，或者当web服务器为Apache2 mpm-worker或IIS&lt;/strong&gt;使用PHP作为模块时，请考虑使用ZTS。当&lt;strong&gt;使用FastCGI / FPM或Apache2 mpm-prefork&lt;/strong&gt;时，您不需要ZTS，因为在PHP运行时使用的多进程处理。&lt;/p&gt;
&lt;p&gt;NTS是运行PHP的首选方式。NTS还使您更容易编写和调试扩展。&lt;/p&gt;
&lt;h2 id=&#34;5-zend引擎的执行过程&#34;&gt;5. Zend引擎的执行过程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Zend Engine调用词法分析器将PHP脚本分割为一个一个的token&lt;/li&gt;
&lt;li&gt;Zend Engine会将得到的token提交给语法分析器，生成抽象语法树(Abstract Syntax Tree)&lt;/li&gt;
&lt;li&gt;ZE调用zend_compile_top_stmt()函数将抽象语法树解析为一个一个的opcode，opcode一般会以op_array的形式存在，它是PHP执行的中间语言&lt;/li&gt;
&lt;li&gt;最后,ZE调用zend_executor来执行op_array，输出结果&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;token&#34;&gt;Token&lt;/h3&gt;
&lt;p&gt;PHP提供&lt;code&gt;token_get_all&lt;/code&gt;函数来获取token，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$token = token_get_all(&#39;&amp;lt;?php echo \&#39;hello, world\&#39;;&#39;);
var_dump($token);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;array(5) {
  [0] =&amp;gt;
  array(3) {
    [0] =&amp;gt;
    int(379)
    [1] =&amp;gt;
    string(6) &amp;quot;&amp;lt;?php &amp;quot;
    [2] =&amp;gt;
    int(1)
  }
  [1] =&amp;gt;
  array(3) {
    [0] =&amp;gt;
    int(328)
    [1] =&amp;gt;
    string(4) &amp;quot;echo&amp;quot;
    [2] =&amp;gt;
    int(1)
  }
  [2] =&amp;gt;
  array(3) {
    [0] =&amp;gt;
    int(382)
    [1] =&amp;gt;
    string(1) &amp;quot; &amp;quot;
    [2] =&amp;gt;
    int(1)
  }
  [3] =&amp;gt;
  array(3) {
    [0] =&amp;gt;
    int(323)
    [1] =&amp;gt;
    string(14) &amp;quot;&#39;hello, world&#39;&amp;quot;
    [2] =&amp;gt;
    int(1)
  }
  [4] =&amp;gt;
  string(1) &amp;quot;;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ast抽象语法树&#34;&gt;AST抽象语法树&lt;/h3&gt;
&lt;p&gt;以下工具可以用于查看AST结构信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://pecl.php.net/package/ast  (扩展)&lt;/li&gt;
&lt;li&gt;https://dooakitestapp.herokuapp.com/phpast/webapp/ (在线)&lt;/li&gt;
&lt;li&gt;https://github.com/nikic/PHP-Parser (PHP解析工具)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opcode&#34;&gt;Opcode&lt;/h3&gt;
&lt;p&gt;opcode是Zend虚拟机可识别的指令，php7共有173个opcode，定义在zend_vm_opcodes.h中，这些中间代码会被Zend VM(Zend虚拟机)直接执行。&lt;/p&gt;
&lt;p&gt;查看opcode可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://pecl.php.net/package/vld (扩展)&lt;/li&gt;
&lt;li&gt;https://3v4l.org/UBstu/vld#output (在线)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-eg变量&#34;&gt;6. EG变量&lt;/h2&gt;
&lt;p&gt;executor_globals是一个全局变量，存储着许多信息(当前上下文、符号表、函数/类/常量表、堆栈等)，EG宏就是用于访问executor_globals的某个成员&lt;/p&gt;
">PHP的一些底层知识</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/ceQxJpgpx/"" data-c="
          &lt;p&gt;fastcgi_finish_request是&lt;strong&gt;工作在FastCGI模式下&lt;/strong&gt;才可用的函数。使用这个脚本可以提高请求响应速度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;cgi&#34;&gt;CGI&lt;/h2&gt;
&lt;p&gt;CGI，公共网关接口，是一种Web服务器与后端语言的通信规范。CGI会在请求到来时，fork出一个子进程用于处理请求，当处理完成后，会杀死该进程，下次请求到来时继续创建，如此往复...&lt;/p&gt;
&lt;p&gt;因此，CGI在创建进程上会存在极大地资源消耗。现在使用较少。&lt;/p&gt;
&lt;h2 id=&#34;fastcgi&#34;&gt;FastCGI&lt;/h2&gt;
&lt;p&gt;FastCGI可以说是CGI的升级版本，其解决了CGI在创建进程上的资源消耗。&lt;/p&gt;
&lt;p&gt;具体方法为，当FastCGI进程管理器启动时，会创建若干个CGI进程（数量可配置）等待请求到来，不需要每次都花时间去创建，同时可以根据请求数对CGI进程数进行伸缩。&lt;/p&gt;
&lt;h2 id=&#34;fastcgi_finish_request&#34;&gt;fastcgi_finish_request&lt;/h2&gt;
&lt;p&gt;该函数就是&lt;strong&gt;工作在FastCGI模式下的&lt;/strong&gt;。具体作用为，当执行到该函数时，直接向客户端返回响应，但后续脚本仍然执行，只是对用户不可见。&lt;/p&gt;
&lt;p&gt;例如脚本文件a.php：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;echo &#39;Hello, Alan&#39;;

fastcgi_finish_request();

sleep(5);
file_put_contents(&#39;a.txt&#39;, &#39;测试内容&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时，使用tail命令监控a.txt文件的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ tail -f -n 5 a.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动Nginx、PHP-FPM，并访问a.php，可以发现很快就能得到响应，并不会受后面&lt;code&gt;sleep(5)&lt;/code&gt;的影响，5秒之后a.txt文件也会出现&lt;code&gt;测试内容&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;因为该函数&lt;strong&gt;只能在FastCGI模式下可用&lt;/strong&gt;，因此，如果需要考虑可移植性，可以自己根据业务逻辑实现fastcgi_finish_request函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!function_exists(&#39;fastcgi_finish_request&#39;)) {
  function fastcgi_finish_request() {
  
  }
}
&lt;/code&gt;&lt;/pre&gt;
">PHP中的fastcgi_finish_request函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/3o6BJ2CzM/"" data-c="
          &lt;p&gt;PHP的扩展分为两类：PHP扩展、Zend扩展，在内核中分别称为module、extension，以下的主要是关于module的内容。&lt;/p&gt;
&lt;p&gt;扩展可以在编译PHP时一起编译（静态编译），也可以将扩展编译为共享库，然后在配置文件php.ini中加入进去。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;加载php扩展的过程&#34;&gt;加载PHP扩展的过程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.alan123.xyz/php/592.html&#34;&gt;PHP生命周期&lt;/a&gt;有5个阶段：模块初始化阶段（php_module_startup）、请求初始化阶段（php_request_startup）、脚本执行阶段（script execute）、请求关闭阶段（php_request_shutdown()）、模块关闭阶段（php_module_shutdown()）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① PHP扩展会在模块初始化阶段解析php.ini配置文件，将相对应的扩展共享库加载到PHP中，保存在全局变量extension_lists中；&lt;br&gt;
② 在php_ini_register_extensions()中依次遍历php_extension_lists.engine、php_extension_lists.functions，然后分别调用php_load_zend_extension_cb()、php_load_php_extension_cb()完成Zend扩展、PHP扩展的注册加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;扩展的组成&#34;&gt;扩展的组成&lt;/h2&gt;
&lt;p&gt;① 通过zend_module_entry结构体来定义扩展的相关信息，包括扩展名称、版本号、hook函数等。且zend_module_entry结构体声明的变量名称需要遵循modulename_module_entry的格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;: 扩展名称&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;functions&lt;/strong&gt;: 扩展定义的内部函数entry&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;module_startup_func&lt;/strong&gt;: 在模块初始化阶段回调的hook函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;module_shutdown_func&lt;/strong&gt;: 在模块关闭阶段回调的hook函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request_startup_func&lt;/strong&gt;: 在请求初始化阶段回调的hook函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request_shutdown_func&lt;/strong&gt;: 在请求关闭阶段回调的hook函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;info_func&lt;/strong&gt;: php_info()函数时调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;: 扩展的版本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;② 定义宏ZEND_GET_MODULE(extension_name)以获取扩展的zend_module_entry结构地址：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_GET_MODULE(extension_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
在PHP中，ZEND_GET_MODULE宏的定义如下：
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define ZEND_GET_MODULE(name) \
    BEGIN_EXTERN_C() \
    ZEND_DLEXPORT zend_module_entry *get_module(void) { return &amp;amp;name##_module_entry; } \    // ##起到拼接字符串的作用
    END_EXTERN_C()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开发php扩展的步骤&#34;&gt;开发PHP扩展的步骤&lt;/h2&gt;
&lt;h3 id=&#34;1-ext_skel生成扩展基本框架&#34;&gt;1、ext_skel生成扩展基本框架&lt;/h3&gt;
&lt;p&gt;通过ext_skel脚本生成扩展的基本框架，ext_skel在PHP源码的ext目录下，使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./ext_skel --extname=extension_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的目录框架如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./ext_skel --extname=TestExtension

TestExtension
├── CREDITS
├── EXPERIMENTAL
├── TestExtension.c     // 扩展源码
├── TestExtension.php   // 用于在PHP中测试扩展是否可用，可去除
├── config.m4           // 扩展编译时的配置文件，用于phpize脚本生成configure文件
├── config.w32          // windows环境的配置
├── php_TestExtension.h // 头文件
└── tests               // 测试用例，用于make test的测试
    └── 001.phpt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-修改configm4配置&#34;&gt;2、修改config.m4配置&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;mweblib://15629867837001&#34;&gt;config.m4详解&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.php.net/manual/zh/internals2.buildsys.configunix.php&#34;&gt;PHP官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下为PHP官方文档给出的config.m4样例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl $Id$
dnl config.m4 for extension example
PHP_ARG_WITH(example, for example support,
[  --with-example[=FILE]       Include example support. File is the optional path to example-config])
PHP_ARG_ENABLE(example-debug, whether to enable debugging support in example,
[  --enable-example-debug        example: Enable debugging support in example], no, no)
PHP_ARG_WITH(example-extra, for extra libraries for example,
[  --with-example-extra=DIR      example: Location of extra libraries for example], no, no)

dnl 检测扩展是否已启用
if test &amp;quot;$PHP_EXAMPLE&amp;quot; != &amp;quot;no&amp;quot;; then
  
  dnl 检测 example-config。首先尝试所给出的路径，然后在 $PATH 中寻找
  AC_MSG_CHECKING([for example-config])
  EXAMPLE_CONFIG=&amp;quot;example-config&amp;quot;
  if test &amp;quot;$PHP_EXAMPLE&amp;quot; != &amp;quot;yes&amp;quot;; then
    EXAMPLE_PATH=$PHP_EXAMPLE
  else
    EXAMPLE_PATH=`$php_shtool path $EXAMPLE_CONFIG`
  fi
  
  dnl 如果找到可用的 example-config，就使用它（检测文件是否存在，是否可执行以及执行的结果）
  if test -f &amp;quot;$EXAMPLE_PATH&amp;quot; &amp;amp;&amp;amp; test -x &amp;quot;$EXAMPLE_PATH&amp;quot; &amp;amp;&amp;amp; $EXAMPLE_PATH --version &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then
    AC_MSG_RESULT([$EXAMPLE_PATH]) dnl 结束check，继续执行
    EXAMPLE_LIB_NAME=`$EXAMPLE_PATH --libname`
    EXAMPLE_INCDIRS=`$EXAMPLE_PATH --incdirs`
    EXAMPLE_LIBS=`$EXAMPLE_PATH --libs`
    
    dnl 检测扩展库是否工作正常
    dnl PHP_CHECK_LIBRARY() 尝试编译、链接和执行程序，
    dnl 在第一个参数指定的库中调用由第二个参数指定的符号，使用第五个参数给出的字符串作为额外的链接选项。
    dnl 如果尝试成功了，则运行第三个参数所给出的脚本。此脚本从 example-config 所提供的原始的选项字符串中取出头文件路径、库文件路径和库名称，告诉 PHP 构建系统。
    dnl 如果尝试失败，脚本则运行第四个参数中的脚本。此时调用 AC_MSG_ERROR() 来中断程序执行。
    PHP_CHECK_LIBRARY($EXAMPLE_LIB_NAME, example_critical_function,
    [
      dnl 添加所需的 include 目录
      PHP_EVAL_INCLINE($EXAMPLE_INCDIRS)
      dnl 添加所需的扩展库及扩展库所在目录
      PHP_EVAL_LIBLINE($EXAMPLE_LIBS, EXAMPLE_SHARED_LIBADD)
    ],[
      dnl 跳出
      AC_MSG_ERROR([example library not found. Check config.log for more information.])
    ],[$EXAMPLE_LIBS]
    )
  else
    dnl 没有可用的 example-config，跳出
    AC_MSG_RESULT([not found])   dnl 结束check
    AC_MSG_ERROR([Please check your example installation.]) dnl 报错
  fi
  
  dnl 检测是否启用调试
  if test &amp;quot;$PHP_EXAMPLE_DEBUG&amp;quot; != &amp;quot;no&amp;quot;; then
    dnl 是，则设置 C 语言宏指令
    AC_DEFINE(USE_EXAMPLE_DEBUG,1,[Include debugging support in example])
  fi
  
  dnl 检测额外的支持
  if test &amp;quot;$PHP_EXAMPLE_EXTRA&amp;quot; != &amp;quot;no&amp;quot;; then
    if test &amp;quot;$PHP_EXAMPLE_EXTRA&amp;quot; == &amp;quot;yes&amp;quot;; then
      AC_MSG_ERROR([You must specify a path when using --with-example-extra])
    fi
    
    PHP_CHECK_LIBRARY(example-extra, example_critical_extra_function,
    [
      dnl 添加所需路径
      PHP_ADD_INCLUDE($PHP_EXAMPLE_EXTRA/include)
      PHP_ADD_LIBRARY_WITH_PATH(example-extra, $PHP_EXAMPLE_EXTRA/lib, EXAMPLE_SHARED_LIBADD)
      AC_DEFINE(HAVE_EXAMPLEEXTRALIB,1,[Whether example-extra support is present and requested])
      EXAMPLE_SOURCES=&amp;quot;$EXAMPLE_SOURCES example_extra.c&amp;quot;
    ],[
      AC_MSG_ERROR([example-extra lib not found. See config.log for more information.])
    ],[-L$PHP_EXAMPLE_EXTRA/lib]
    )
  fi
  
  dnl 最后，将扩展及其所需文件等信息传给构建系统
  dnl PHP_NEW_EXTENSION
  dnl 第一个参数是扩展的名称，和包含它的目录同名。
  dnl 第二个参数是做为扩展的一部分的所有源文件的列表。参见 PHP_ADD_BUILD_DIR() 以获取将在子目录中源文件添加到构建过程的相关信息。
  dnl 第三个参数总是 $ext_shared， 当为了 --with-example[=FILE] 而调用 PHP_ARG_WITH()时，由 configure 决定参数的值。
  dnl 第四个参数指定一个“SAPI 类”，仅用于专门需要 CGI 或 CLI SAPI 的扩展。其他情况下应留空。
  dnl 第五个参数指定了构建时要加入 CFLAGS 的标志列表。
  dnl 第六个参数是一个布尔值，为 &amp;quot;yes&amp;quot; 时会强迫整个扩展使用 $CXX 代替 $CC 来构建。
  dnl 第三个以后的所有参数都是可选的。
  PHP_NEW_EXTENSION(example, example.c $EXAMPLE_SOURCES, $ext_shared)
  dnl PHP_SUBST() 来启用扩展的共享构建
  PHP_SUBST(EXAMPLE_SHARED_LIBADD)
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-编写扩展的功能&#34;&gt;3、编写扩展的功能&lt;/h3&gt;
&lt;p&gt;在TestExtension.c文件中编写扩展实现的具体功能。&lt;/p&gt;
&lt;h2 id=&#34;编译安装扩展的步骤&#34;&gt;编译安装扩展的步骤&lt;/h2&gt;
&lt;h3 id=&#34;1-使用phpize解析configm4生成configure及其他配置文件&#34;&gt;1、使用phpize解析config.m4，生成configure及其他配置文件&lt;/h3&gt;
&lt;p&gt;当代码量较少，结构简单的项目中，我们往往会手动编写Makefile文件，但是在大型项目中编写Makefile是很难的，于是出现了autoconf/automake/autoheader/autolocal等一系列用于生成configure的自动化工具。&lt;/p&gt;
&lt;p&gt;而phpize就是一款操作这一系列复杂工具的脚本，它会读取并解析config.m4文件，并以此生成configure及其他文件。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在待编译的扩展目录使用 phpize 即可，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ phpize
Configuring for:
PHP Api Version:        
Zend Module Api No:     
Zend Extension Api No:
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-编译安装&#34;&gt;2、编译安装&lt;/h3&gt;
&lt;p&gt;使用上一步生成的configure文件检测安装平台的特征：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./configure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以加上一些参数，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./configure --with-php-config=php-config_path   
// php-config是在PHP安装时保存PHP安装信息的脚本，指定php-config更好
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，使用make、make install命令完成扩展的安装。&lt;/p&gt;
">PHP扩展编写</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/J3UFSRsWT/"" data-c="
          &lt;p&gt;config.m4是扩展的编译配置文件，其会被包含到configure.in中，最终被autoconf编译为configure。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;php提供的宏&#34;&gt;PHP提供的宏&lt;/h2&gt;
&lt;h3 id=&#34;php_arg_witharg_name-check_message-help_info&#34;&gt;PHP_ARG_WITH(arg_name, check_message, help_info)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义一个&lt;code&gt;--with-param[=arg]&lt;/code&gt;的编译参数。&lt;/li&gt;
&lt;li&gt;这个宏有五个参数，但常用的是前三个。第一个参数为&lt;code&gt;参数名&lt;/code&gt;，第二个参数为&lt;code&gt;执行./configure时的展示信息&lt;/code&gt;，第三个参数为&lt;code&gt;执行 --help 时的展示信息&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;该宏定义的参数可以在config.m4中通过&lt;code&gt;$PHP_大写参数名&lt;/code&gt;的形式进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;PHP_ARG_WITH(extname, for extname support, [--with-extname=yes])
# 通过$PHP_EXTNAME即可获得--with-extname=yes中的yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;php_arg_enablearg_name-check_message-help_info&#34;&gt;PHP_ARG_ENABLE(arg_name, check_message, help_info)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义一个&lt;code&gt;--enable-param[=arg]&lt;/code&gt;或&lt;code&gt;--disable-param&lt;/code&gt;（等价于&lt;code&gt;--enable-param=no&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;该宏与&lt;code&gt;PHP_ARG_WITH&lt;/code&gt;类似，如果参数需要设置具体的值，则使用&lt;code&gt;PHP_ARG_WITH&lt;/code&gt;，否则使用&lt;code&gt;PHP_ARG_ENABLE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ac_msg_checking-ac_msg_result-ac_msg_error&#34;&gt;AC_MSG_CHECKING、AC_MSG_RESULT、AC_MSG_ERROR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AC_MSG_CHECKING([提示信息]): 在执行./configure时，check的提示信息。&lt;/li&gt;
&lt;li&gt;AC_MSH_RESULT([检测的路径]): 结束check，继续执行&lt;/li&gt;
&lt;li&gt;AC_MSG_ERROR([错误信息]): 输出错误信息并退出./configure的执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ac_definevariable-value-description&#34;&gt;AC_DEFINE(variable, value, [description])&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义一个宏，例如：&lt;code&gt;AC_DEFINE(DEBUG_MODEL, 1, [open debug model])&lt;/code&gt;，最终会执行&lt;code&gt;#define DEBUG_MODEL 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_add_includepath&#34;&gt;PHP_ADD_INCLUDE(path)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;添加include路径，相当于&lt;code&gt;#include &amp;quot;file&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用外部库或分为多个目录时会使用到&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_check_librarylibrary-function-action-found-action-not-found-extra-libs&#34;&gt;PHP_CHECK_LIBRARY(library, function [, action-found [, action-not-found [, extra-libs]]])&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查依赖库library中是否存在需要的function，action-found为存在时执行的动作，action-not-found是不存在时执行的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;PHP_CHECK_LIBRARY($EXAMPLE_LIB_NAME, example_critical_function, [
  dnl 添加所需的 include 目录
  PHP_EVAL_INCLINE($EXAMPLE_INCDIRS)
  dnl 添加所需的扩展库及扩展库所在目录
  PHP_EVAL_LIBLINE($EXAMPLE_LIBS, EXAMPLE_SHARED_LIBADD)
],[
  dnl 跳出
  AC_MSG_ERROR([example library not found. Check config.log for more information.])
],[$EXAMPLE_LIBS])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ac_check_funcfunction-action-if-found-action-if-not-found&#34;&gt;AC_CHECK_FUNC(function, [action-if-found], [action-if-not-found])&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查函数function是否存在，action-if-found为存在时执行的动作，action-if-not-found为不存在时执行的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_add_library_with_path&#34;&gt;PHP_ADD_LIBRARY_WITH_PATH&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;格式为：&lt;code&gt;PHP_ADD_LIBRARY_WITH_PATH($LIBNAME, $XXX_DIR/$PHP_LIBDIR, XXX_SHARED_LIBADD)&lt;/code&gt;，添加链接库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;PHP_ADD_LIBRARY_WITH_PATH(example-extra, $PHP_EXAMPLE_EXTRA/lib, EXAMPLE_SHARED_LIBADD)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;php_add_build_dir&#34;&gt;PHP_ADD_BUILD_DIR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加载所需所有C文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_require_cxx&#34;&gt;PHP_REQUIRE_CXX()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用C++进行开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_substxxx_shared_libadd&#34;&gt;PHP_SUBST(XXX_SHARED_LIBADD)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;扩展编译成动态链接库的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php_new_extensionextname-sources-ext_shared-sapi_class-extra-cflags-cxx-zend_ext&#34;&gt;PHP_NEW_EXTENSION(extname, sources , $ext_shared [, sapi_class [, extra-cflags [, cxx [, zend_ext]]]])&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注册一个扩展&lt;/li&gt;
&lt;li&gt;第一个参数是扩展的名称，和包含它的目录同名&lt;/li&gt;
&lt;li&gt;第二个参数是做为扩展的一部分的所有源文件的列表&lt;/li&gt;
&lt;li&gt;第三个参数总是 $ext_shared&lt;/li&gt;
&lt;li&gt;第四个参数指定一个“SAPI 类”，仅用于专门需要 CGI 或 CLI SAPI 的扩展&lt;/li&gt;
&lt;li&gt;第五个参数指定了构建时要加入 CFLAGS 的标志列表&lt;/li&gt;
&lt;li&gt;第六个参数是一个布尔值，为 &amp;quot;yes&amp;quot; 时会强迫整个扩展使用 &lt;code&gt;$CXX&lt;/code&gt; 代替 &lt;code&gt;$CC&lt;/code&gt; 来构建&lt;/li&gt;
&lt;li&gt;第三个以后的所有参数都是可选的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;PHP_NEW_EXTENSION(example, example.c $EXAMPLE_SOURCES, $ext_shared)
&lt;/code&gt;&lt;/pre&gt;
">config.m4详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/ek0IMhO66/"" data-c="
          &lt;p&gt;使用C语言开发PHP扩展时可能需要使用到全局变量，在使用全局变量时涉及到线程安全的问题，PHP设计了TSRM(线程安全资源管理器)来解决这个问题。在扩展开发中需要按照TSRM的规范定义全局变量。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;zend_begin_module_globals-zend_end_module_globals&#34;&gt;ZEND_BEGIN_MODULE_GLOBALS、ZEND_END_MODULE_GLOBALS&lt;/h2&gt;
&lt;p&gt;PHP为扩展的全局变量提供一种存储方式：每个扩展将自己所有的全局变量统一定义在结构体中，然后将这个结构体注册到TSRM中。&lt;/p&gt;
&lt;p&gt;ZEND_BEGIN_MODULE_GLOBALS、ZEND_END_MODULE_GLOBALS便是用来定义这个结构体的。使用方式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_BEGIN_MODULE_GLOBALS(extension_name)
    zend_long   val
    HashTable   table
ZEND_END_MODULE_GLOBALS(extension_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;zend_declare_module_globals&#34;&gt;ZEND_DECLARE_MODULE_GLOBALS&lt;/h2&gt;
&lt;p&gt;定义好存储全局变量的结构体后，便需要将该结构体注册进TSRM中。ZEND_DECLARE_MODULE_GLOBALS宏就是用于处理这个操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_DECLARE_MODULE_GLOBALS(extension_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;zend_module_globals_accessor&#34;&gt;ZEND_MODULE_GLOBALS_ACCESSOR&lt;/h2&gt;
&lt;p&gt;访问扩展中定义的全局变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ZEND_MODULE_GLOBALS_ACCESSOR(extension_name, val)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然你也可以自己定义一个宏进行访问：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define TEST_G(val) ZEND_MODULE_GLOBALS_ACCESSOR(extension_name, val)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，在一个PHP扩展中并不是只能定义一个全局变量结构体，数量是不限制的。&lt;/p&gt;
&lt;/blockquote&gt;
">PHP扩展之全局变量的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/BCE4qebR7/"" data-c="
          &lt;p&gt;这段时间一直忙着写作业和论文，心力交瘁，今天突然发现好久没写博客了（心痛的感觉QAQ），所以来给网站擦擦灰。。&lt;/p&gt;
&lt;p&gt;其实以前是很耐心学过Git的，只是没有写博客记录相关内容，现在来补上这个坑 😃&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;值得注意的是：Git只能跟踪文本文件的内容变化，而不能跟踪二进制文件的内容变化（包括Word文档）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-安装git&#34;&gt;一、安装Git&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;
&lt;p&gt;在Windows下，可以在&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;官网&lt;/a&gt;上下载Windows的安装程序进行安装，安装完成打开Git Bash即可。&lt;/p&gt;
&lt;h3 id=&#34;mac&#34;&gt;Mac&lt;/h3&gt;
&lt;p&gt;第一种方法：使用Homebrew进行安装（如果已经安装了&lt;a href=&#34;https://brew.sh/index_zh-cn&#34;&gt;Homebrew&lt;/a&gt;的话），使用命令进行安装：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种方法：安装Xcode，Xcode集成了Git，但是默认未安装，你可以在Xcode的Preferences-&amp;gt;Download中安装Command Line Tools。&lt;/p&gt;
&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;
&lt;p&gt;Linux不同的发行版有不同的安装方式，可以尝试使用以下方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完成后，使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git config --global user.name &amp;quot;Your Name&amp;quot;
git config --global user.email &amp;quot;user@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置用户名和邮箱。&lt;/p&gt;
&lt;h2 id=&#34;二-git相关操作&#34;&gt;二、Git相关操作&lt;/h2&gt;
&lt;h3 id=&#34;1创建版本库仓库repository&#34;&gt;1.创建版本库(仓库，Repository)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir Test  
$ cd Test
$ git init    // 创建仓库
Initialized empty Git repository in /Volumes/办公/Alan/Test/.git/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK, 仓库已经建好，Git会在该目录下生成一个目录.git（.开头为隐藏目录），其用于跟踪管理这个仓库。&lt;/p&gt;
&lt;p&gt;如果使用的是某些特殊的shell，当切换到该目录时，可能会出现明显的变化，例如我使用的zsh，当执行git init创建好仓库后，切换到该目录下时（即Test），路径显示变成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Test git:(master) ✗ $
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2添加文件到版本库&#34;&gt;2.添加文件到版本库&lt;/h3&gt;
&lt;p&gt;添加文件到仓库，让Git跟踪该文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ touch readme.md     // 创建readme.md文件
$ git add readme.md   // 添加readme.md到仓库
$ git add test.php    // 添加test.php到仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3提交文件到版本库&#34;&gt;3.提交文件到版本库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git commit -m &amp;quot;add readme.me test.php&amp;quot; // 提交到仓库（-m参数是提交的相关说明，添加提交说明至关重要）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可多次使用git add添加多个文件，然后使用git commit一次进行提交。每次的git commit都会生成一个新的版本。&lt;/p&gt;
&lt;h3 id=&#34;4查看提交日志&#34;&gt;4.查看提交日志&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;commit bc916412b5b6ca835a21c72a530598db3ae38fb0 (HEAD -&amp;gt; master)
Author: AlanAlbert &amp;lt;1766447919@qq.com&amp;gt;
Date:   Thu Jun 21 09:27:42 2018 +0800

    upload Sort

commit ee45db03f09b212562520be5c1a4e1d853064a2e
Author: AlanAlbert &amp;lt;1766447919@qq.com&amp;gt;
Date:   Thu Jun 21 09:17:41 2018 +0800

    upload readme.md test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git log会根据时间倒序显示每条提交记录，包括提交者、提交时间以及提交说明，也可以给git log加上参数--pretty=oneline让其只显示一行，只包括提交说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bc916412b5b6ca835a21c72a530598db3ae38fb0 (HEAD -&amp;gt; master) upload Sort
ee45db03f09b212562520be5c1a4e1d853064a2e upload readme.md test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面两次都出现的很长一串的字符串是每次提交的id，其通过SHA1计算出来的十六进制数字，保证唯一性。&lt;/p&gt;
&lt;h3 id=&#34;5重置版本&#34;&gt;5.重置版本&lt;/h3&gt;
&lt;p&gt;当前版本可以在git log的结果中看到，其用HEAD指向当前版本。上一个版本则为&lt;code&gt;HEAD^&lt;/code&gt;，上上个版本为&lt;code&gt;HEAD^^&lt;/code&gt;，上5个版本可以表示为&lt;code&gt;HEAD~5&lt;/code&gt;。重置到上一个版本为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git reset --hard HEAD^
HEAD is now at ee45db0 upload readme.md test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用git log --pretty=oneline显示结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ee45db03f09b212562520be5c1a4e1d853064a2e (HEAD -&amp;gt; master) upload readme.md test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见HEAD指向了上一个commit版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git reset命令将HEAD指向另一个commit版本，并将工作目录进行更新。&lt;/p&gt;
&lt;p&gt;那么--hard参数是干什么的呢？git reset的参数有三个：--soft、--hard、--mixed，默认为mixed。&lt;/p&gt;
&lt;p&gt;① &lt;strong&gt;--soft&lt;/strong&gt;: HEAD指向另一个commit版本，而工作区和暂存区不发生变化。即，将HEAD头指针恢复，而add的缓存和工作区的所有东西都不变。&lt;/p&gt;
&lt;p&gt;② &lt;strong&gt;--mixed&lt;/strong&gt;: HEAD的指向、暂存区都发生变化，工作区不发生变化。即，将HEAD头指针恢复，add的缓存也会丢失，但工作区文件不变。&lt;/p&gt;
&lt;p&gt;③ &lt;strong&gt;--hard&lt;/strong&gt;: HEAD的指向、暂存区、工作区都发生变化。即，HEAD头指针恢复、add的缓存丢失、工作区的代码修改将恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在回退到上一个版本后，最新的那个版本不见了，如果又想回到最新的版本怎么办？&lt;br&gt;
办法是有的，只要你知道最新版本的commit id，可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git reset --hard bc91641
HEAD is now at bc91641 upload Sort
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;commit id并不需要输入完整，只要能够唯一区分目标版本即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果实在不记得版本的id，有两种方法可以进行查找，&lt;/p&gt;
&lt;p&gt;第一种较简单：使用命令git reflog，第一列显示就是版本id&lt;/p&gt;
&lt;p&gt;第二种比较麻烦：在日志文件.git/logs/refs/heads/master中查看，其内容如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;0000000000000000000000000000000000000000 ee45db03f09b212562520be5c1a4e1d853064a2e username &amp;lt;user@example.com&amp;gt; 1529543861 +0800	commit (initial): upload readme.md test.php
ee45db03f09b212562520be5c1a4e1d853064a2e bc916412b5b6ca835a21c72a530598db3ae38fb0 username &amp;lt;user@example.com&amp;gt; 1529544462 +0800	commit: upload Sort
/*结构组成如下：
上一个版本id 当前版本id 用户名 用户邮箱 时间戳 时区(+0800表示正8时区，北京所在时区) 执行的操作: 操作说明
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6工作区-working-copy和暂存区staging-copy&#34;&gt;6.工作区 （working copy）和暂存区（staging copy）&lt;/h3&gt;
&lt;p&gt;工作区不用多说，其就是我们可见的目录。&lt;br&gt;
而在工作区下的隐藏文件夹.git下包含一个叫做stage或index的暂存区、第一个分支master以及指向master的指针HEAD，git add就是将文件添加至暂存区，git commit将暂存区的所有内容提交到当前分支，提交后暂存区的内容清空。&lt;/p&gt;
&lt;h3 id=&#34;7查看状态&#34;&gt;7.查看状态&lt;/h3&gt;
&lt;p&gt;使用git status可以查看状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git status
On branch master
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

  new file:   test1.php
	modified:   test2.php
	
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

	modified:   test3.php

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
  
	test4.php

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;master分支下状态结果显示分三个状态：&lt;br&gt;
① Changes to be committed表示已添加到暂存区但未提交的修改&lt;br&gt;
② Changes not staged for commit表示被修改但未未添加到暂存区的修改，执行git add filename后该修改便会出现在状态① Changes to be committed中，并显示为modified: filename&lt;br&gt;
③ Untracked files表示未跟踪的文件，执行git add filename后该文件便会出现在状态① Changes to be committed中，并显示为new file: filename&lt;/p&gt;
&lt;h3 id=&#34;8查看差异&#34;&gt;8.查看差异&lt;/h3&gt;
&lt;p&gt;使用git diff HEAD可以显示最新提交版本和工作区的差异：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git diff HEAD
diff --git a/test.php b/test.php
index 94fd6d7..46a8d83 100644
--- a/test.php
+++ b/test.php
@@ -1,7 +1,6 @@
 &amp;lt;?php
 /**
- * add line
+ * test line
  */
    
diff --git a/test2.php b/test2.php
index 10d6ee9..4a3f8ca 100644
--- a/test2.php
+++ b/test2.php
@@ -1,6 +1,6 @@
 &amp;lt;?php
-
+// test.line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，git diff HEAD会显示工作区和最新版本之间所有的差异，如果要检查某一个文件在工作区和最新提交版本之间的差异则使用git diff HEAD -- test.php：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$git diff HEAD -- test.php
diff --git a/test.php b/test.php
index 94fd6d7..46a8d83 100644
--- a/test.php
+++ b/test.php
@@ -1,7 +1,6 @@
 &amp;lt;?php
 /**
- * add line
+ * test line
  */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9撤销修改&#34;&gt;9.撤销修改&lt;/h3&gt;
&lt;p&gt;对工作区进行修改后，如果想要放弃这次的修改可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git checkout -- test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令会让工作区的文件回到最近一次git commit或git add时的状态。&lt;/p&gt;
&lt;h3 id=&#34;10删除文件&#34;&gt;10.删除文件&lt;/h3&gt;
&lt;p&gt;当删除工作区的文件后，使用git status查看状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git status 
Changes not staged for commit:
  (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

	deleted:    readme.md
	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用以下命令删除版本库的filename文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git rm filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用git commit将修改提交到版本库。&lt;/p&gt;
&lt;h3 id=&#34;11添加远程仓库&#34;&gt;11.添加远程仓库&lt;/h3&gt;
&lt;p&gt;以使用的较多的GitHub为例。&lt;br&gt;
首先，需要在GitHub上为你的账户配置ssh密钥，确保在电脑上可以通过GitHub的验证，可以在命令行或终端使用如下命令进行测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ssh git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若结果显示为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;PTY allocation request failed on channel 0
Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
Connection to github.com closed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则表示通过GitHub的验证；&lt;/p&gt;
&lt;p&gt;然后，使用命令关联远程仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git remote add origin git@github.com:username/test.git 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，origin为远程库的名字，然后使用git push将本地库内容推送到远程库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次推送时加上-u参数，Git不但会把master分支内容推送给远程新的master分支，还会把本地master分支和远程master分支关联起来。在以后将本地内容推送到远程仓库时，只需要使用以下命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将远程库的更改合并至当前库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git pull origin master:test // 远程master与test分支合并
$ git pull origin master // 远程master和当前分支合并
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11从远程仓库克隆&#34;&gt;11.从远程仓库克隆&lt;/h3&gt;
&lt;p&gt;远程仓库的内容克隆到本地：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone git@github.com:username/test.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，Git就会下载远程仓库的内容到本地。&lt;br&gt;
Git默认使用的是ssh协议，除此之外还可以使用https等协议，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone https://github.com/username/test.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12分支管理&#34;&gt;12.分支管理&lt;/h3&gt;
&lt;p&gt;首先了解一下分支是什么？每个分支都是一条timeline(时间线)，前面用到的分支就是master主分支，用户可以在分支上单独操作互不影响。&lt;br&gt;
创建test分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git branch test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到test分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git checkout test
Switched to branch &#39;test&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上两步也可以使用一个命令完成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git checkout -b test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有分支（*号表示当前分支）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git branch
  master
* test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git checkout master
$ git merge test
Updating 8d8593e..4b01548
Fast-forward
 google.md | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 google.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git branch -d test
Deleted branch test (was cfc8d84).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了更好的理解Git的分支，我们做一个小试验：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① git init创建一个仓库&lt;/p&gt;
&lt;p&gt;② 在master分支中新建readme.md，使用git add和git commit提交至仓库&lt;/p&gt;
&lt;p&gt;③ 使用git checkout -b test1新建并切换至test1分支，在test1分支中新建并提交test1.md&lt;/p&gt;
&lt;p&gt;④ 使用git checkout -b test2新建并切换至test2分支，在test2分支中新建并提交test2.md&lt;/p&gt;
&lt;p&gt;⑤ 使用git checkout master切换至master分支，在master分支中新建test.md文件，并提交&lt;/p&gt;
&lt;p&gt;⑥ 此时，各分支状况如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/git/1.png&#34; alt=&#34;分支状况1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⑦ 在master、test1、test2分支中切换时，工作区的文件也会随之变化：切换到master时，工作区有readme.md和test.md；切换至test1分支时，工作区有readme.md和test1.md；切换至test2分支时，工作区有readme.md和test2.md文件&lt;/p&gt;
&lt;p&gt;⑧ 切换至master分支，使用git merge test1 test2将test1和test2分支合并至master&lt;/p&gt;
&lt;p&gt;⑨ 此时，master分支下的文件包含原来的readme.md、test.md以及加入的test1.md、test2.md，而test1和test2分支未发生变化&lt;/p&gt;
&lt;p&gt;⑩ 这时的test1和test2可以用git branch -d test1 test2进行删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，如果存在两个分支master、test，它们对同一个文件readme.md进行修改（master在文件末尾加入master line，test在文件末尾加入test line），这时，当将test分支合并到master分支时Git会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git merge test
Auto-merging readme.md
CONFLICT (content): Merge conflict in readme.md
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用git status查看状态也会提示文件在两个分支都修改了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;On branch master
Your branch is ahead of &#39;origin/master&#39; by 6 commits.
  (use &amp;quot;git push&amp;quot; to publish your local commits)

You have unmerged paths.
  (fix conflicts and run &amp;quot;git commit&amp;quot;)
  (use &amp;quot;git merge --abort&amp;quot; to abort the merge)

Unmerged paths:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to mark resolution)

	both modified:   readme.md

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，需要手动对master主分支下的readme.md文件进行修改，使用vim readme.md打开文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;  1 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
  2 master line
  3 =======
  4 test line
  5 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git将两个分支的readme.md的内容使用&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;、=======、&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;区分开来。将内容修改为目标内容，然后git add、git commit即可完成合并。（使用git log --graph可以查看分支合并图）&lt;/p&gt;
&lt;h3 id=&#34;13分支管理策略&#34;&gt;13.分支管理策略&lt;/h3&gt;
&lt;p&gt;在合并分支时，如果不指定合并模式，Git会默认使用Fast forward模式，在这个模式下，删除分支信息后，会丢失分支信息。我们可以在合并分支时加上--no-ff参数禁用Fast forward模式，此时Git在合并时会生成一个新的commit：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git merge --no-ff -m &#39;merge test&#39; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用git log --graph --pretty=oneline分别查看禁用Fast forward和不禁用时的区别：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 不禁用时：
$ git merge test
* 06cf0607846548da37edf16cba68a4b46ba95835 (HEAD -&amp;gt; master) add test.md
* 9ee02e9c78cde794543df93ab508fefb2b7f7667 add readme.md

# 禁用时：
% git merge --no-ff -m &#39;merge test&#39; test
*   2e6de5d4c6f4c919d63b553615181f51411b3a99 (HEAD -&amp;gt; master) merge test
|\  
| * bbfb8e492523ba516e69813ce7b6b09b7ccd3778 test.md
|/  
* 9ee02e9c78cde794543df93ab508fefb2b7f7667 add readme.md

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14隐藏改变&#34;&gt;14.隐藏改变&lt;/h3&gt;
&lt;p&gt;当正在为一个Web应用程序进行升级时，突然发现当前版本的程序存在Bug，需要优先修复Bug，此时，升级的工作未完成，尚不能commit，而由于升级修改的文件会影响原来版本，怎么办？&lt;/p&gt;
&lt;p&gt;使用git stash命令即可隐藏工作区未提交的工作（前提需要将文件添加到仓库，使得Git能够追踪这些文件）。例如，在当前目录下创建test.md文件并添加至仓库，此时使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git stash
Saved working directory and index state WIP on master: 9ee02e9 add readme.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，那些未上传的文件在工作区消失了，可以使用以下命令进行查看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git stash list
stash@{0}: WIP on master: 9ee02e9 add readme.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git将相对于最近commit的修改保存至一个类似队列的结构中，可以尝试在使用git stash后再次添加一个文件并使用git stash，然后使用git stash list即可查看到两个stash。&lt;/p&gt;
&lt;p&gt;隐藏后如何恢复呢？&lt;br&gt;
① 使用git stash apply，使用后stash的记录和内容不会删除，可以使用git stash drop进行删除；&lt;br&gt;
② 使用git stash pop弹出stash，在恢复的同时，删除stash&lt;/p&gt;
&lt;h3 id=&#34;15标签管理&#34;&gt;15.标签管理&lt;/h3&gt;
&lt;p&gt;添加标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git tag v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git默认是为当前分支下的最新commit版本添加标签，如果想为历史提交的版本添加标签，添加上commit id即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git tag v1.0 commitid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git tag
v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看标签详细信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git show v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git tag -d v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地标签不会自动推送至远程，可以手动推送至远程库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git push origin v1.0   // 推送标签名v1.0至远程库
$ git push origin --tags // 推送所有标签至远程库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除远程库标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git push origin :refs/tags/v1.0  // 删除标签v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;16多人协作的工作流程&#34;&gt;16.多人协作的工作流程&lt;/h3&gt;
&lt;p&gt;多人协作的工作模式通常是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果合并有冲突，则解决冲突，并在本地提交；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。&lt;/p&gt;
&lt;p&gt;这就是多人协作的工作模式，一旦熟悉了，就非常简单。&lt;/p&gt;
&lt;h2 id=&#34;三-总结&#34;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;善用Git的--help可以帮助更好的使用命令，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git --help
$ git pull --help
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git config —global user.name “&amp;lt; username &amp;gt;&amp;quot;&lt;/td&gt;
&lt;td&gt;配置用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git config —global user.email “&amp;lt; user@example.com &amp;gt;&amp;quot;&lt;/td&gt;
&lt;td&gt;配置邮箱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git init&lt;/td&gt;
&lt;td&gt;创建版本库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git add &amp;lt; file &amp;gt;&lt;/td&gt;
&lt;td&gt;添加文件到版本库（Git追踪该文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git commit -m “&amp;lt; commit message &amp;gt;&amp;quot;&lt;/td&gt;
&lt;td&gt;将改动提交到版本库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git log [--graph --pretty=oneline ...]&lt;/td&gt;
&lt;td&gt;查看版本库日志信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reflog&lt;/td&gt;
&lt;td&gt;查看所有分支的所有操作日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reset --hard &amp;lt; version &amp;gt;&lt;/td&gt;
&lt;td&gt;重置版本,HEAD^,HEAD~5,commit id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git status&lt;/td&gt;
&lt;td&gt;查看状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git diff &amp;lt; version &amp;gt;&lt;/td&gt;
&lt;td&gt;查看版本和当前工作区差异&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout — &amp;lt; file &amp;gt;&lt;/td&gt;
&lt;td&gt;恢复至最近commit或add时的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git rm &amp;lt; file &amp;gt;&lt;/td&gt;
&lt;td&gt;从版本库删除文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git remote add &amp;lt; 远程库名 &amp;gt; &amp;lt; address &amp;gt;&lt;/td&gt;
&lt;td&gt;关联远程仓库（远程库名、地址）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push [-u] &amp;lt; 远程库名 &amp;gt; &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;本地库内容推送至远程，第一次加-u（，分支）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git pull origin &amp;lt; 远程分支名 &amp;gt;:&amp;lt; 本地分支名 &amp;gt;&lt;/td&gt;
&lt;td&gt;将远程库的更改合并至当前库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git clone &amp;lt; address &amp;gt;&lt;/td&gt;
&lt;td&gt;远程仓库的内容克隆到本地&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;添加分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch -d &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;删除分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git branch&lt;/td&gt;
&lt;td&gt;显示所有分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout -b &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;新建并切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git merge &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;合并分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git merge --no-ff -m “&amp;lt; commit message &amp;gt;” &amp;lt; branch &amp;gt;&lt;/td&gt;
&lt;td&gt;禁用Fast forward模式合并分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git stash&lt;/td&gt;
&lt;td&gt;隐藏已跟踪未提交的工作区内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git stash list&lt;/td&gt;
&lt;td&gt;显示stash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git stash apply&lt;/td&gt;
&lt;td&gt;恢复隐藏内容，但不删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git stash drop&lt;/td&gt;
&lt;td&gt;删除stash记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git stash pop&lt;/td&gt;
&lt;td&gt;恢复隐藏内容，并删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git tag &amp;lt; tag name &amp;gt; [&amp;lt; commit id &amp;gt;]&lt;/td&gt;
&lt;td&gt;添加标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git tag&lt;/td&gt;
&lt;td&gt;显示所有标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git show &amp;lt; tag name &amp;gt;&lt;/td&gt;
&lt;td&gt;显示tag详细信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git tag -d &amp;lt; tag name &amp;gt;&lt;/td&gt;
&lt;td&gt;删除标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push &amp;lt; 远程库名 &amp;gt; &amp;lt; tag name &amp;gt;&lt;/td&gt;
&lt;td&gt;推送标签至远程库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push &amp;lt; 远程库名 &amp;gt; --tags&lt;/td&gt;
&lt;td&gt;推送所有标签至远程库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push &amp;lt; 远程库名 &amp;gt; :refs/tags/&amp;lt; tag name &amp;gt;&lt;/td&gt;
&lt;td&gt;删除远程库标签&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;四-实际使用&#34;&gt;四、实际使用&lt;/h2&gt;
&lt;h3 id=&#34;1-在github上修改他人项目的代码&#34;&gt;1、在GitHub上，修改他人项目的代码&lt;/h3&gt;
&lt;p&gt;① 在GitHub上，将项目从他人仓库fork到自己仓库；&lt;/p&gt;
&lt;p&gt;② 使用git clone将自己仓库的项目clone到本地；&lt;/p&gt;
&lt;p&gt;③ 修改完代码后，将修改push到自己远程仓库；&lt;/p&gt;
&lt;p&gt;④ 在GitHub上，创建Pull Request，等待原仓库管理员的审核；&lt;/p&gt;
&lt;h3 id=&#34;2-pull-request被合并后&#34;&gt;2、Pull Request被合并后&lt;/h3&gt;
&lt;p&gt;最近在GitHub上修改别人的代码，遇到一个问题：我在第二次提交Pull Request时，将第一次已合并的Pull Request再次提交了上去。（毕竟第一次嘛😂&lt;/p&gt;
&lt;p&gt;需要注意的是，在我们的Pull Request被合并时，我们需要做的工作有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 给fork配置远程库：&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;git remote -v&lt;/code&gt;可以查看远程仓库状态。如果结果中没有原仓库的配置，可以使用&lt;code&gt;git remote add 自定义名 原仓库地址&lt;/code&gt;进行配置，例如：&lt;code&gt;git remote add nickname https://github.com/username/repostory.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;② 使用&lt;code&gt;git fetch nickname&lt;/code&gt;从原仓库fetch分支和提交点到本地，并存储到本地分支nickname/master&lt;/p&gt;
&lt;p&gt;③ 切换到master分支：&lt;code&gt;git checkout master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;④ 将nickname/master分支合并到本地master：&lt;code&gt;git merge nickname/master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;⑤ 更新到GitHub的fork上：&lt;code&gt;git push origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（原仓库即上游仓库）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">Git补坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/YZYCy5Hq6/"" data-c="
          &lt;p&gt;前两天在面试中，遇到Git Flow的问题，涉及到知识盲区，今天趁有空学习一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是git-flow&#34;&gt;什么是Git Flow&lt;/h2&gt;
&lt;p&gt;Git Flow是2010年由&lt;a href=&#34;https://nvie.com/about/&#34;&gt;Vincent Driessen&lt;/a&gt;提出的在进行产品开发时Git的行为规范（&lt;a href=&#34;https://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;原文链接&lt;/a&gt;）。类似的规范还有Github Flow、Gitlab Flow。&lt;/p&gt;
&lt;h2 id=&#34;git-flow的分支&#34;&gt;Git Flow的分支&lt;/h2&gt;
&lt;p&gt;Git Flow中定义了两类分支：主分支、辅助分支。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主分支用于组织与软件开发、部署相关的活动。主分支是所有开发活动的核心分支，可分为&lt;code&gt;master分支&lt;/code&gt;、&lt;code&gt;develop分支&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;辅助分支是为了解决特定的问题而进行的各种开发活动。辅助分支有&lt;code&gt;feature分支&lt;/code&gt;、&lt;code&gt;release分支&lt;/code&gt;、&lt;code&gt;hotfix分支&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;master分支&#34;&gt;master分支&lt;/h3&gt;
&lt;p&gt;master分支用于存放可上线的稳定代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源：&lt;code&gt;release分支&lt;/code&gt;、&lt;code&gt;hotfix分支&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去向：无&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;develop分支&#34;&gt;develop分支&lt;/h3&gt;
&lt;p&gt;develop 分支是开发的基础分支，当需要增加功能时可以从该分支切出一个 feature 分支。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源：&lt;code&gt;feature分支&lt;/code&gt;、&lt;code&gt;release分支&lt;/code&gt;、&lt;code&gt;hotfix分支&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去向：&lt;code&gt;release分支&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feature分支&#34;&gt;feature分支&lt;/h3&gt;
&lt;p&gt;当需要增加新功能时，使用 feature 分支。feature 分支从 develop 分支切出，完成时也要合并到 develop 分支。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源：&lt;code&gt;develop分支&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去向：&lt;code&gt;develop分支&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;release分支&#34;&gt;release分支&lt;/h3&gt;
&lt;p&gt;release 分支是发布到 master 分支前的版本。可以把已完成的 develop 分支合并到 release 分支，在该分支上做最后的测试。测试通过即可完成 release 分支，完成时会将 release 合并到 master 以及 develop 两个分支上。合并到 develop 分支是因为在 Release 分支上可能会有代码修改，需要将修改同步到 develop 分支上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源：&lt;code&gt;develop分支&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去向：&lt;code&gt;master分支&lt;/code&gt;、&lt;code&gt;develop分支&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常用命名：release-*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;hotfix分支&#34;&gt;hotfix分支&lt;/h3&gt;
&lt;p&gt;当线上产品产生Bug时，从 master 分支开一个 hotfix 分支用于修复，修复完成后会合并到 master、develop 分支。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源：&lt;code&gt;master分支&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;去向：&lt;code&gt;master分支&lt;/code&gt;、&lt;code&gt;develop分支&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常用命名：hotfix-*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上分支的关系如下图所示（引用自&lt;a href=&#34;https://segmentfault.com/a/1190000006194051&#34;&gt;Git Flow简介&lt;/a&gt;）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;/post-images/1617678407230.png&#34; alt=&#34;Git Flow分支&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;git-flow&#34;&gt;git-flow&lt;/h2&gt;
&lt;p&gt;git-flow是配合Git Flow工作流程使用的一个Git扩展。可以简化Git Flow的操作。&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Mac OSX&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install git-flow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Debian/Ubuntu Linux&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;apt-get install git-flow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Windows搭配Cygwin&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow init
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;feature&#34;&gt;feature&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新建feature分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow feature start FeatureName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;结束feature分支（将当前feature分支合并到develop；删除当前分支；并切换到develop分支）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow feature finish FeatureName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;公布feature分支（当需要与同伴一起开发时，将feature分支公布到服务器上）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow feature publish FeatureName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从服务器上获取一个别人公布的feature分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow feature pull origin FeatureName
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;release&#34;&gt;release&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建一个release分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow release start ReleaseName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;公布一个release分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow release publish ReleaseName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;结束一个release分支（把release分支合并回master，给本次发布打tag；把release合并回develop；删除release分支）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow release finish ReleaseName
// 最后不要忘记把tag push到服务器：git push --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hotfix&#34;&gt;hotfix&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建一个hotfix分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow hotfix start HotfixName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;结束一个hotfix分支（合并到develop、master分支，并删除hotfix分支）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git flow hotfix finish HotfixName
&lt;/code&gt;&lt;/pre&gt;
">Git Flow与git-flow的介绍</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/arQUCWSCr/"" data-c="
          &lt;p&gt;自己收集的一些数据库设计和使用的优化方法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;优化sql语句&#34;&gt;优化SQL语句&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应避免全表扫描，首先应考虑在where和order by的列上建立索引&lt;/li&gt;
&lt;li&gt;避免在where条件中进行null判断，且表的设计也应该尽量使用not null&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;《高性能MySQL》书中提到：MySQL难以优化引用可为null的查询，它会使索引、索引统计和值更加复杂。可为null的列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MyISAM中固定大小的索引变成可变大小的索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应避免使用&lt;code&gt;!=&lt;/code&gt;或&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;操作符，MySQL只有对以下操作才使用索引：&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;=&lt;/code&gt;、&lt;code&gt;=&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;BETWEEN&lt;/code&gt;、&lt;code&gt;IN&lt;/code&gt;、以及形如&lt;code&gt;name LIKE &#39;Alan%&#39;&lt;/code&gt;的&lt;code&gt;LIKE&lt;/code&gt;(%放在后面，%放在前面的可以使用全文索引)&lt;/li&gt;
&lt;li&gt;应避免在&lt;code&gt;where&lt;/code&gt;中使用&lt;code&gt;or&lt;/code&gt;来连接条件，否则会导致引擎放弃使用索引而进行全表扫描，可以使用&lt;code&gt;union all&lt;/code&gt;进行联合查询&lt;/li&gt;
&lt;li&gt;使用联合查询时，应尽量使用&lt;code&gt;union all&lt;/code&gt;代替&lt;code&gt;union&lt;/code&gt;，因为&lt;code&gt;union&lt;/code&gt;会对结果进行去重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;not in&lt;/code&gt;也会导致全表扫描，对于连续的数值，应尽量使用&lt;code&gt;between ... and ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免在&lt;code&gt;where&lt;/code&gt;中对字段进行&lt;strong&gt;表达式操作&lt;/strong&gt;和&lt;strong&gt;函数操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;避免在&lt;code&gt;where中&lt;/code&gt;使用参数，其也会导致全表扫描。因为SQL在执行时才能解析局部变量，因此在编译时无法建立索引，可以修改为强制使用索引：&lt;code&gt;SELECT id FROM table FORCE INDEX(index_name) WHERE num=@num&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;exists&lt;/code&gt;代替&lt;code&gt;in&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一张表的索引应尽量不多于6个，虽然索引可以加速查询，但同时也提高了索引的维护成本，降低插入数据及更新数据的速度&lt;/li&gt;
&lt;li&gt;尽可能避免更新聚集(clustered)索引数据列，因为操作聚集索引会消耗相当大的资源（&lt;a href=&#34;mweblib://15628148741975&#34;&gt;聚集索引、非聚集索引及主键&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;只含数值信息的字段尽量使用数字型字段，以提高查询和连接的性能&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;varchar&lt;/code&gt;代替&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询时只查询需要的字段，而不是使用&lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当连接多个表时，使用&lt;code&gt;as&lt;/code&gt;设置表的别名并使用别名访问列，如：&lt;code&gt;SELECT t1.name, t2.class_name FROM table1 AS t1 JOIN table2 AS t2 ON t1.class_id=t2.id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量少用子查询&lt;/li&gt;
&lt;li&gt;不要超过5个以上的&lt;code&gt;JOIN&lt;/code&gt;，可以使用中间变量或临时表存放中间结果&lt;/li&gt;
&lt;li&gt;统计行数时使用&lt;code&gt;COUNT(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量使用&lt;code&gt;&amp;gt;=&lt;/code&gt;代替&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过将不需要的记录在&lt;code&gt;GROUP BY&lt;/code&gt;之前过滤掉&lt;/li&gt;
&lt;li&gt;使用慢查询日志查看慢查询的语句&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;explain&lt;/code&gt;分析SQL语句的执行计划&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;LIMIT&lt;/code&gt;查询只需要的数据&lt;/li&gt;
&lt;li&gt;建立索引&lt;code&gt;index(a,b,c)&lt;/code&gt;，存储引擎不能使用索引范围条件右边的列作为索引，例如：&lt;code&gt;select * from where a=&#39;Alan&#39; and b&amp;gt;25 and c=&#39;dev&#39;&lt;/code&gt;，此时，只有a和b使用到索引&lt;/li&gt;
&lt;li&gt;尽量只访问索引列的查询，避免&lt;code&gt;select *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is null&lt;/code&gt;或&lt;code&gt;is not null&lt;/code&gt;也会无法使用索引&lt;/li&gt;
&lt;li&gt;隐式转换：&lt;code&gt;select * from test where name=123&lt;/code&gt;，此时不会使用索引，应为&lt;code&gt;name&lt;/code&gt;加上单引号&lt;/li&gt;
&lt;li&gt;少用&lt;code&gt;or&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何建立索引&#34;&gt;如何建立索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每个表都需要主键索引&lt;/li&gt;
&lt;li&gt;数据量超过300的表应该建立索引&lt;/li&gt;
&lt;li&gt;对经常出现在where条件中或order by中的字段建立索引&lt;/li&gt;
&lt;li&gt;经常需要与其他表进行连接的表，在其连接字段上建立索引&lt;/li&gt;
&lt;li&gt;索引应该建立在数据量小的字段&lt;/li&gt;
&lt;li&gt;频繁进行数据操作的表不应建立过多索引&lt;/li&gt;
&lt;li&gt;复合索引应注意前缀原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;慎用&#34;&gt;慎用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt;或&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;形如&lt;code&gt;name LIKE %Alan&lt;/code&gt;的&lt;code&gt;LIKE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IN&lt;/code&gt;和&lt;code&gt;NOT IN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子查询&lt;/li&gt;
&lt;/ul&gt;
">数据库使用和设计的优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/tD_-5wiPT/"" data-c="
          &lt;h2 id=&#34;svnadmin&#34;&gt;svnadmin&lt;/h2&gt;
&lt;h3 id=&#34;1-使用svnadmin初始化svn项目&#34;&gt;1、使用svnadmin初始化SVN项目:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svnadmin create /home/user1/project
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-修改配置文件&#34;&gt;2、修改配置文件&lt;/h3&gt;
&lt;p&gt;① 修改passwd，添加用户密码，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[users]
alan = 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 修改权限文件authz，给用户设置权限：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[aliases]

[groups]

[/]
alan = rw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 修改SVN服务器配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[general]
# 以下两个配置的可选选项有read、write、none，read为只读权限，write为可读可写权限，none为不可读不可写
# 未认证用户权限
anon-access = read    
# 认证用户权限
auth-access = write  

# 用户密码数据，指定为第一步修改的文件
password-db = passwd
# 用户权限数据，指定为第二步修改的文件
authz-db = authz
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;svnserve&#34;&gt;svnserve&lt;/h2&gt;
&lt;p&gt;svnserve命令用于启动SVN服务。可选参数有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-r: 指定SVN服务的root目录&lt;br&gt;
-d: Daemon守护程序方式运行&lt;br&gt;
-R: Read Only&lt;br&gt;
-i: 超级服务器模式&lt;br&gt;
-t: 隧道模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动SVN服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svnserve -d -r /home/user1/project
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;svn&#34;&gt;svn&lt;/h2&gt;
&lt;h3 id=&#34;1-从svn服务器下拉代码&#34;&gt;1、从SVN服务器下拉代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn chekout svn://127.0.0.1
// 或 svn co svn://127.0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-查看当前工作目录下的文件状态&#34;&gt;2、查看当前工作目录下的文件状态&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn status
// 或 svn st
// ? 表示未在SVN的控制下
// M 表示已修改
// A 表示已添加
// D 表示已删除
// C 表示冲突文件
// I 表示忽略的文件
// R 表示被替换
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-查看当前工作目录下文件的版本差异&#34;&gt;3、查看当前工作目录下文件的版本差异&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn diff [file]
// file为可选参数，表示查看指定文件的差异
svn diff -r m:n file
// 查看m版本和n版本的文件差异

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-提交文件到svn服务器&#34;&gt;4、提交文件到SVN服务器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn commit -m &#39;【新增】a.php&#39;
// 或 svn ci -m &#39;【新增】a.php&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-从svn服务器更新文件到本地&#34;&gt;5、从SVN服务器更新文件到本地&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn update [file]
// 或 svn up [file]
// file为可选参数，表示只更新指定文件内容
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-加锁与解锁&#34;&gt;6、加锁与解锁&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 加锁，锁定目录，让别人无法提交更新到这里
svn lock file -m &#39;【锁定】a.php&#39;
// 解锁
svn unlock file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-查看svn日志&#34;&gt;7、查看SVN日志&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn log [file]
// 查看版本日志信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8-查看文件或项目详细信息&#34;&gt;8、查看文件或项目详细信息&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn info [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9-合并分支&#34;&gt;9、合并分支&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn merge -r m:n file
// 合并m版本和n版本的file文件差异，例如：svn merge -r 500:502 a.php
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10-恢复本地修改&#34;&gt;10、恢复本地修改&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn revert file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-移除冲突状态&#34;&gt;11、移除冲突状态&lt;/h3&gt;
&lt;p&gt;在处理完文件冲突后，可以使用该命令移除文件冲突的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn resolved file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;svn代码库表更&#34;&gt;SVN代码库表更&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn switch URL
&lt;/code&gt;&lt;/pre&gt;
">SVN命令的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/a5xuigu8t/"" data-c="
          &lt;p&gt;OpCache、APC、APCu、XCache都是用于PHP加速的扩展，文中会讲述它们的工作原理及使用方法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在介绍这些工具之前，先简单的描述一下PHP的工作流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;PHP请求到来&lt;/li&gt;
&lt;li&gt;读取PHP文件&lt;/li&gt;
&lt;li&gt;Zend引擎进行词法分析与语法分析&lt;/li&gt;
&lt;li&gt;生成Zend可执行的指令opcode&lt;/li&gt;
&lt;li&gt;执行opcode&lt;/li&gt;
&lt;li&gt;返回响应&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;而OpCache、APC等此类工具就是通过缓存opcode指令来提升PHP的效率。&lt;/p&gt;
&lt;h2 id=&#34;opcache&#34;&gt;OpCache&lt;/h2&gt;
&lt;h3 id=&#34;开启opcache&#34;&gt;开启OpCache&lt;/h3&gt;
&lt;p&gt;OpCache在PHP 5.5及之后的版本是默认安装的，不需要我们去下载源码进行编译了，只要在PHP配置文件中开启即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[opcache]
zend_extension=opcache.so
opcache.enable=1
opcache.enable_cli=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;opcache是否生效&#34;&gt;OpCache是否生效&lt;/h3&gt;
&lt;p&gt;以下是opCache的更多配置（摘自&lt;a href=&#34;https://www.zybuluo.com/phper/note/1016714&#34;&gt;https://www.zybuluo.com/phper/note/1016714&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;opcache.enable=1 (default &amp;quot;1&amp;quot;)
;OPcache打开/关闭开关。当设置为Off或者0时，会关闭Opcache, 代码没有被优化和缓存。

opcache.enable_cli=1 (default &amp;quot;0&amp;quot;)
;CLI环境下，PHP启用OPcache。这主要是为了测试和调试。从 PHP 7.1.2 开始，默认启用。

opcache.memory_consumption=128 (default &amp;quot;64&amp;quot;)
;OPcache共享内存存储大小。用于存储预编译的opcode（以MB为单位）。

opcache.interned_strings_buffer=8 (default &amp;quot;4&amp;quot;)
;这是一个很有用的选项，但是似乎完全没有文档说明。PHP使用了一种叫做字符串驻留（string interning）的技术来改善性能。例如，如果你在代码中使用了1000次字符串“foobar”，在PHP内部只会在第一使用这个字符串的时候分配一个不可变的内存区域来存储这个字符串，其他的999次使用都会直接指向这个内存区域。这个选项则会把这个特性提升一个层次——默认情况下这个不可变的内存区域只会存在于单个php-fpm的进程中，如果设置了这个选项，那么它将会在所有的php-fpm进程中共享。在比较大的应用中，这可以非常有效地节约内存，提高应用的性能。
;这个选项的值是以兆字节（megabytes）作为单位，如果把它设置为16，则表示16MB，默认是4MB，这是一个比较低的值。

opcache.max_accelerated_files (default &amp;quot;2000&amp;quot;)
;这个选项用于控制内存中最多可以缓存多少个PHP文件。这个选项必须得设置得足够大，大于你的项目中的所有PHP文件的总和。设置值取值范围最小值是 200，最大值在 PHP 5.5.6 之前是 100000，PHP 5.5.6 及之后是 1000000。也就是说在200到1000000之间。你可以运行“find . -type f -print | grep php | wc -l”这个命令来快速计算你的代码库中的PHP文件数。

opcache.max_wasted_percentage (default &amp;quot;5&amp;quot;)
;计划重新启动之前，“浪费”内存的最大百分比。

opcache.use_cwd (default &amp;quot;1&amp;quot;)
;如果启用，OPcache将在哈希表的脚本键之后附加改脚本的工作目录， 以避免同名脚本冲突的问题。禁用此选项可以提高性能，但是可能会导致应用崩溃

opcache.validate_timestamps (default &amp;quot;1&amp;quot;)
;如果启用（设置为1），OPcache会在
opcache.revalidate_freq设置的秒数去检测文件的时间戳（timestamp）检查脚本是否更新。
;如果这个选项被禁用（设置为0），opcache.revalidate_freq会被忽略，PHP文件永远不会被检查。这意味着如果你修改了你的代码，然后你把它更新到服务器上，再在浏览器上请求更新的代码对应的功能，你会看不到更新的效果，你必须使用 `opcache_reset()` 或者 `opcache_invalidate()` 函数来手动重置 OPcache。或者重重你的web服务器或者php-fpm 来使文件系统更改生效。
;我强烈建议你在生产环境中设置为0，why？因为当你在更新服务器代码的时候，如果代码较多，更新操作是有些延迟的，在这个延迟的过程中必然出现老代码和新代码混合的情况，这个时候对用户请求的处理必然存在不确定性。最后，等所有的代码更新完毕后，再平滑重启PHP和web服务器。
    
opcache.revalidate_freq (default &amp;quot;2&amp;quot;)
;这个选项用于设置缓存的过期时间（单位是秒），当这个时间达到后，opcache会检查你的代码是否改变，如果改变了PHP会重新编译它，生成新的opcode，并且更新缓存。值为“0”表示每次请求都会检查你的PHP代码是否更新（这意味着会增加很多次stat系统调用，译注：stat系统调用是读取文件的状态，这里主要是获取最近修改时间，这个系统调用会发生磁盘I/O，所以必然会消耗一些CPU时间，当然系统调用本身也会消耗一些CPU时间）。可以在开发环境中把它设置为0，生产环境下不用管。
;如果 `opcache.validate_timestamps` 配置指令设置为禁用（设置为0），那么此设置项将会被忽略。
    
opcache.revalidate_path (default &amp;quot;0&amp;quot;)
;在include_path优化中启用或禁用文件搜索
;如果被禁用，并且找到了使用的缓存文件相同的include_path，该文件不被再次搜索。因此，如果一个文件与include_path中的其他地方相同的名称出现将不会被发现。如果此优化对此有效，请启用此指令你的应用程序，这个指令的默认值是禁用的，这意味着该优化是活跃的。
    
opcache.fast_shutdown（默认“0”）
;如果启用，则会使用快速停止续发事件。 所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。该指令已在PHP 7.2.0中被删除。快速关机序列的一个变种已经被集成到PHP中，并且如果可能的话将被自动使用。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;opcache其他内容&#34;&gt;OpCache其他内容&lt;/h3&gt;
&lt;p&gt;除了配置项以外，opCache还提供一些函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opcache_compile_file — 无需运行，即可编译并缓存 PHP 脚本，该函数可用于在 Web 服务器重启之后初始化缓存，俗称缓存预热&lt;/li&gt;
&lt;li&gt;opcache_get_configuration — 获取php.ini中的配置信息&lt;/li&gt;
&lt;li&gt;opcache_get_status — 获取缓存的状态信息&lt;/li&gt;
&lt;li&gt;opcache_invalidate — 废除脚本缓存&lt;/li&gt;
&lt;li&gt;opcache_is_script_cached — 一个php文件是否被缓存&lt;/li&gt;
&lt;li&gt;opcache_reset — 重置情况所有的缓存内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;apcalternative-php-cache-可选的php缓存&#34;&gt;APC（Alternative PHP Cache 可选的PHP缓存）&lt;/h2&gt;
&lt;p&gt;APC包含两个功能：用户缓存（用户数据缓存，类似MemCache）、opcode缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：apc的3.1.14版本存在严重的内存问题，被官方废弃。最新可用的apc版本为3.1.13，仅支持php 5.3.* 。之后的PHP版本中自带了opCache&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;apcuapc-user-cacheapc的用户缓存&#34;&gt;APCu（APC user cache，APC的用户缓存）&lt;/h2&gt;
&lt;p&gt;APCu保留了APC的用户数据缓存部分，去掉了opcode缓存。且提供的接口与APC一致。&lt;/p&gt;
&lt;h3 id=&#34;apcu的安装&#34;&gt;APCu的安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前往&lt;a href=&#34;http://pecl.php.net/package/APCu&#34;&gt;pecl下载页面&lt;/a&gt;下载源码包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压并进入源代码根目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用PHP的 &lt;code&gt;phpize&lt;/code&gt; 命令工具读取config.m4文件，并生成configure&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行生成的 &lt;code&gt;configure&lt;/code&gt; 文件: &lt;code&gt;./configure with-php-config=/usr/bin/php-config&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;make&lt;/code&gt; 及 &lt;code&gt;sudo make install&lt;/code&gt; 进行编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在php.ini中添加扩展:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[apcu]
extension      = apcu.so
apc.enabled    = on
apc.shm_size   = 256m
apc.enable_cli = on
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;apcu的使用&#34;&gt;APCu的使用&lt;/h3&gt;
&lt;p&gt;APCu的使用可以参考&lt;a href=&#34;https://www.php.net/manual/zh/book.apcu.php&#34;&gt;https://www.php.net/manual/zh/book.apcu.php&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;xcache&#34;&gt;XCache&lt;/h2&gt;
&lt;p&gt;XCache的安装与前面的安装方法类似：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前往&lt;a href=&#34;https://xcache.lighttpd.net/pub/Releases/&#34;&gt;https://xcache.lighttpd.net/pub/Releases/&lt;/a&gt;下载源代码压缩包&lt;/li&gt;
&lt;li&gt;解压并进入根目录&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;phpize&lt;/code&gt;、&lt;code&gt;./configure with-php-config=/usr/bin/php-config&lt;/code&gt;、&lt;code&gt;make&lt;/code&gt;、&lt;code&gt;sudo make install&lt;/code&gt;进行编译安装&lt;/li&gt;
&lt;li&gt;修改php.ini，添加扩展配置&lt;/li&gt;
&lt;/ol&gt;
">PHP的加速器--OpCache、APC、APCu、XCache</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/QqXXeBu-i/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;衡量算法优劣的指标&#34;&gt;衡量算法优劣的指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度&lt;/li&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链表有哪些&#34;&gt;链表有哪些&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单向链表&lt;/li&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线性结构&#34;&gt;线性结构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;线性结构是指一个有序数据元素的集合，除了第一个和最后一个外，其他元素都是首尾相接的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见的线性结构有：线性表、栈、队列、数据&lt;/p&gt;
&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;二叉搜索树&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;li&gt;红黑树&lt;/li&gt;
&lt;li&gt;B树&lt;/li&gt;
&lt;li&gt;B+树&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;散列表&#34;&gt;散列表&lt;/h2&gt;
&lt;p&gt;散列表，就是哈希（Hash）表，在PHP中，数组就是哈希表的实现。&lt;/p&gt;
&lt;p&gt;散列表是用来存储key-value键值对的数据结构，其原理是将key通过&lt;strong&gt;散列函数&lt;/strong&gt;计算，得到相应的&lt;strong&gt;桶&lt;/strong&gt;的序号，然后通过桶号直接访问value。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;散列函数应尽可能让所有key均匀地散布到整个集合。&lt;br&gt;
此外，散列函数计算得到的结果可能相同，这种情况就叫&lt;strong&gt;哈希冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理哈希冲突的常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉链法：在每个桶中存放一个链表，通过链表存储冲突的值&lt;/li&gt;
&lt;li&gt;开放地址法：用大小为M的数组保存N个键值对，其中M&amp;gt;N，数组中的空位用于解决冲突问题。线性探测法就是这种方法的具体实现：当发生碰撞时，我们会检测数组的下一个位置，直到找到该键或遇到一个空位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;选择排序：简单选择排序（每次选择最小或最大的排在起始位置）、堆排序（将序列构成最大堆或最小堆，将堆顶元素（最大元素或最小元素）放于序列末尾，然后将剩下的n-1个元素继续如上操作，直至得到有序序列）&lt;/li&gt;
&lt;li&gt;插入排序：简单插入排序（前面为有序序列，后面为无序序列，每次从无序序列中选择第一个元素，比较并插入到有序序列中的合适位置）、希尔排序&lt;/li&gt;
&lt;li&gt;交换排序：冒泡排序（比较相邻元素的大小，并按条件进行交换）、快速排序（选择一个数值，交换并保证比它小的元素在其左边，比它大的元素在其右边）&lt;/li&gt;
&lt;li&gt;归并排序（将序列分为左右两个子序列，对两个子序列分别进行归并排序，将排好序的两个子序列合并成最终的排序序列）&lt;/li&gt;
&lt;li&gt;基数排序：桶排序、基数排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他算法&#34;&gt;其他算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KPM（字符串查找算法）&lt;/li&gt;
&lt;li&gt;布隆过滤器（检索一个元素是否在集合中）&lt;/li&gt;
&lt;li&gt;贪心算法&lt;/li&gt;
&lt;li&gt;回溯算法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;最短路径&lt;/li&gt;
&lt;li&gt;推荐算法&lt;/li&gt;
&lt;li&gt;深度优先、广度优先&lt;/li&gt;
&lt;/ul&gt;
">面试问题之数据结构及算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/nDsg9NX3r/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PHP中的八大数据类型：整型、字符串、浮点型、布尔、数组、对象、NULL、资源。&lt;/li&gt;
&lt;li&gt;字符串的定义：单引号、双引号、NowDoc及HereDoc。双引号包裹的字符串会被解析，单引号的不会。&lt;/li&gt;
&lt;li&gt;判断语句中被判定为false的情况：0、0.0、&#39;0&#39;、&#39;&#39;、array()、null、false&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用计数、写时复制（对象除外）&lt;/li&gt;
&lt;li&gt;unset不销毁内存空间、只是取消引用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;echo-print-print_r-var_dump-printf-sprintf&#34;&gt;echo、print、print_r、var_dump、printf、sprintf&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;echo、print属于语言结构，print_r、var_dump、printf、sprintf是普通函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;echo：输出一个或多个字符串（echo &#39;123&#39;, &#39;345&#39;, &#39;567&#39;;）&lt;/li&gt;
&lt;li&gt;print：输出字符串&lt;/li&gt;
&lt;li&gt;print_r：可输出复杂数据类型Array、Object，布尔类型true输出为1，false输出为0&lt;/li&gt;
&lt;li&gt;var_dump：可输出复杂数据类型Array、Object，布尔输出正常&lt;/li&gt;
&lt;li&gt;printf：格式化输出&lt;/li&gt;
&lt;li&gt;sprintf：格式化返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isset-is_null-empty&#34;&gt;isset、is_null、empty&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;isset：当变量为NULL、声明后未赋值或者变量未声明时，返回false&lt;/li&gt;
&lt;li&gt;is_null：当变量为NULL、声明后未赋值或者变量未声明时，返回true（当变量未声明或未赋值时，PHP输出警告）&lt;/li&gt;
&lt;li&gt;empty：当变量为空字符串、false、array()、null、&amp;quot;0&amp;quot;、0、0.0或变量未声明时，返回true&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;超全局变量&#34;&gt;超全局变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$GLOBALS: 包含以下8个&lt;/li&gt;
&lt;li&gt;$_GET: 请求的GET参数&lt;/li&gt;
&lt;li&gt;$_POST: 请求的POST参数&lt;/li&gt;
&lt;li&gt;$_FILES: 提交的文件信息&lt;/li&gt;
&lt;li&gt;$_REQUEST: 请求参数，包含GET及POST的参数&lt;/li&gt;
&lt;li&gt;$_COOKIE: 请求中携带的cookie数据&lt;/li&gt;
&lt;li&gt;$_SESSION: 服务器中的session数据&lt;/li&gt;
&lt;li&gt;$_ENV: 服务器系统的环境变量&lt;/li&gt;
&lt;li&gt;$_SERVER: 服务器脚本信息、客户端信息、请求信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;const：语言结构，可以在类中定义常量，数据更快&lt;/li&gt;
&lt;li&gt;define：函数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP中预定义的常量（魔术常量）：&lt;strong&gt;DIR&lt;/strong&gt;、&lt;strong&gt;FILE&lt;/strong&gt;、&lt;strong&gt;LINE&lt;/strong&gt;、&lt;strong&gt;NAMESPACE&lt;/strong&gt;、&lt;strong&gt;CLASS&lt;/strong&gt;、&lt;strong&gt;TRAIT&lt;/strong&gt;、&lt;strong&gt;FUNCTION&lt;/strong&gt;、&lt;strong&gt;METHOD&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;static-self-this-parent&#34;&gt;static、self、$this、parent&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;static表示当前实例化的类，不能用于访问非静态属性&lt;/li&gt;
&lt;li&gt;self表示当前语句所在的类，也不能用于访问非静态属性，&lt;/li&gt;
&lt;li&gt;$this指的是实际实例化的对象，其不能访问静态属性和常量，且不能出现于静态方法中&lt;/li&gt;
&lt;li&gt;parent指向父类，用于访问父类public的方法及静态常量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;require-include-require_once-include_once&#34;&gt;require、include、require_once、include_once&lt;/h2&gt;
&lt;p&gt;require引用文件出错时报致命错误，并终止脚本执行，include引用文件出错时报警告，但继续执行后续脚本。&lt;/p&gt;
&lt;p&gt;require_once、include_once与require、include类似，但文件只会被包含一次。因为包含前存在判断，所以性能比require、include较差。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应尽量不使用include_once、require_once&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;常见的数组处理函数&#34;&gt;常见的数组处理函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;array_count_values: 统计数组中各个value的个数&lt;/li&gt;
&lt;li&gt;array_diff: 判断一个数组与其他数组的差异，返回在第一个数组中但不在其他数组中的元素，例如array_duff([1,2,3,4], [1,2], [4])返回[2 =&amp;gt; 3]&lt;/li&gt;
&lt;li&gt;array_key_exists: 判断key是否存在&lt;/li&gt;
&lt;li&gt;in_array: 判断值是否存在于数组中&lt;/li&gt;
&lt;li&gt;array_keys: 获取数组的所有键&lt;/li&gt;
&lt;li&gt;array_values: 获取数组的所有值&lt;/li&gt;
&lt;li&gt;array_merge: 合并数组，后者覆盖前者。使用“+”则是前者覆盖后者&lt;/li&gt;
&lt;li&gt;sort: 数组排序&lt;/li&gt;
&lt;li&gt;count: 数组长度，等同于sizeof&lt;/li&gt;
&lt;li&gt;array_shift: 删除数组第一个元素，并返回&lt;/li&gt;
&lt;li&gt;array_unshift: 在数组头部加入一个元素&lt;/li&gt;
&lt;li&gt;array_pop: 删除数组末尾最后一个元素，并返回&lt;/li&gt;
&lt;li&gt;array_push: 向数组末尾添加一个元素&lt;/li&gt;
&lt;li&gt;array_reverse: 翻转数组&lt;/li&gt;
&lt;li&gt;array_rand: 从数组中取随机值&lt;/li&gt;
&lt;li&gt;array_flip: 交换数组的键值&lt;/li&gt;
&lt;li&gt;array_search: 搜索数组的值，返回第一个匹配到的元素的键&lt;/li&gt;
&lt;li&gt;array_sum: 计算数组所有值的和&lt;/li&gt;
&lt;li&gt;array_slice: 根据开始位置和长度复制数组元素，返回复制的元素（即原数组不改变）&lt;/li&gt;
&lt;li&gt;array_splice: 根据开始位置和长度剪切数组元素，并返回剪切的元素（即原数组中匹配到的元素被删除）&lt;/li&gt;
&lt;li&gt;array_map: 对数组进行遍历，并对每个元素使用提供的回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见的字符串处理函数&#34;&gt;常见的字符串处理函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;chr: ASCII码转字符&lt;/li&gt;
&lt;li&gt;ord: 字符转ASCII码&lt;/li&gt;
&lt;li&gt;count_chars: 统计字符串中的字符数&lt;/li&gt;
&lt;li&gt;str_word_count: 统计字符串中的单词数&lt;/li&gt;
&lt;li&gt;explode: 按指定字符将字符串分解为数组&lt;/li&gt;
&lt;li&gt;implode: 按指定字符将数组合并为字符串&lt;/li&gt;
&lt;li&gt;htmlentities: 转义处理字符串中的HTML实体。html_entity_decode用于反向解码&lt;/li&gt;
&lt;li&gt;htmlspecialchars: 转义处理字符串中的特殊字符，包括&amp;amp;、&amp;quot;、&#39;、&amp;lt;、&amp;gt;。htmlspecialchars_decode用于反向解码&lt;/li&gt;
&lt;li&gt;trim: 去除字符串两端的空格，ltrim、rtrim分别用于去除左边界的空格和右边界的空格&lt;/li&gt;
&lt;li&gt;str_len: 计算字符串长度&lt;/li&gt;
&lt;li&gt;strrev: 翻转字符串&lt;/li&gt;
&lt;li&gt;substr: 根据起始位置和长度获取子字符串，返回获取的子字符串&lt;/li&gt;
&lt;li&gt;preg_replace: 正则表达式替换&lt;/li&gt;
&lt;li&gt;preg_match: 正则表达式匹配&lt;/li&gt;
&lt;li&gt;strstr: 判断字符串2是否为字符串1的子字符串，如果是，返回匹配到的开始位置到父字符串末尾的字符串，如果不是，返回null&lt;/li&gt;
&lt;li&gt;strrchr: 与strstr一样，只是该函数从父字符串的末尾开始匹配&lt;/li&gt;
&lt;li&gt;strcmp: 字符串比较函数，如果字符串1&amp;gt;字符串2，返回1；如果字符串1&amp;lt;字符串2，返回-1；如果字符串1等于字符串2，返回0；如果两个字符串部分内容不一致，返回两个字符串中第一个不同的字符的差值&lt;/li&gt;
&lt;li&gt;str_replace: 搜索并替换字符串的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多台服务器session共享的解决方案&#34;&gt;多台服务器session共享的解决方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将session数据存储到MySQL数据库中&lt;/li&gt;
&lt;li&gt;将session数据存储到Redis、MemCache这些内存型数据库中&lt;/li&gt;
&lt;li&gt;使用NFS共享session文件&lt;/li&gt;
&lt;li&gt;使用cookie保存session信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;魔术方法&#34;&gt;魔术方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;__construct()&lt;/li&gt;
&lt;li&gt;__destruct()&lt;/li&gt;
&lt;li&gt;__call(): 当调用不存在的方法时&lt;/li&gt;
&lt;li&gt;__callStatic(): 当调用不存在的惊天方法时&lt;/li&gt;
&lt;li&gt;__get(): 获取不存在的属性时&lt;/li&gt;
&lt;li&gt;__set(): 写入不存在的属性时&lt;/li&gt;
&lt;li&gt;__sleep(): 当对象被序列化时&lt;/li&gt;
&lt;li&gt;__wakeup(): 反序列化时&lt;/li&gt;
&lt;li&gt;__toString(): 对象作为字符串使用时&lt;/li&gt;
&lt;li&gt;__invoke(): 当对象被作为函数调用时&lt;/li&gt;
&lt;li&gt;__isset(): 当使用isset函数探测对象的私有属性时&lt;/li&gt;
&lt;li&gt;__unset(): 当使用unset函数删除对象的私有属性时&lt;/li&gt;
&lt;li&gt;__clone(): 当对象被克隆&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;public-protected-private-final&#34;&gt;public、protected、private、final&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public可被外部访问，protected与private不可被外部访问&lt;/li&gt;
&lt;li&gt;public、protected可被子类继承，private不可被继承&lt;/li&gt;
&lt;li&gt;final描述的方法，不可被子类重写；final描述的类，不可被继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;server_addr-remote_addr-http_x_forwarded_for-http_client_ip&#34;&gt;SERVER_ADDR、REMOTE_ADDR、HTTP_X_FORWARDED_FOR、HTTP_CLIENT_IP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SERVER_ADDR获取服务器IP&lt;/li&gt;
&lt;li&gt;REMOTE_ADDR获取客户端IP，但当用户使用代理时，获取到的就是代理服务器的IP&lt;/li&gt;
&lt;li&gt;HTTP_X_FORWARDED_FOR、HTTP_CLIENT_IP可以获取到用户真实IP及使用的各个代理的IP，但该字段可能被伪造&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当后端架构中有使用到代理服务器，可以使用HTTP_X_FORWARDED_FOR、HTTP_CLIENT_IP来进行获取用户IP。如果后端服务器直接暴露给用户，只需要使用REMOTE_ADDR获取客户端IP即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;phpini配置&#34;&gt;php.ini配置&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;short_open_tag&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;是否开启缩写模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;precision&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;浮点数显示有效数字的位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable_functions&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;禁用的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable_classes&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;禁用的类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;expose_php&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;是否暴露PHP被安装在服务器上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max_execution_time&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;最大执行时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_limit&lt;/td&gt;
&lt;td&gt;128M&lt;/td&gt;
&lt;td&gt;每个脚本执行时内存限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;error_reporting&lt;/td&gt;
&lt;td&gt;E_ALL &amp;amp; ~E_DEPRECATED &amp;amp; ~E_STRICT&lt;/td&gt;
&lt;td&gt;设置错误报告级别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;display_errors&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;显示错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;log_errors&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;设置是否将错误日志记录到error_log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;error_log&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PHP错误日志文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;upload_max_filesize&lt;/td&gt;
&lt;td&gt;2M&lt;/td&gt;
&lt;td&gt;上传文件的最大限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;post_max_size&lt;/td&gt;
&lt;td&gt;8M&lt;/td&gt;
&lt;td&gt;设置POST最大数据限制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;php-fpmconf配置信息&#34;&gt;php-fpm.conf配置信息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pid&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pid文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;error_log&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;错误日志的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;log_level&lt;/td&gt;
&lt;td&gt;notice&lt;/td&gt;
&lt;td&gt;错误级别（alert: 必须立即处理；error: 错误信息；warning: 警告信息；notice: 一般重要信息；debug: 调试信息）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;daemonize&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;设置FPM后台运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;listen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FPM监听的地址及端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;request_slowlog_timeout&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;慢日志记录阈值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;slowlog&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;慢日志记录文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;进程通讯方式&#34;&gt;进程通讯方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;发起http请求的方式&#34;&gt;发起HTTP请求的方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;curl: curl_init -&amp;gt; curl_setopt -&amp;gt; curl_exec -&amp;gt; curl_close&lt;/li&gt;
&lt;li&gt;file_get_contents: http_build_query -&amp;gt; stream_context_create -&amp;gt; file_get_content(url, false, context)&lt;/li&gt;
&lt;li&gt;fopen: fopen -&amp;gt; fgets -&amp;gt; fclose&lt;/li&gt;
&lt;li&gt;fsockopen: fsocketopen -&amp;gt; fputs -&amp;gt; fgets -&amp;gt; fclose&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生成器yield的基本原理&#34;&gt;生成器yield的基本原理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个生成器被调用的时候，它返回一个可以被遍历的对象。&lt;br&gt;
当你遍历这个对象的时候 (例如通过一个 foreach 循环)，PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态，这样它就可以在需要产生下一个值的时候恢复调用状态。&lt;/p&gt;
&lt;p&gt;一旦不再需要产生更多的值，生成器函数可以简单退出，而调用生成器的代码还可以继续执行，就像一个数组已经被遍历完了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，yield还可以接受值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function printer()
{
    while (true) {
        printf(&amp;quot;receive: %s\n&amp;quot;, yield);
    }
}

$printer = printer();

$printer-&amp;gt;send(&#39;hello&#39;);
$printer-&amp;gt;send(&#39;world&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PHP的生成器还实现了一个send方法，该方法向yield处传递一个值，同时从 yied 语句处继续执行，直至再次遇到 yield 后控制权回到外部。&lt;/p&gt;
&lt;p&gt;Generator生成器提供的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current: 获取生成器当前的值&lt;/li&gt;
&lt;li&gt;getReturn: 获取生成器返回的值&lt;/li&gt;
&lt;li&gt;key: 获取生成器当前的key&lt;/li&gt;
&lt;li&gt;next: 继续执行生成器&lt;/li&gt;
&lt;li&gt;rewind: 重置生成器&lt;/li&gt;
&lt;li&gt;send: 发送值给生成器&lt;/li&gt;
&lt;li&gt;valid: 验证生成器是否关闭&lt;/li&gt;
&lt;li&gt;throw: 抛出一个生成器异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;防止内存泄露的解决方法&#34;&gt;防止内存泄露的解决方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;过大的数据分段读取&lt;/li&gt;
&lt;li&gt;尽可能减少静态变量的使用，可以考虑使用引用代替&lt;/li&gt;
&lt;li&gt;数据库、文件操作完后，及时释放连接&lt;/li&gt;
&lt;li&gt;对象、变量使用完后，及时unset释放&lt;/li&gt;
&lt;li&gt;unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间&lt;/li&gt;
&lt;li&gt;当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;模板引擎的原理&#34;&gt;模板引擎的原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过视图名找到相应的视图文件&lt;/li&gt;
&lt;li&gt;通过正则表达式或其它方式将模板引擎的定界符及其他符号修改为PHP的定界符和符号&lt;/li&gt;
&lt;li&gt;将转化好的文件内容存为缓存文件，并以视图文件的上一次修改时间作为缓存文件的命名依据，保证视图文件更新后，缓存文件也进行更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反射类&#34;&gt;反射类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ReflectionClass&lt;/li&gt;
&lt;li&gt;ReflectionFunction&lt;/li&gt;
&lt;li&gt;ReflectionMethod&lt;/li&gt;
&lt;li&gt;ReflectionObject&lt;/li&gt;
&lt;li&gt;ReflectionGenerator&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;\d: 数字&lt;/li&gt;
&lt;li&gt;\D: 非数字&lt;/li&gt;
&lt;li&gt;\w: 字母、数字、下划线&lt;/li&gt;
&lt;li&gt;\W: 非字母、数字、下划线&lt;/li&gt;
&lt;li&gt;\s: 空白符，空格、制表、换行&lt;/li&gt;
&lt;li&gt;\S: 非空白符&lt;/li&gt;
&lt;li&gt;.: 除换行外的任意字符&lt;/li&gt;
&lt;li&gt;*: 0~n个&lt;/li&gt;
&lt;li&gt;?: 0或1个&lt;/li&gt;
&lt;li&gt;+: 1~n个&lt;/li&gt;
&lt;li&gt;{n}: n个&lt;/li&gt;
&lt;li&gt;{n,}: 大于等于n个&lt;/li&gt;
&lt;li&gt;{n,m}: n~m个&lt;/li&gt;
&lt;li&gt;^: 开始&lt;/li&gt;
&lt;li&gt;$: 结束&lt;/li&gt;
&lt;li&gt;[]: 匹配中括号中任意一个&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;(): 整体或后文引用&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;修正符:&lt;br&gt;
i: 区分大小写&lt;br&gt;
S: .包括换行&lt;br&gt;
m: 每一行分别进行匹配&lt;br&gt;
U: 取消贪婪模式，另一种方法就是在量词后面加问号，如*?&lt;br&gt;
u: utf8中文匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cgi-fastcgi-php-fpm&#34;&gt;CGI、FastCGI、PHP-FPM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CGI: 通用网关接口，是Web服务器与服务端语言交互的标准接口。在一个请求到来时，服务器创建一个CGI进程用来执行程序，等待程序执行完成，该CGI进程被杀死。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FastCGI: 是用于提升CGI性能的标准，FastCGI要求CGI进程在处理完请求后不被立刻杀死，而是保留下来，等待处理下一次请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PHP-FPM: FastCGI Processor Manager，实现FastCGI的管理器，使用FastCGI标准管理CGI程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;php操作mysql数据库&#34;&gt;PHP操作MySQL数据库&lt;/h2&gt;
&lt;h3 id=&#34;mysqli面向过程&#34;&gt;mysqli面向过程&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 使用prepare（推荐）
$conn = mysqli_connect(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;&#39;, &#39;test&#39;);
mysqli_set_charset($conn, &#39;utf8&#39;);
$stmt = mysqli_prepare($conn, &#39;SELECT `name`, `phone` FROM `aihailin` LIMIT ?&#39;);
mysqli_stmt_bind_param($stmt, &#39;i&#39;, $limit);
$limit = 2;
mysqli_execute($stmt);
$result = mysqli_stmt_get_result($stmt);
foreach ($result as $row) {
  var_dump($row);
}
// 或不使用prepare
$conn = mysqli_connect(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;&#39;, &#39;test&#39;);
mysqli_set_charset($conn, &#39;utf8&#39;);
$res = mysqli_query($conn, &#39;SELECT * FROM `aihailin` LIMIT 2&#39;);
foreach ($res as $row) {
  var_dump($row);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysqli面向对象&#34;&gt;mysqli面向对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$mysqli = new mysqli(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;&#39;, &#39;test&#39;);
$mysqli-&amp;gt;set_charset(&#39;utf8&#39;);
$stmt = $mysqli-&amp;gt;prepare(&#39;SELECT `name`, `phone` FROM `aihailin` LIMIT ?&#39;);
$stmt-&amp;gt;bind_param(&#39;i&#39;, $limit);
$limit = 2;
$stmt-&amp;gt;execute();
$result = $stmt-&amp;gt;get_result();
foreach ($result as $row) {
  var_dump($row);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pdo&#34;&gt;PDO&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$dsn = &#39;mysql:host=127.0.0.1;dbname=test;charset=utf8&#39;;
$pdo = new PDO($dsn, &#39;root&#39;, &#39;&#39;);
$stmt = $pdo-&amp;gt;prepare(&#39;SELECT * FROM `aihailin` LIMIT :limit&#39;);
$stmt-&amp;gt;bindParam(&#39;:limit&#39;, $limit);
$limit = 5;
if ($stmt-&amp;gt;execute()) {
    $result = $stmt-&amp;gt;fetchAll(PDO::FETCH_ASSOC);
    var_dump($result);
}
&lt;/code&gt;&lt;/pre&gt;
">面试问题之PHP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/Vyg8SHrxV/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;seo&#34;&gt;SEO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;语义化的HTML代码，符合W3C规范&lt;/li&gt;
&lt;li&gt;重要内容放在最前&lt;/li&gt;
&lt;li&gt;重要内容不用js输出&lt;/li&gt;
&lt;li&gt;少使用iframe&lt;/li&gt;
&lt;li&gt;非装饰图片加alt&lt;/li&gt;
&lt;li&gt;添加网站地图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;javascript代码放在html末尾&#34;&gt;JavaScript代码放在HTML末尾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优先加载HTML及CSS，减少用户使用时的加载时长&lt;/li&gt;
&lt;li&gt;在JavaScript执行之前，保证HTML全部加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跨域方式&#34;&gt;跨域方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用jsonp进行跨域（只能GET请求），创建回调函数，在服务器返回的数据中调用该函数，并将数据放在函数的参数中&lt;/li&gt;
&lt;li&gt;document.domain + iframe，设置两个页面的基础域名相同（子域不同）&lt;/li&gt;
&lt;li&gt;CORS，服务器返回设置Access-Contorl-Allow-Origin: *&lt;/li&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;/ul&gt;
">面试问题之Web</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/Xg5xYirjI/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;left-join-inner-join-right-join-full-join&#34;&gt;left join、inner join、right join、full join&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;left join: 用左边所有的数据在右边中查找匹配的值，如果没有匹配的，用null代替&lt;/li&gt;
&lt;li&gt;right join: 与left join类似&lt;/li&gt;
&lt;li&gt;inner join: 左右两边匹配到的行&lt;/li&gt;
&lt;li&gt;full join: 左边、右边的所有数据，未匹配到的用null代替&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;union-union-all&#34;&gt;union、union all&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;union: 连接两个结果集，并去重&lt;/li&gt;
&lt;li&gt;union all: 不去重&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql常用函数&#34;&gt;MySQL常用函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;floor向下取整、ceil向上取整、round四舍五入、rand随机数、abs绝对值&lt;/li&gt;
&lt;li&gt;concat连接字符串、length字符串长度&lt;/li&gt;
&lt;li&gt;now当前时间、curdate当前日期、unix_timestamp转时间戳、from_unixtime时间戳转格式化日期&lt;/li&gt;
&lt;li&gt;password、md5加密&lt;/li&gt;
&lt;li&gt;format数字格式化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;读锁（共享锁）：同一时刻可以同时读取同一个资源，阻塞写&lt;/li&gt;
&lt;li&gt;写锁（排他锁）：阻塞其他写和读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共享锁和排他锁都属于悲观锁（悲观锁认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作），乐观锁则认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# 1.查询出商品信息

select (status,version) from t_goods where id=#{id}

# 2.根据商品信息生成订单

# 3.修改商品status为2

update t_goods 

set status=2,version=version+1

where id=#{id} and version=#{version};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;悲观锁由数据库内部实现&lt;br&gt;
乐观锁则是在外部需要手动实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;表锁：开销小，锁定整张表&lt;/li&gt;
&lt;li&gt;行级锁：开销大，锁定一行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事务隔离级别&#34;&gt;事务隔离级别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;未提交读：事务中未提交的修改，对其他事务可见&lt;/li&gt;
&lt;li&gt;提交读：事务中未提交修改仅自己可见，但两次查询可能得到不同结果（解决脏读：一个线程中的事务读取到了另外一个线程中未提交的数据）&lt;/li&gt;
&lt;li&gt;可重复读：MySQL默认，同一事务多次读取结果一致（解决不可重复读：一个线程中的事务读取到了另外一个线程中提交的update的数据）&lt;/li&gt;
&lt;li&gt;可串行化：强制事务串行执行（解决幻读：一个线程中的事务读取到了另外一个线程中提交的insert的数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;innodb-myisam&#34;&gt;InnoDB、MyISAM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB: MySQL默认存储引擎，支持事务、行级锁、外键，支持崩溃后安全恢复，性能优秀&lt;/li&gt;
&lt;li&gt;MyISAM: 支持全文索引、表锁，不支持事务、外键、崩溃后安全恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他存储引擎：Blackhole、Memory&lt;/p&gt;
&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;
&lt;p&gt;通过二叉查找树等数据结构来提升无序数据表的查询效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优势：提升数据的扫描量、避免创建临时表、提升查询速度&lt;br&gt;
劣势：增删改需要额外维护索引，写入速度降低，索引会导致占用更多磁盘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;普通索引&lt;/li&gt;
&lt;li&gt;唯一索引&lt;/li&gt;
&lt;li&gt;主键索引&lt;/li&gt;
&lt;li&gt;外建索引&lt;/li&gt;
&lt;li&gt;组合索引：应遵循最左前缀原则&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按物理存储分类：聚簇索引、非聚簇索引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚簇索引：叶节点就是数据节点&lt;/li&gt;
&lt;li&gt;非聚簇索引：叶节点仍是索引节点，存在指向数据块的指针&lt;/li&gt;
&lt;/ul&gt;
">面试问题之MySQL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/a4NkY63cQ/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;redis特点&#34;&gt;Redis特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持数据持久化&lt;/li&gt;
&lt;li&gt;支持key-value类型数据及其他数据类型&lt;/li&gt;
&lt;li&gt;支持主从结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;String字符串&lt;/li&gt;
&lt;li&gt;List链表&lt;/li&gt;
&lt;li&gt;Hash哈希表&lt;/li&gt;
&lt;li&gt;Set集合&lt;/li&gt;
&lt;li&gt;ZSet有序集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis与memcache&#34;&gt;Redis与MemCache&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis支持丰富的数据类型，MemCache支持k-v数据&lt;/li&gt;
&lt;li&gt;Redis支持数据持久化，MemCache不支持&lt;/li&gt;
&lt;li&gt;Redis支持事务，MemCache用cas维持数据一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis事务&#34;&gt;Redis事务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MULTI: 后续的命令进入事务队列&lt;/li&gt;
&lt;li&gt;DISCARD: 取消一个事务，清空事务队列&lt;/li&gt;
&lt;li&gt;EXEC: 执行事务&lt;/li&gt;
&lt;li&gt;WATCH: 用于在事务开始之前监视任意数量的键：当调用 EXEC 命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;持久化策略&#34;&gt;持久化策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RDB快照持久化：将所有数据写入硬盘，BGSAVE&lt;/li&gt;
&lt;li&gt;AOF持久化：以追加形式写入，将写过的命令保存到磁盘&lt;/li&gt;
&lt;/ul&gt;
">面试问题之Redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/hKStxyoPW/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;目录结构&#34;&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;/
├── bin #存放二进制可执行文件，常用命令一般都在这里
├── boot #存放用于系统引导时使用的各种文件
├── dev #用于存放设备文件
├── etc #存放系统管理和配置文件
├── home #存放所有用户文件的根目录
├── lib #存放着和系统运行相关的库文件
├── media #linux 系统会自动识别一些设备，当识别后，linux 会把识别的设备挂载到这个目录下
├── mnt #用户临时挂载其他的文件系统
├── opt #额外安装的可选应用程序包所放置的位置
├── proc #虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息
├── root #超级用户的主目录
├── run #是一个临时文件系统，存储系统启动以来的信息
├── sbin #存放二进制可执行文件，只有 root 才能访问
├── srv #该目录存放一些服务启动之后需要提取的数据
├── sys #存放内核相关文件
├── tmp #用于存放各种临时文件，是公用的临时文件存储点
├── usr #用于存放系统应用程序
└── var #用于存放运行时需要改变数据的文件，比如服务的日志文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;linux命令&#34;&gt;Linux命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;uname -a: 系统信息&lt;/li&gt;
&lt;li&gt;cat /proc/cpuinfo: CPU信息&lt;/li&gt;
&lt;li&gt;env: 环境变量&lt;/li&gt;
&lt;li&gt;free: 查看内存使用量&lt;/li&gt;
&lt;li&gt;df -h: 查看分区使用情况&lt;/li&gt;
&lt;li&gt;du &lt;dir&gt;: 查看具体目录使用情况&lt;/li&gt;
&lt;li&gt;uptime: 查看系统运行时间、用户数、负载&lt;/li&gt;
&lt;li&gt;ifconfig: 查看网络接口的属性&lt;/li&gt;
&lt;li&gt;iptables: 查看防火墙设置&lt;/li&gt;
&lt;li&gt;netstat -lntp: 查看所有监听的端口&lt;/li&gt;
&lt;li&gt;netstat -antp: 查看所有已建立的连接&lt;/li&gt;
&lt;li&gt;ps -ef、ps aux: 查看所有进程&lt;/li&gt;
&lt;li&gt;top: 实时查看进程状况&lt;/li&gt;
&lt;li&gt;w: 查看活动用户&lt;/li&gt;
&lt;li&gt;last: 查看用户登录日志&lt;/li&gt;
&lt;li&gt;crontab: 设置定时任务&lt;/li&gt;
&lt;li&gt;tail -f: 实时查看文件尾部的内容&lt;/li&gt;
&lt;li&gt;awk、cut: 文本处理（&lt;a href=&#34;https://blog.alan123.xyz/linux/953.html&#34;&gt;awk、cut命令&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;which: 查找命令的位置&lt;/li&gt;
&lt;li&gt;find &amp;lt;obj_dir&amp;gt; -name &amp;lt;file_name&amp;gt;: 查找目标目录下的文件&lt;/li&gt;
&lt;li&gt;locate: 查找文件，但从其自己的数据中查找，速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标准数据流&#34;&gt;标准数据流&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;STDIN: 标准输入，0&lt;/li&gt;
&lt;li&gt;STDOUT: 标准输出，1&lt;/li&gt;
&lt;li&gt;STDERR: 标准错误输出，2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vim&#34;&gt;vim&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;向上翻半页: ctrl+u&lt;/li&gt;
&lt;li&gt;向下翻半页: ctrl+d&lt;/li&gt;
&lt;li&gt;光标上移: k&lt;/li&gt;
&lt;li&gt;光标下移: j&lt;/li&gt;
&lt;li&gt;光标左移: h&lt;/li&gt;
&lt;li&gt;光标右移: l&lt;/li&gt;
&lt;li&gt;跳到第一行: gg&lt;/li&gt;
&lt;li&gt;跳到最后一行: G&lt;/li&gt;
&lt;li&gt;调到指定行: :n&lt;/li&gt;
&lt;li&gt;查找: /word&lt;/li&gt;
&lt;li&gt;查找下一个: n&lt;/li&gt;
&lt;li&gt;查找上一个: N&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程-线程-协程&#34;&gt;进程、线程、协程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程: 是一个正在执行的程序，它是系统资源分配的最小单位&lt;/li&gt;
&lt;li&gt;线程: 相对进程更小，一个进程可能包含多个线程，同一个进程中的线程资源共享，线程是CPU调度的最小单位&lt;/li&gt;
&lt;li&gt;协程: 比线程还小，协程的调度由程序员操控，没有进程和线程中的上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;套接字&lt;/li&gt;
&lt;/ul&gt;
">面试问题之Linux</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/7i2vSqeys/"" data-c="
          &lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sql注入&#34;&gt;SQL注入&lt;/h2&gt;
&lt;p&gt;用户在提交的表单中注入SQL命令，恶意篡改原SQL语句的语义，以达到破坏或入侵系统的目的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;防范: ① 使用预编译SQL语句绑定变量的方式；② 检查用户输入；③ 对数据库用户设置权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;xss攻击&#34;&gt;XSS攻击&lt;/h2&gt;
&lt;p&gt;在表单中提交恶意脚本代码，当用户在加载网页时，恶意脚本会被执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;防范: 对用户输入进行验证，对特殊字符进行转义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;csrf&#34;&gt;CSRF&lt;/h2&gt;
&lt;p&gt;利用浏览器保存的登录态，诱导用户执行非本意操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;防范: ① 使用token令牌进行验证；② 增加验证码；③ 检查请求来源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;php安全&#34;&gt;PHP安全&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文件包含漏洞：include、require、include_once、require_once，使用这4个函数包含文件，该文件将作为 PHP 代码执行，PHP 内核不会在意该包含的文件是什么类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码执行漏洞：危险函数exec、shell_exec、system可以直接执行系统命令。eval函数可以执行 PHP 代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">面试问题之安全</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/2DEhssgZW/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;awk命令&#34;&gt;awk命令&lt;/h2&gt;
&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;
&lt;p&gt;可以选用的参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-F &#39;,&#39;: 指定列分割符&lt;br&gt;
-v var=value: 赋值一个用户定义变量，将外部变量传递给awk&lt;br&gt;
-f scriptfile: 从脚本文件中读取awk命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模式&#34;&gt;模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;/正则表达式/：使用通配符的扩展集&lt;/li&gt;
&lt;li&gt;关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试&lt;/li&gt;
&lt;li&gt;模式匹配表达式：用运算符&lt;sub&gt;和&lt;/sub&gt;!分别表示匹配、不匹配&lt;/li&gt;
&lt;li&gt;BEGIN语句块、pattern语句块、END语句块&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用的基本结构&#34;&gt;使用的基本结构&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;awk &#39;BEGIN{ print &amp;quot;start&amp;quot;} pattern { commands } END{ print &amp;quot;end&amp;quot; }&#39; file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk脚本由：&lt;strong&gt;BEGIN语句块、能够使用模式匹配的通用语句块、END语句块&lt;/strong&gt;组成，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;awk &#39;BEGIN{ i=0 } { i++ } END{ print i }&#39; filename
awk &#39;/^2/ {print $0}&#39; filename // 输出以2开头的行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;awk的工作原理&#34;&gt;awk的工作原理&lt;/h3&gt;
&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;执行 &lt;code&gt;BEGIN {commands}&lt;/code&gt;语句块中的语句；&lt;/li&gt;
&lt;li&gt;从文件或标准输入（stdin）读取一行，然后执行 &lt;code&gt;pattern {commands}&lt;/code&gt; 语句，逐行扫描文件，直至文件结尾；&lt;/li&gt;
&lt;li&gt;当读到文件结尾处时，执行 &lt;code&gt;END {commands}&lt;/code&gt; 语句块；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font style=&#34;color:red;&#34;&gt;&lt;em&gt;注意：在awk的print语句中，双引号被当做拼接符使用&lt;/em&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;awk的内置变量&#34;&gt;awk的内置变量&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;$n: 表示当前记录的第n个字段（列）&lt;br&gt;
$0: 该变量包含执行过程中当前行的文本内容&lt;br&gt;
FILENAME: 当前输入文件名&lt;br&gt;
FS: 字段分隔符&lt;br&gt;
NF: 每行的字段数（列数）&lt;br&gt;
NR: 记录数，即当前的行号&lt;br&gt;
OFMT: 数字的输出格式&lt;br&gt;
OFS: 输出字段分隔符&lt;br&gt;
ORS: 输出记录（行）分隔符，默认为换行&lt;br&gt;
RS: 记录（行）分隔符，默认为换行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;awk &#39;{print $NF}&#39; filename
// 输出每一行最后一列的值
awk &#39;{if($2==&amp;quot;abc&amp;quot;) s+=1;} END {print s}&#39; a.txt
// 计算第2列为abc的行数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cut命令&#34;&gt;cut命令&lt;/h2&gt;
&lt;h3 id=&#34;参数-2&#34;&gt;参数&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;-d &#39;,&#39;: 指定列分隔符为逗号&lt;br&gt;
-f 9: 获取第9列的数据&lt;br&gt;
-c 1-3: 获取每行的第1至第三个字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cut -d &#39;,&#39; -f 8 filename
// 输出第8列的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cut一般与grep配合使用，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cut -d &#39;,&#39; -f 6 a.txt | grep -c &#39;abc&#39;
// 计算第6列为abc的行数
&lt;/code&gt;&lt;/pre&gt;
">awk、cut命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/J-kvhZen-/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;0-进程&#34;&gt;0、进程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;僵尸进程：**当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。**如果父进程一直不处理,该进程将会一直存在,占用系统进程表项。&lt;/li&gt;
&lt;li&gt;孤儿进程：**在其父进程执行完成或被终止后仍继续运行的一类进程。**这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程没有任何危害,只是需要注意自己的代码逻辑即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-进程-进程组-会话-控制终端的关系&#34;&gt;1、进程、进程组、会话、控制终端的关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程：进程属于且仅属于一个进程组；&lt;/li&gt;
&lt;li&gt;进程组：进程组包含多个进程，进程组号就是进程组长的进程号；&lt;/li&gt;
&lt;li&gt;会话：会话包含多个进程组，这些进程组可以分为：后台进程组、前台进程组&lt;/li&gt;
&lt;li&gt;控制终端：控制终端对应一个或多个登录会话（screen命令可以创建会话）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系如图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;media/15533478923246/5c963c3a9036d.jpg&#34; alt=&#34;进程、进程组、会话、控制终端&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-守护进程的创建过程&#34;&gt;2、守护进程的创建过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;media/15533478923246/5c95a53bc04d5.png&#34; alt=&#34;守护进程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;① fork出的子进程会在继承父进程的状态，并往下执行，且子进程属于父进程所在的进程组和会话。&lt;font style=&#34;color:red;&#34;&gt;&lt;strong&gt;使用posix_setsid函数的作用就是创建一个新的会话，让子进程摆脱父进程所在的进程组和会话的控制&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;② &lt;font style=&#34;color:red;&#34;&gt;命令行使用&amp;amp;符号在后台运行程序，只是将该程序放到后台进程组，并没有脱离当前进程组和会话的控制&lt;/font&gt;，因此，当用户退出登录时，程序就会结束&lt;/p&gt;
&lt;p&gt;③ POSIX：portable operating system interface of UNIX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$pid = pcntl_fork();
if ($pid == -1) {
    die(&amp;quot;Fork Error&amp;quot;);
} elseif ($pid) {
    // 父进程
    exit();
} else {
    // 子进程
    posix_setsid();
    chdir(&#39;/&#39;);
    umask(0);
    for ($i = 0; $i &amp;lt; 20; $i++) {
        echo $i, PHP_EOL;
        sleep(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-结语&#34;&gt;3、结语&lt;/h2&gt;
&lt;p&gt;可以将上述代码优化封装成一个Daemon守护进程类，添加&lt;strong&gt;实现信号量处理（启动、暂停、结束等）、添加执行任务、保存进程id到pid文件等功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Daemon
{
    private $pid_file;
    private $log_file;
    private $jobs = [];

    public function __construct($log_dir = &#39;/tmp/&#39;, $pid_dir = &#39;/var/run/&#39;)
    {
        $this-&amp;gt;checkCli();
        $this-&amp;gt;checkPcntl();
        $this-&amp;gt;setLogFile(rtrim($log_dir, &#39;/&#39;) . &#39;/&#39; . __CLASS__ . &#39;.log&#39;);
        $this-&amp;gt;setPidFile(rtrim($pid_dir, &#39;/&#39;) . &#39;/&#39; . __CLASS__ . &#39;.pid&#39;);
    }

    /**
     * 设置日志文件
     * @param string $log_file 日志文件路径
     */
    private function setLogFile($log_file)
    {
        $this-&amp;gt;log_file = $log_file;
    }

    /**
     * 设置pid文件
     * @param string $pid_file pid文件路径
     */
    private function setPidFile($pid_file)
    {
        $this-&amp;gt;pid_file = $pid_file;
    }

    /**
     * 检验是否安装pcntl扩展
     * @return void 
     */
    private function checkPcntl()
    {
        if (!function_exists(&#39;pcntl_fork&#39;)) {
            throw new Exception(&amp;quot;Extension pcntl not exists&amp;quot;);
        }
    }

    /**
     * 检查运行环境是否是命令行
     * @return void 
     */
    private function checkCli()
    {
        if (php_sapi_name() != &#39;cli&#39;) {
            throw new Exception(&amp;quot;Current running environment is not cli&amp;quot;);
        }
    }

    /**
     * 添加任务
     * @param array $job 任务数组
     */
    public function addJob($job)
    {
        if (!isset($job[&#39;callback&#39;]) || empty($job[&#39;callback&#39;])) {
            throw new Exception(&amp;quot;Job need callback&amp;quot;);
        }
        array_push($this-&amp;gt;jobs, $job);
    }
    
    /**
     * 创建守护进程
     *
     * @return void
     */
    private function daemonize()
    {
        $pid = pcntl_fork();
        if ($pid &amp;lt; 0) {
            throw new Exception(&#39;Fork son process error&#39;);
        } elseif ($pid &amp;gt; 0) {
            exit();
        }
        
        if (posix_setsid() == -1) {
            throw new Exception(&#39;Cannot detach session&#39;);
        }
        chdir(&#39;/&#39;);
        umask(0);
        if (!$fp = fopen($this-&amp;gt;pid_file, &#39;w&#39;)) {
            throw new Exception(&#39;Cannot create pid file&#39;);
        }
        fwrite($fp, posix_getpid());
        if (!empty($this-&amp;gt;jobs)) {
            foreach ($this-&amp;gt;jobs as $job) {
                if (isset($job[&#39;argv&#39;])) {
                    call_user_func($job[&#39;callback&#39;], $job[&#39;argv&#39;]);
                } else {
                    call_user_func($job[&#39;callback&#39;]);
                }
            }
        }
    }
    
    /**
     * 启动守护进程
     *
     * @return void
     */
    private function start()
    {
        if ($this-&amp;gt;getPid()) {
            $this-&amp;gt;tips(&#39;Process is running...&#39;);
            return;
        }
        $this-&amp;gt;tips(&#39;Start success.&#39;);
        $this-&amp;gt;daemonize();
    }

    /**
     * 停止进程
     *
     * @return void
     */
    private function stop()
    {
        if ($pid = $this-&amp;gt;getPid()) {
            posix_kill($pid, SIGTERM);
            unlink($this-&amp;gt;pid_file);
            $this-&amp;gt;tips(&#39;Stop success.&#39;);
        } else {
            $this-&amp;gt;tips(&#39;Process not running.&#39;);
        }
    }

    /**
     * 获取状态
     *
     * @return void
     */
    private function status()
    {
        if ($this-&amp;gt;getPid()) {
            $this-&amp;gt;tips(&#39;Process is running...&#39;);
        } else {
            $this-&amp;gt;tips(&#39;Process is stopped.&#39;);
        }
    }

    /**
     * 输出提示信息
     *
     * @param string $msg 提示内容
     * @return void
     */
    private function tips($msg)
    {
        printf(&amp;quot;%s: %s\n&amp;quot;, date(&#39;Y-m-d H:i:s&#39;), $msg);
    }

    /**
     * 获取守护进程pid
     *
     * @return void
     */
    private function getPid()
    {
        if (!file_exists($this-&amp;gt;pid_file)) {
            return 0;
        }
        $pid = intval(file_get_contents($this-&amp;gt;pid_file));
        if (posix_kill($pid, SIG_DFL)) {
            return $pid;
        } else {
            unlink($this-&amp;gt;pid_file);
            return 0;
        }
    }

    /**
     * 运行
     *
     * @return void
     */
    public function run($argv)
    {
        if (count($argv) &amp;lt; 2) {
            $this-&amp;gt;tips(&#39;Params: stop | start | status&#39;);
            return;
        }
        switch ($argv[1]) {
            case &#39;start&#39;:
                $this-&amp;gt;start();
                break;
            case &#39;stop&#39;:
                $this-&amp;gt;stop();
                break;
            case &#39;status&#39;:
                $this-&amp;gt;status();
                break;
            default:
                $this-&amp;gt;tips(&#39;Params: stop | start | status&#39;);
                break;
        }
    }
}


// 测试
$daemon = new Daemon(&#39;/Users/Alan_Albert/Desktop/Daemon&#39;, &#39;/Users/Alan_Albert/Desktop/Daemon&#39;);
$daemon-&amp;gt;addJob([
    &#39;callback&#39; =&amp;gt; function () {
        while (1) {
            echo &amp;quot;true&amp;quot;, PHP_EOL;
            sleep(1);
        }
    }
]);
$params = $argv;
$daemon-&amp;gt;run($argv);
&lt;/code&gt;&lt;/pre&gt;
">Daemon守护进程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/hjW63kIwP/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;一-安装lumen框架&#34;&gt;一、安装Lumen框架&lt;/h2&gt;
&lt;p&gt;使用composer命令基于Lumen框架创建项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;composer create-project laravel/lumen:&amp;quot;5.6.*&amp;quot; Lumen-Project --prefer-dist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在.env文件中配置32位的APP_KEY以及数据库的相关配置。&lt;/p&gt;
&lt;h2 id=&#34;二-安装dingoapihttpsgithubcomdingoapi&#34;&gt;二、安装dingo/api(https://github.com/dingo/api)&lt;/h2&gt;
&lt;p&gt;① 使用composer命令安装dingo/api：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;composer require dingo/api:&amp;quot;2.0.0-alpha2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 配置dingo/api：&lt;/p&gt;
&lt;p&gt;在.env文件中配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# dingo api
API_NAME=Lumen
API_STANDARDS_TREE=x
API_PREFIX=api
API_STRICT=false
API_DEBUG=true
API_VERSION=v1
API_SUBTYPE=lumen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 注册dingo/api服务到Lumen：&lt;/p&gt;
&lt;p&gt;在App\Providers\AppServiceProvider类的register方法中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$this-&amp;gt;app-&amp;gt;register(\Dingo\Api\Provider\LumenServiceProvider);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④ 创建dingo/api的配置文件config/api.php&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lumen框架不自带config目录，需要自行在项目根目录下创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;api.php可以在vendor/dingo/api/config目录下找到，同理，Lumen框架的配置文件也可在Lumen框架源码中找到。&lt;/p&gt;
&lt;p&gt;⑤ 完成以上步骤，可以在routes/web.php中添加以下代码测试是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$api = $app[&#39;Dingo\Api\Routing\Router&#39;];
$api-&amp;gt;version(&#39;v1&#39;, function ($api) {
    $api-&amp;gt;get(&#39;/&#39;, function () {
        return [
            &#39;status&#39; =&amp;gt; &#39;200&#39;,
            &#39;msg&#39; =&amp;gt; &#39;成功&#39;,
            &#39;data&#39; =&amp;gt; [
                &#39;name&#39; =&amp;gt; &#39;Alan&#39;,
                &#39;age&#39; =&amp;gt; 18
            ],
        ];
    });
})；
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-安装tymonjwt-auth&#34;&gt;三、安装tymon/jwt-auth&lt;/h2&gt;
&lt;p&gt;① 使用composer安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;composer require tymon/jwt-auth:&amp;quot;1.0.0-rc.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：jwt-auth稳定版为0.5，其对lumen高版本不太兼容，所以采用jwt-auth 1.0版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② 修改bootstrap/app.php文件：&lt;/p&gt;
&lt;p&gt;去除以下行的注释：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$app-&amp;gt;withFacades();
$app-&amp;gt;withEloqent();

$app-&amp;gt;routeMiddleware([
    &#39;auth&#39; =&amp;gt; App\Http\Middleware\Authenticate::class,
]);

$app-&amp;gt;register(App\Providers\AppServiceProvider::class);
$app-&amp;gt;register(App\Providers\AuthServiceProvider::class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 修改app/Providers/AppServiceProvider.php文件：&lt;/p&gt;
&lt;p&gt;在AppServiceProvider类中的register方法里添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$this-&amp;gt;app
-&amp;gt;register(\Tymon\JWTAuth\Providers\LumenServiceProvider::class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④ 将Lumen框架的配置文件auth.php复制到config/auth.php，并修改内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

return [
    &#39;defaults&#39; =&amp;gt; [
        &#39;guard&#39; =&amp;gt; env(&#39;AUTH_GUARD&#39;, &#39;api&#39;),
        &#39;passwords&#39; =&amp;gt; &#39;users&#39;,
    ],
    
    &#39;guards&#39; =&amp;gt; [
        &#39;api&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;jwt&#39;,
            &#39;provider&#39; =&amp;gt; &#39;users&#39;
        ],
    ],

    &#39;providers&#39; =&amp;gt; [
        &#39;users&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;eloquent&#39;,
            &#39;model&#39;  =&amp;gt; App\User::class,
        ],
    ],

    &#39;passwords&#39; =&amp;gt; [
        //
    ],
];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑤ 修改配置文件，将dingo/api和tymon/jwt-auth关联：&lt;/p&gt;
&lt;p&gt;修改dingo/api的配置文件config/api.php:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&#39;auth&#39; =&amp;gt; [
    &#39;jwt&#39; =&amp;gt; &#39;Dingo\Api\Auth\Provider\JWT&#39;,
],
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成以上步骤就完成了在Lumen框架下dingo/api和tymon/jwt-auth的安装。&lt;/p&gt;
&lt;p&gt;⑥ 生成jwt的secret：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan jwt:secret
&lt;/code&gt;&lt;/pre&gt;
">Lumen框架下安装dingo/api和tymon/jwt-auth</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/_w0MPiApJ/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;视图的基本用法&#34;&gt;视图的基本用法&lt;/h2&gt;
&lt;p&gt;Laravel中，可以通过两种方式返回视图，一种是直接以字符串形式返回视图源码，另一种是返回视图文件。&lt;/p&gt;
&lt;p&gt;① 第一种方法就是直接使用return返回字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function index()
{
    return &#39;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 第二种是通过view()返回视图文件，视图存放在laravel/resources/views目录下。view函数是定义的全局函数相当于View::make()方法，实质调用的是Illuminate\View\Factory的make方法，进而创建Illuminate\View\View类的实例化对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function index()
{
    return view(&#39;index&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上用例会加载laravel/resources/views/index.blade.php文件，如果视图文件存在laravel/resources/views下的子目录下，例如：视图文件为laravel/resources/views/user/login.blade.php，则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function index()
{
    return view(&#39;user.login&#39;);
    // 或
    // return view(&#39;user/login&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据传递&#34;&gt;数据传递&lt;/h2&gt;
&lt;p&gt;如果需要传递数据到视图中，有三种方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 通过数组的形式，如：&lt;code&gt;return view(&#39;index&#39;, [&#39;username&#39; =&amp;gt; &#39;Alan&#39;, &#39;age&#39; =&amp;gt; 18]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;② 通过with函数，如：&lt;code&gt;return view(&#39;index&#39;)-&amp;gt;with(&#39;username&#39;, &#39;Alan&#39;)-&amp;gt;with(&#39;age&#39;, 18);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;③ 通过with加变量名的形式，如：&lt;code&gt;return view(&#39;index&#39;)-&amp;gt;withUsername(&#39;Alan&#39;)-&amp;gt;withAge(18);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;blade模板&#34;&gt;blade模板&lt;/h2&gt;
&lt;p&gt;Blade模板是Laravel提供的视图文件引擎，该模板可以通过模板继承和区块实现高度的代码复用和清晰的视图结构。blade模板文件以&lt;code&gt;.blade.php&lt;/code&gt;为后缀。&lt;/p&gt;
&lt;h3 id=&#34;blade模板结构布局&#34;&gt;blade模板结构布局&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// layout.blade.php
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        @section(&#39;navbar&#39;)
            This is the layout navbar.
        @show
        
        @yield(&#39;content&#39;)
        &amp;lt;footer&amp;gt;
            &amp;lt;p&amp;gt;This is footer.&amp;lt;/p&amp;gt;
        &amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

// view.blade.php
@extend(&#39;layout&#39;)

@section(&#39;navbar&#39;)
    &amp;lt;p&amp;gt;This is the view navbar.&amp;lt;/p&amp;gt;
    @parent
@endsection

@section(&#39;content&#39;)
    &amp;lt;div&amp;gt;
        This is the content.
        include(&#39;sidebar&#39;)
    &amp;lt;/div&amp;gt;
@endsection

// sidebar.blade.php
&amp;lt;div&amp;gt;
    This is the sidebar.
&amp;lt;/div

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;return view(&#39;view&#39;);&lt;/code&gt;即可使用视图，显示内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;This is the view navbar.
This is the layout navbar.
This is the content.
This is the sidebar.
This is footer.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下为blade模板中用于布局的语法标签：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@extends(&#39;布局文件名&#39;)：用于继承一个布局文件&lt;/p&gt;
&lt;p&gt;@parent：用于显示继承的布局模板中的内容&lt;/p&gt;
&lt;p&gt;@section(&#39;区块名&#39;)：定义一个区块，其可以有不同的结尾标：@show用于显示区块；@stop和@endsection用于结束这个区块；@overwrite用于重写前面的区块。如果在布局模板文件中用@stop或@endsection结束这个区块，则视图文件将无法覆盖这个区块。&lt;/p&gt;
&lt;p&gt;@yield(&#39;区块文件&#39;, &#39;默认内容&#39;)：用于布局文件中显示一个区块。&lt;/p&gt;
&lt;p&gt;@include(&#39;子视图名称&#39;)：加载子视图文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;blade模板的过程控制语法&#34;&gt;blade模板的过程控制语法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;blade模板变量输出&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;{{ $name }}
// 效果对应的PHP原生代码
&amp;lt;?php echo $name; ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三目运算符&lt;code&gt;?:&lt;/code&gt;的效果&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;{{ $name or &#39;default&#39; }}
// 效果对应的PHP原生代码
&amp;lt;?php echo isset($name) ? $name : &#39;default&#39;; ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;禁止花括号被解析&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;@{{ $name }} // 输出{{ $name }}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;条件控制&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;@if($age == 18)
    i am {{$name}}
@elseif($age == 19)
    i am {{$age}}
@else
    i am {{$name}}, {{$age}}
@endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;循环控制&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// foreach
@foreach ($data as $key =&amp;gt; $value)
    &amp;lt;p&amp;gt;{{$key}} =&amp;gt; {{$value}}&amp;lt;/p&amp;gt;
@endforeach

// for
@for ($i = 0; $i &amp;lt; count($data); $i++)
    {{$i}} =&amp;gt; {{$data[$i]}}
@endfor

// while
@while (true)
    While loop
@endwhile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中在foreach循环中，可以使用&lt;code&gt;$loop&lt;/code&gt;变量获取相应的循环信息。该变量包含的信息有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;object(stdClass)[203]
  public &#39;iteration&#39; =&amp;gt; int 1       // 第几个item，范围：1~length
  public &#39;index&#39; =&amp;gt; int 0           // 索引，范围：0~length-1
  public &#39;remaining&#39; =&amp;gt; int 3       // 倒数，范围：length-1~0
  public &#39;count&#39; =&amp;gt; int 4           // 总长度，length
  public &#39;first&#39; =&amp;gt; boolean true    // 是否为第一个
  public &#39;last&#39; =&amp;gt; boolean false    // 是否为最后一个
  public &#39;depth&#39; =&amp;gt; int 1           // 当前循环嵌套层级
  public &#39;parent&#39; =&amp;gt; null           // 父级循环的loop变量信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;{{-- 注释 --}}
&lt;/code&gt;&lt;/pre&gt;
">初探Laravel---round 9 视图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/GFon-QqN1/"" data-c="
          &lt;p&gt;Laravel的控制器类通常存放在laravel/app/Http/Controllers目录下。应用程序的控制器类需要继承Laravel的控制器基类（Illuminate/Routing/Controller）。控制器类作为HTTP请求的二次分发控制部分，与路由有着紧密的关系，Laravel通依赖注入的方式降低了这种耦合。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;控制器路由&#34;&gt;控制器路由&lt;/h2&gt;
&lt;p&gt;前面讲了路由的处理由闭包函数完成，其实也可以将请求分发给控制器的具体函数进行处理。&lt;/p&gt;
&lt;h3 id=&#34;基础控制器路由&#34;&gt;基础控制器路由&lt;/h3&gt;
&lt;p&gt;基本格式与前面的路由一致，只是将第二个参数从闭包函数换为&amp;quot;控制器类@函数名&amp;quot;形式的字符串。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::get(&#39;user/{name}&#39;, &#39;UserController@index&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述用例中，将user/{name}形式的请求分发给UserController下的index函数进行处理，其中index函数需要一个形参用于接收URL中的name参数。控制器类如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace App\Http\Controllers;

use Illuminate\Routing\Controller as BaseController;

class UserController extends BaseController
{
    public function index($name)
    {
        return &#39;Hello &#39; . $name;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;span-stylecolordarkred隐式控制器路由在laravel-53中被弃用span&#34;&gt;&lt;span style=&#34;color:darkred;&#34;&gt;隐式控制器路由（在Laravel 5.3中被弃用）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;基础控制器路由需要对路由逐个定义，效率较低，而隐式控制器路由是一条语句定义多条路由信息。&lt;/p&gt;
&lt;p&gt;隐式控制器路由的具体格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::controller(&#39;路由前缀&#39;, &#39;控制器类名&#39; [, 命名路由]);
// 最后一个参数是当需要添加命名路由时，才以关联数组的形式给出。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 路由
&amp;lt;?php
Route::controller(&#39;user&#39;, &#39;UserController&#39;);

// 控制器类
&amp;lt;?php
namespace App\Http\Controllers;

use Illuminate\Routing\Controller as BaseController;

class UserController extends BaseController
{
    public function getIndex($name)
    {
        return &#39;Hello &#39; . $name;
    }
    
    public function anyTest()
    {
        return &#39;This is any request Test&#39;;
    }
    
    public function postIndex()
    {
    
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上实例中，user/index/Alan的GET请求会被分发给getIndex方法；user/test的任意请求都会被分发给anyTest方法；user/index的POST请求会分发给postIndex方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;注意：&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;① 隐式控制器路由在5.3版本及之后被弃用；&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;② 路由前缀可以为&#39;/&#39;；&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&#34;color: red;&#34;&gt;&lt;strong&gt;③ 当控制器的方法名为多个单词时（如：getUserIndex），请求地址应该是home-index的形式；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;restful资源控制器路由&#34;&gt;RESTful资源控制器路由&lt;/h3&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::resource(&#39;根资源标识&#39;, &#39;控制器类名&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;resource方法可以创建多条路由来处理不同的HTTP请求，控制器类的方法与HTTP请求的对应关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求方法&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;th&gt;行为&lt;/th&gt;
&lt;th&gt;控制器类处理函数名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;索引（首页）&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/home/create&lt;/td&gt;
&lt;td&gt;创建&lt;/td&gt;
&lt;td&gt;create&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;td&gt;store&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/home/{id}&lt;/td&gt;
&lt;td&gt;显示&lt;/td&gt;
&lt;td&gt;show&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/home/{id}/edit&lt;/td&gt;
&lt;td&gt;编辑&lt;/td&gt;
&lt;td&gt;edit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT/PATCH&lt;/td&gt;
&lt;td&gt;/home/{id}&lt;/td&gt;
&lt;td&gt;更新&lt;/td&gt;
&lt;td&gt;update&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;/home/{id}&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;destroy&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 路由文件
&amp;lt;?php
Route::resource(&#39;user&#39;, &#39;UserController&#39;);

// 控制器类
&amp;lt;?php
namespace App\Http\Controllers;

use Illuminate\Routing\Controller;

class UserController extends Controller
{
    public function index()
    {
        return &#39;This is index&#39;;
    }
    
    public function show($id)
    {
        return &#39;ID is&#39; . $id;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述用例中，当路由为&#39;/&#39;时，GET请求被分发到index方法；&#39;/home/12&#39;时，GET请求被分发到show方法。&lt;/p&gt;
">初探Laravel---round 8 控制器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/3j7CLIH6a/"" data-c="
          &lt;p&gt;路由是框架根据URL的不同，将请求提交给指定的控制器或者功能函数来处理。Laravel中，应用程序中的路由基本在laravel/routes目录下。路由文件在应用程序服务提供者启动过程中，通过app\Providers\RouteServiceProvider.php文件中的map方法进行加载。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;基础路由&#34;&gt;基础路由&lt;/h2&gt;
&lt;p&gt;在Laravel框架中，基础路由是一个URL对应一个响应程序，这个程序可以是一个闭包函数，也可以是一个控制器响应函数标识。&lt;/p&gt;
&lt;p&gt;以下为路由定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::方法名(&#39;URL&#39;, 闭包函数或控制器响应函数标识);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;路由定义中的方法名有：get、post、put、delete等。使用实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 该实例将根URL的GET请求路由到处理函数
Route::get(&#39;/&#39;, function () {
    return &#39;Hello World&#39;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要路由多种请求，可以使用match和any方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 匹配&#39;/&#39;的get、post请求
Route::match([&#39;get&#39;, &#39;post&#39;], &#39;/&#39;, function () {
    return &#39;Hello World&#39;;
});

// 匹配&#39;/&#39;的任意请求
Route::any(&#39;/&#39;, function () {
    return &#39;Hello World&#39;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;路由参数&#34;&gt;路由参数&lt;/h2&gt;
&lt;p&gt;使用GET请求可以通过URL传递参数。在Laravel中，使用URL传递参数的格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Route::get(&#39;资源标识/{参数[?][/{参数}...]}&#39;, 闭包函数或控制响应函数标识)[-&amp;gt;where(&#39;参数名&#39;, &#39;正则表达式&#39;)];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这种形式传递参数，闭包函数或控制器函数可以直接在路由处理函数中添加&lt;code&gt;$参数名&lt;/code&gt;的形参来接受参数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 当http://localhost/user/3的GET请求到来时，输出$id=3
// 该实例的id参数必须添加
Route::get(&#39;user/{id}&#39;, function ($id) {
    return &#39;$id=&#39; . $id;
});

// 参数名后接?表示该参数可选
Route::get(&#39;user/{name?}&#39;, function ($name = NULL) {
    return &#39;$name=&#39; . $name;
});

// where用来对输入参数进行限定，只有符合正则表达式要求的参数才能传递。
Route::get(&#39;user/{name}&#39;, function ($name) {
    return &#39;$name=&#39; . $name;
})-&amp;gt;where(&#39;name&#39;, &#39;[A-Za-z]+&#39;);

// 需要匹配多个参数时，使用数组传入
Route::get(&#39;user/{id}/{name}&#39;, function ($name) {
    return &#39;$name=&#39; . $name . PHP_EOL . 
        &#39;$id=&#39; . $id . PHP_EOL;
})-&amp;gt;where([&#39;name&#39; =&amp;gt; &#39;[A-Za-z]+&#39;, &#39;id&#39; =&amp;gt; &#39;[0-9]+&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;注意：&lt;strong&gt;形参的传入与参数名无关，只与形参的先后顺序有关。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;路由命名&#34;&gt;路由命名&lt;/h2&gt;
&lt;p&gt;路由命名相当于在路由定义的时候，为路由起一个别名，在以后的程序中通过这个别名来获取路由信息。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 为user/name起一个别名name，可以在其他地方使用，如：$url = route(&#39;name&#39;);获取该URL
Route::get(&#39;user/name&#39;, [&#39;as&#39; =&amp;gt; &#39;name&#39;, &#39;uses&#39; =&amp;gt; function () {
    return &#39;Hello World&#39;;
}]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;路由群组&#34;&gt;路由群组&lt;/h2&gt;
&lt;p&gt;当存在许多路由时，可以对路由进行分组，以增加程序的可读性。路由群组便是用来给路由分组的，同时给这个路由组添加前缀、中间件、子域名等。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 存在以下两个路由，它们的前缀都是user，中间件都是auth。
Route::get(&#39;user/id&#39;, [&#39;middleware&#39; =&amp;gt; &#39;auth&#39;, function () {
    return &#39;Hello ID&#39;;
}]);
Route::get(&#39;user/name&#39;, [&#39;middleware&#39; =&amp;gt; &#39;auth&#39;, function () {
    return &#39;Hello NAME&#39;;
}]);

// 此时，可将其定义为一个路由群组
Route::group([&#39;prefix&#39; =&amp;gt; &#39;user&#39;, &#39;middleware&#39; =&amp;gt; &#39;auth&#39;], function () {
    Route::get(&#39;id&#39;, function () {
        return &#39;Hello ID&#39;;
    });
    Route::get(&#39;name&#39;, function () {
        return &#39;Hello NAME&#39;;
    });
});
&lt;/code&gt;&lt;/pre&gt;
">初探Laravel---round 7 路由</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/S34EbWQZq/"" data-c="
          &lt;p&gt;HTTP协议的请求和响应报文都是由报文首部、空行和报文主体组成的，报文首部又分为：请求行或状态行、首部字段。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;请求行&#34;&gt;请求行&lt;/h2&gt;
&lt;p&gt;请求行是存在于请求报文中的，其组成为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;请求方法 请求URL HTTP版本
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTTP的请求方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求方法&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;th&gt;是否包含主体数据&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;从服务器获取文本&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;向服务器发送客户端数据&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;上传客户端的文件到服务器&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;从服务器上删除一个文件&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;只获取服务器的响应首部&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;获取服务器可以执行的方法&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;对经过代理服务器的报文进行追踪&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;状态行&#34;&gt;状态行&lt;/h2&gt;
&lt;p&gt;状态行是存在于响应报文中的，其组成为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP版本 状态码 描述短语
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTTP响应报文状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态码范围&lt;/th&gt;
&lt;th&gt;状态码类别&lt;/th&gt;
&lt;th&gt;典型状态码&lt;/th&gt;
&lt;th&gt;描述短语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;信息类状态码&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;收到请求初始部分，请继续发送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;成功状态码&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;请求已被正常处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;成功状态码&lt;/td&gt;
&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No Content&lt;/td&gt;
&lt;td&gt;请求被成功处理，但没有主体数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;成功状态码&lt;/td&gt;
&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;对资源部分请求成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;重定向状态满&lt;/td&gt;
&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;永久性重定向，请求的URL资源已被更新，响应首部包含新的URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;重定向状态码&lt;/td&gt;
&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Found(HTTP/1.1)、Move Temporarily(HTTP/1.0)&lt;/td&gt;
&lt;td&gt;临时性重定向，请求的URL资源临时更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;重定向状态码&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;Not Modified&lt;/td&gt;
&lt;td&gt;这是用于缓存目的。它告诉客户端的响应没有被修改，所以客户端可以继续使用的响应相同的缓存版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端错误状态码&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;客户端发送一个错误请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端错误状态码&lt;/td&gt;
&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;请求需要包含通过HTTP认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端错误状态码&lt;/td&gt;
&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;访问被拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端错误状态码&lt;/td&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;未找到请求的URL资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;服务器错误状态码&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;服务器出现错误，无法提供请求的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;服务器错误状态码&lt;/td&gt;
&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service Unavailable&lt;/td&gt;
&lt;td&gt;服务器正忙，无法提供正常请求服务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;首部字段&#34;&gt;首部字段&lt;/h2&gt;
&lt;h3 id=&#34;通用首部字段&#34;&gt;通用首部字段&lt;/h3&gt;
&lt;p&gt;通用首部字段无论是在请求报文中还是响应报文中都可以使用，主要用于描述HTTP协议本身。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通用首部字段名&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;用于指定客户端/服务器间连接的选项，例如指定连续连接或者通过”close&amp;quot;选项通知服务器在响应完成后关闭连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;报文创建日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;指定报文主体数据的编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Update&lt;/td&gt;
&lt;td&gt;发送端协议准备升级为新版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;报文经过中间节点（网关、代理等）信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;指定缓存行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;请求首部字段&#34;&gt;请求首部字段&lt;/h3&gt;
&lt;p&gt;请求首部字段存在于HTTP请求报文中，主要描述客户端的版本、处理能力等信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求首部字段名&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;客户端可处理的媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;客户端优先接收的字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;客户端优先接收的编码方式，如gzip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;客户端希望的语言种类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;授权信息，通常用于对服务器发送的WWW-Authorization首部进行应答&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie&lt;/td&gt;
&lt;td&gt;用于客户端向服务器发送Cookie信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie2&lt;/td&gt;
&lt;td&gt;用来说明客户端支持的Cookie版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;客户端的E-mail地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;请求资源所在服务器的主机和端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304 Not Modified&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;包含一个URL，客户端从该URL页面出发访问请求页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User-Agent&lt;/td&gt;
&lt;td&gt;用户代理，客户端信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UA-OS&lt;/td&gt;
&lt;td&gt;客户端主机上的操作系统名称、版本等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UA-Pixels&lt;/td&gt;
&lt;td&gt;客户端显示器像素信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;响应首部字段&#34;&gt;响应首部字段&lt;/h3&gt;
&lt;p&gt;响应首部字段存在于响应报文中，主要用于描述响应主机的信息、功能等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;响应首部字段名&lt;/th&gt;
&lt;th&gt;功能含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Age&lt;/td&gt;
&lt;td&gt;响应资源创建的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set-Cookie&lt;/td&gt;
&lt;td&gt;在客户端设置一个Cookie，服务器用来对客户端进行标识&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;服务器应用程序软件的名称、版本等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Retry-After&lt;/td&gt;
&lt;td&gt;当资源不可用时，在此期间再次发送请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Refresh&lt;/td&gt;
&lt;td&gt;表示浏览器应该在多长时间之后刷新文档，以秒计&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;实体首部字段&#34;&gt;实体首部字段&lt;/h3&gt;
&lt;p&gt;实体首部字段用于描述HTTP报文主体数据的字段，可以同时存在于请求报文中和响应报文中。如，实体信息类型、长度、压缩方法等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实体首部字段名&lt;/th&gt;
&lt;th&gt;功能含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Allow&lt;/td&gt;
&lt;td&gt;资源主体可以支持的HTTP请求方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;通知接收端主体的URL，用于接收端定位到该资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;主体适用的编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Language&lt;/td&gt;
&lt;td&gt;解释主体时使用的语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;主体的大小，通常以字节数表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-MD5&lt;/td&gt;
&lt;td&gt;主体的MD5校验和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;主体的对象类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">HTTP协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/2-U_VGU8Q/"" data-c="
          &lt;p&gt;最近不知道怎么的迷上了计算机网络，喜欢抓各种包，于是乎接触到了嗅探，对其有了一些了解，遂码个博客记录一下（ Wireshark 真的厉害）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-嗅探原理&#34;&gt;一、嗅探原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;集线器Hub&lt;/strong&gt;组建的网络是基于共享原理的，所有传输的数据在局域网中是共享的，换言之就是在同一局域网的所有网络接口都可以访问该局域网中正在传输的所有数据。那为什么对于某一用户而言，其他用户的数据不可见呢？关键在于每个计算机网卡都构建了一个“过滤器”，通过识别数据包中的地址来过滤掉与本机地址不匹配的信息，而嗅探只需要关闭这个“过滤器”，就可以接收所有数据包了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用&lt;strong&gt;交换机Switch&lt;/strong&gt;组成的网络基于交换原理，与集线器不同的是它并不会将数据包发送给全部设备，而是直接发送到目的地址。在这种情况下，嗅探又是如何“窥”到数据包的呢？既然交换机是将数据包直接发送给目的地址，那么如果我们将自己设备的地址伪装成数据包的目的地址是否就可以接收到此数据包呢？答案是肯定的，这就是嗅探获取交换机网络数据包的思路。既然要伪装成目的地址，那么就不得不说说交换机是如何确定目的设备的物理地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回信息，以此确定目标的物理地址。（ARP：Address Resolution Protocol，地址解析协议，与之相对应的还有RARP---Reverse Address Resolution Protocol，反向地址解析协议。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，对于使用交换机组建的网络可以使用&lt;a href=&#34;https://baike.baidu.com/item/ARP%E6%AC%BA%E9%AA%97/2805503?fr=aladdin&#34;&gt;ARP欺骗&lt;/a&gt;的方式，通过改变MAC地址欺骗交换机将数据包发给自己，嗅探完成后再转发出去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二-防范手段&#34;&gt;二、防范手段&lt;/h2&gt;
&lt;p&gt;如何保证自己的数据安全呢？我们改变不了底层数据包的s后发机制（也很难做到更好），那么只能通过使用更安全的传输协议或方式去让你的数据即使被截取也无法被识别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;从用户的角度：我们可以使用HTTPS访问网站，HTTPS全称为Hyper Text Transfer Protocol over Secure Socket Layer，它的实质是在HTTP的基础上加上SSL层，通过SSL层进行数据加密（SSL详情请看&lt;a href=&#34;https://baike.baidu.com/item/ssl&#34;&gt;SSL&lt;/a&gt;）。 &lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;注意：并不是使用HTTPS就万无一失，你必须保证你的浏览器与目标服务器建立了安全的HTTPS连接，其连接状态通常会显示在浏览器地址栏的开头，通常会有几种颜色表示连接状态的安全等级。&lt;/em&gt;&lt;/span&gt;例如Chrome：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/sniff/https.jpg&#34; alt=&#34;Chrome HTTPS效果图&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;从网站运营者的角度：我们应该对传输的数据进行加密。&lt;br&gt;
&lt;span style=&#34;line-height:200%;&#34;&gt;&lt;strong&gt;js加密可以吗？&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;em&gt;普通的 js 加密是不能解决问题的，试想一下：如果别人获取到你的数据包，得到你密码加密后的字符串，然后使用该字符串作为密码，并屏蔽掉前端网页的js加密脚本进行提交，其发送的数据内容其实和你正常登陆的数据别无二致。&lt;/em&gt;&lt;br&gt;
&lt;span style=&#34;line-height:200%;&#34;&gt;&lt;strong&gt;那应该如何加密呢？&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;em&gt;我们需要服务器端进行动态配合，当用户请求时在服务器端生成一个随机的验证码key，保存，并将 key 发送至前端 js，js 得到 key 之后，使用 key 作为密钥对提交的数据进行加密后提交（例如：md5(md5(password) + key)）。服务器端得到前端提交的加密后的字符串str1后，从数据库取出用户密码和 key ，进行同样的加密算法得到 str2 ，比较 str1 和 str2 就能得知密码是否正确。&lt;span style=&#34;color:red;&#34;&gt;该方法的好处在于每次请求都生成一个随机验证码，并使用该验证码对数据进行加密，就算每次使用的密码都一致，HTTP数据包的内容也会因为验证码的不同而出现差异。保证了每次请求的唯一性。&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
">浅谈嗅探</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/1q8juCKkk/"" data-c="
          &lt;p&gt;PHP是一种单继承语言，类似的还有Ruby等，与C++等多继承语言相比，代码复用性需要使用另外的方法去解决。在Ruby中使用Mixin混入类来解决。而在PHP中，使用Trait来实现。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Trait和类相似，但不能像类一样进行实例化，而是需要使用use关键字添加到其他类的内部。&lt;/p&gt;
&lt;h2 id=&#34;trait的简单使用&#34;&gt;Trait的简单使用：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;trait Hello
{
    public function hello()
    {
        echo &#39;hello() from Trait Hello&#39;;
    }
}

class A
{
    use Hello;
    
}

$a = new A();
$a-&amp;gt;hello(); // hello() from Trait Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;trait的重要性质&#34;&gt;Trait的重要性质&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;优先级：当前类的方法会覆盖trait中的方法，trait中的方法会覆盖基类的方法。&lt;/li&gt;
&lt;li&gt;多个Trait组合：use后跟多个trait并通过逗号分隔；或者使用use一一列出trait。&lt;/li&gt;
&lt;li&gt;冲突解决：如果两个trait都插入了一个同名的方法，若没有明确解决冲突，会产生一个致命错误。为了解决多个trait在同一类中的命名冲突，&lt;strong&gt;需要使用insteadof操作符来明确指定使用冲突方法中的哪一个&lt;/strong&gt;。同时，&lt;strong&gt;可以通过as操作符将其中一个冲突的方法以另外一个名称引入进来&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;修改方法的访问控制：使用as语法可以用来调整方法的访问控制。&lt;/li&gt;
&lt;li&gt;trait的抽象方法：在trait中可以使用抽象成员，使得类中必须实现这个抽象方法。&lt;/li&gt;
&lt;li&gt;trait中可以使用静态方法和静态变量。&lt;/li&gt;
&lt;li&gt;在trait中同样可以定义属性。&lt;/li&gt;
&lt;/ol&gt;
">PHP的Trait</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/wj0p65Bqw/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;一-php的错误error与异常exception&#34;&gt;一、PHP的错误ERROR与异常EXCEPTION&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;注意：在不同的语言中，错误与异常的定义不同。因此以下内容只在PHP中成立。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;错误error&#34;&gt;错误ERROR&lt;/h3&gt;
&lt;p&gt;错误：属于PHP脚本自身的问题，可能是由错误的语法、服务器环境等导致，使得编译器无法通过检查，甚至无法运行的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误不能被try/catch捕获&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;错误的级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fatal Error  致命错误，脚本终止运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E_ERRO: 致命的运行时错误，阻止脚本的执行&lt;/li&gt;
&lt;li&gt;E_CORE_ERROR: PHP初始化启动过程发生的错误，由PHP引擎核心产生&lt;/li&gt;
&lt;li&gt;E_COMPILE_ERROR: 致命编译时错误，由Zend脚本引擎产生&lt;/li&gt;
&lt;li&gt;E_USER_ERROR: 用户产生的错误信息，在代码中使用函数trigger_error()产生（错误类型设置为E_USER_ERROR）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parse Error  编译时解析错误，语法错误，脚本终止运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E_PARSE: 编译时语法解析错误，仅有分析器产生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Warning Error  警告错误，脚本不终止运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E_WARNING: 运行时警告，非致命错误&lt;/li&gt;
&lt;li&gt;E_CORE_WARNING: PHP初始化启动过程中发生的警告，非致命错误，由PHP引擎核心产生&lt;/li&gt;
&lt;li&gt;E_COMPILE_WARNING: 编译时警告，非致命错误，由Zend脚本产生&lt;/li&gt;
&lt;li&gt;E_USER_WARNING: 用户产生的警告信息，在代码中使用函数trigger_error()产生（错误类型设置为E_USER_WARNING）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Notice Error  通知错误，脚本不终止运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E_NOTICE: 运行时通知，表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知&lt;/li&gt;
&lt;li&gt;E_USER_NOTICE: 用户产生的通知信息，在代码中使用函数trigger_error()产生（错误类型设置为E_USER_NOTICE）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E_ALL: 除E_ALL外的所有的错误、警告和注意&lt;/li&gt;
&lt;li&gt;E_STRICT: 关于PHP版本移植的兼容性和互操作性建议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异常exception&#34;&gt;异常EXCEPTION&lt;/h3&gt;
&lt;p&gt;异常：在程序运行期间出现的不符合预期的情况，允许发生但不正常的情况。属于业务逻辑的错误，而不是语法或编译的错误。&lt;/p&gt;
&lt;h3 id=&#34;捕获错误和异常&#34;&gt;捕获错误和异常&lt;/h3&gt;
&lt;p&gt;在PHP中，用于捕获异常和错误的几个重要函数：&lt;strong&gt;error_reporting&lt;/strong&gt;、&lt;strong&gt;set_error_handler&lt;/strong&gt;、&lt;strong&gt;register_shutdown_function&lt;/strong&gt;、&lt;strong&gt;error_get_last&lt;/strong&gt;、&lt;strong&gt;set_exception_handler&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;error_reporting函数&#34;&gt;error_reporting函数&lt;/h4&gt;
&lt;p&gt;设置报告哪些错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;int error_reporting([int $err_type])

/**
 * int $err_type 可选参数，需要设置错误等级
 * 返回值：int 返回旧的错误级别
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;error_report(E_ALL | E_STRICT);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;set_error_handler函数&#34;&gt;set_error_handler函数&lt;/h4&gt;
&lt;p&gt;捕获错误，并执行用户自定义的错误处理函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;mixed set_error_handler(callable $error_handler 
    [, int $error_types = E_ALL | E_STRICT])
/**
 * callable $error_handler
 *     回调函数，需要声明四个参数：错误类型、错误信息、错误所在文件、错误所在行。
 *     第五个参数可选，指向错误发生时活动符号表的array，但在PHP 7.2.0被废）
 *     
 * int $error_types
 *     可选，规定在哪个错误报告级别显示用户定义的错误
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果存在该方法，相应的error_reporting()就不能再使用，所有错误都会交给自定义函数处理；&lt;/li&gt;
&lt;li&gt;此函数只能捕获系统产生的一些Warning、Notice级别的错误，不能捕获：E_ERROR、E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_WARNING以及set_error_handler()函数所在文件中产生的E_STRICT。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    set_error_handler(&#39;error_handler&#39;);
    function error_handler($err_type, $err_msg, $err_file, $err_line)
    {
        var_dump($err_type);
        var_dump($err_msg);
        var_dump($err_file);
        var_dump($err_line);
    }
    
    // 或者
    
    set_error_handler(array(&#39;class_name&#39;, &#39;function_name&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;register_shutdown_function函数&#34;&gt;register_shutdown_function函数&lt;/h4&gt;
&lt;p&gt;该函数时PHP脚本执行结束前最后一个调用的函数。通过这个函数就可以在脚本结束前判断是否产生错误。这是需要使用到&lt;strong&gt;error_get_last&lt;/strong&gt;函数，获取本次执行产生的所有错误。&lt;strong&gt;register_shutdown_function可以配合set_error_handler捕获所有错误&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;void register_shutdown_function(callable $callback
    [, mixed $parameter
    [, mixed $...]])
/**
 * callable $callback 回调函数
 * mixed $parameter 传递给回调的参数
 * ... 更多回调
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;该函数可以捕获的错误：Fatal Error、Parse Error等&lt;/li&gt;
&lt;li&gt;register_shutdown_function所在的文件发生语法错误，不能触发回调函数（用例之后会说到）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    register_shutdown_function(&#39;shutdown_handler&#39;);
    function shutdown_handler()
    {
        if ($err = error_get_last()) {
            var_dump($err);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，如果执行下列测试文件，是不能触发调用回调函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    register_shutdown_function(&#39;shutdown_handler&#39;);
    function shutdown_handler()
    {
        if ($err = error_get_last()) {
            var_dump($err);
        }
    }
    echo 1++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么不能触发呢？这是因为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果register_shutdown_function所在文件发生语法错误，该脚本不能通过PHP的语法分析，register_shutdown_function函数就不会被执行，也就没有注册回调函数。&lt;/p&gt;
&lt;p&gt;因此，我们需要保证register_shutdown_function所在文件没有语法错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将上述代码修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    register_shutdown_function(&#39;shutdown_handler&#39;);
    function shutdown_handler()
    {
        if ($err = error_get_last()) {
            var_dump($err);
        }
    }
    require &#39;a.php&#39;;
    
// a.php文件
&amp;lt;?php
    echo 1++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改之后，因为register_shutdown_function所在文件没有语法错误，通过了PHP的语法分析，所以register_shutdown_function函数得以正常运行，便能注册回调函数了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，最好将register_shutdown_function单独放在一个的文件中，并保证该文件没有语法错误。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;error_get_last函数&#34;&gt;error_get_last函数&lt;/h4&gt;
&lt;p&gt;该函数用于获取本次执行中产生的错误信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;array error_get_last()
/**
 * 返回值：array 
 * type =&amp;gt;　错误类型
 * message =&amp;gt; 错误信息
 * file =&amp;gt; 发生错误的文件
 * line =&amp;gt; 发生错误的行号
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;set_exception_handler函数&#34;&gt;set_exception_handler函数&lt;/h4&gt;
&lt;p&gt;设置异常处理函数，如果异常没被捕获就会进到该方法中，并且在回调函数调用后异常会中止。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;callable set_exception_handler(callable $exception_handler)

/**
 * callable $exception_handler 回调函数，需要接受一个参数：捕获的异常对象
 * 返回值： callable 返回定义的回调函数的名称
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是：set_error_handler、register_shutdown_function、set_exception_handler三个函数捕获错误的范围并不是相互独立，可能存在一定的交集，但错误只会被捕获一次，不会重复被捕获&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;二-日期与时间&#34;&gt;二、日期与时间&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mktime: 获取时间戳，参数依次为时、分、秒、月、日、年，皆可选&lt;/li&gt;
&lt;li&gt;strtotime: 将自然语言英语转换为时间戳&lt;/li&gt;
&lt;li&gt;gettimeofday: 获取某一天中的具体时间&lt;/li&gt;
&lt;li&gt;getdate: 获取一个由时间戳组成的关联数组，可选参数：一个时间戳&lt;/li&gt;
&lt;li&gt;date: 以指定格式返回时间字符串，参数：指定格式，可选参数为时间戳&lt;/li&gt;
&lt;li&gt;date_default_timezone_set: 设置默认时区，RPC、Asia/Shanghai、Asia/Chongqing、Etc/GMT-8&lt;/li&gt;
&lt;li&gt;microtime: 获取当前微秒级时间戳，可选参数：是否以浮点数形式返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-文件与目录&#34;&gt;三、文件与目录&lt;/h2&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 获取文件类型
filetype(string $file) : string | false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows中PHP只能获取到3种文件类型：file、dir、unknown，而在UNIX中，可以获取7种block、char、dir、fifo、file、link、unknown。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;block：块设备文件，如：硬盘分区、软驱、光驱等&lt;/li&gt;
&lt;li&gt;char：字符设备，指I/O传输中以字符为单位进行传输的设备，如键盘、打印机等&lt;/li&gt;
&lt;li&gt;dir：目录类型，目录也是文件的一种&lt;/li&gt;
&lt;li&gt;fifo：命名管道，常用于将信息从一个进程传递到另一个进程&lt;/li&gt;
&lt;li&gt;file：普通文件类型&lt;/li&gt;
&lt;li&gt;link：链接，软链接、硬链接&lt;/li&gt;
&lt;li&gt;unknown：未知类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;is_file、is_dir、is_link...：判断是否给定的文件为某一类型&lt;/li&gt;
&lt;li&gt;file_exists：&lt;strong&gt;文件或目录&lt;/strong&gt;是否存在&lt;/li&gt;
&lt;li&gt;filesize：文件大小&lt;/li&gt;
&lt;li&gt;is_readable：是否可读&lt;/li&gt;
&lt;li&gt;is_writeable：是否可写&lt;/li&gt;
&lt;li&gt;is_executable：是否可执行&lt;/li&gt;
&lt;li&gt;filectime：文件创建时间（inode修改时间）&lt;/li&gt;
&lt;li&gt;filemtime：文件修改时间&lt;/li&gt;
&lt;li&gt;fileatime：文件访问时间&lt;/li&gt;
&lt;li&gt;stat：获取文件的大部分属性值&lt;/li&gt;
&lt;li&gt;unlink：删除文件&lt;/li&gt;
&lt;li&gt;copy：复制文件&lt;/li&gt;
&lt;li&gt;rename：重命名&lt;/li&gt;
&lt;li&gt;fopen：打开文件，返回文件句柄，r、r+、w、w+、x、x+、a、a+、b、t&lt;/li&gt;
&lt;li&gt;fclose：关闭打开的文件&lt;/li&gt;
&lt;li&gt;fwrite：往打开的文件中写&lt;/li&gt;
&lt;li&gt;fread：读取打开文件的指定长度内容，参数1为文件句柄，参数2为读取的长度&lt;/li&gt;
&lt;li&gt;file_get_content：获取文件内容&lt;/li&gt;
&lt;li&gt;fgets：从打开的文件中获取一行&lt;/li&gt;
&lt;li&gt;fgets：从打开的文件中获取一个字符&lt;/li&gt;
&lt;li&gt;readfile：读取一个文件，并输出到输出缓冲区，返回长度&lt;/li&gt;
&lt;li&gt;file：把文件按行读到一个数组中&lt;/li&gt;
&lt;li&gt;ftell：返回文件指针的当前位置&lt;/li&gt;
&lt;li&gt;fseek：移动文件指针到指定位置&lt;/li&gt;
&lt;li&gt;rewind：重置文件指针到文件开头&lt;/li&gt;
&lt;li&gt;ftruncate：把文件截取到指定长度&lt;/li&gt;
&lt;li&gt;flock：文件锁，LOCK_SH共享锁、LOCK_EX排他锁、LOCK_UN释放锁、LOCK_NB附件锁（如果不希望flock在锁定时堵塞，则应该                                                                       加上该锁），锁也可被fclose释放&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;只读方式打开文件，从文件开头开始读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r+&lt;/td&gt;
&lt;td&gt;读写方式打开文件，从文件开头开始读写，逐个覆盖原内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;只写方式打开文件，从文件开头开始写。若文件已存在，删除原文件内容；若不存在，创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w+&lt;/td&gt;
&lt;td&gt;读写方式打开文件，从文件开头开始读写。若文件已存在，删除原文件内容；若不存在，创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;创建并以写入方式打开，从文件开头开始写。若文件存在，报出E_WARNING级别的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x+&lt;/td&gt;
&lt;td&gt;创建并以读写方式打开，从文件开头开始读写。若文件存在，报出E_WARNING级别的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;写入方式打开，从文件结尾开始写。若文件不存在，创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a+&lt;/td&gt;
&lt;td&gt;读写方式打开，从文件结尾开始读写。若文件不存在，创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;以二进制模式打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;以文本模式打开文件，只在Windows下可用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;p&gt;在UNIX系统中，必须使用&#39;/&#39;作为文件分隔符，而在Windows中，默认使用&#39;&#39;作为分隔符，同时支持使用&#39;/&#39;作为分隔符。&lt;/p&gt;
&lt;p&gt;在PHP中可以使用DIRECTORY_SEPARATOR获取当前系统的分隔符（Windows为&#39;&#39;，UNIX为&#39;/&#39;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;basename：获取文件名部分，第二个参数可以指定扩展名，如果指定了，返回值则不带扩展名&lt;/li&gt;
&lt;li&gt;dirname：获取去掉文件名部分后的目录&lt;/li&gt;
&lt;li&gt;pathinfo：获取路径的目录部分dirname、带扩展的文件名basename、扩展extension、不带扩展的文件名filename&lt;/li&gt;
&lt;li&gt;dir：返回Directory类的实例&lt;/li&gt;
&lt;li&gt;opendir：打开目录，返回目录句柄&lt;/li&gt;
&lt;li&gt;readdir：读取目录&lt;/li&gt;
&lt;li&gt;closedir：关闭目录&lt;/li&gt;
&lt;li&gt;rewinddir：倒回目录句柄，将目录指针重置到开始处&lt;/li&gt;
&lt;li&gt;scandir：浏览目录内容&lt;/li&gt;
&lt;li&gt;glob：检索指定的目录&lt;/li&gt;
&lt;li&gt;mkdir：创建目录&lt;/li&gt;
&lt;li&gt;rmdir：删除目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上传文件&#34;&gt;上传文件&lt;/h3&gt;
&lt;p&gt;需要注意的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;form表单设置enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;data&amp;quot;&lt;/li&gt;
&lt;li&gt;PHP使用$_FILES获取上传文件信息&lt;/li&gt;
&lt;li&gt;多文件上传，可指定name=&amp;quot;file[]&amp;quot;的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理上传文件可以用到的函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;is_uploaded_file：判断处理的文件是否是通过HTTP POST上传的。但参数必须是类似$_POST[&#39;file&#39;][&#39;tmp_name&#39;]的变量。&lt;/p&gt;
&lt;p&gt;move_uploaded_file：将上传移动到新位置，且该函数会判断文件是否为合法的通过HTTP POST上传的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;下载文件&#34;&gt;下载文件&lt;/h3&gt;
&lt;p&gt;设置网页头部信息，以保证浏览器是下载文件而不是直接输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;header(&#39;Content-Type: image/gif&#39;);
header(&#39;Content-Disposition: attachment; filename=&amp;quot;test.gif&amp;quot;&#39;); // 说明是附件
header(&#39;Content-Length: 3390&#39;);

readfile(&#39;test.gif&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图像绘制&#34;&gt;图像绘制&lt;/h2&gt;
&lt;h3 id=&#34;创建画布&#34;&gt;创建画布&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;resource imagecreate($x_size, $y_size)          // 基于调色板
resource imagecreatetruecolor($x_size, $y_size) // 真彩
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置颜色&#34;&gt;设置颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;int imagecolorallocate(resource $image, int $r, int $g, int $b)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;绘制&#34;&gt;绘制&lt;/h3&gt;
&lt;p&gt;图形区域填充&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagefill(resource $image, int $x, int $y, int $color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制点和线&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagesetpixel(resource $image, int $x, int $y, int $color)
bool imageline(resource $image, int $x1, int $y1, int $x2, int $y2, int $color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制矩阵&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 画一个矩阵
bool imagerectangle(resource $image, int $x1, int $y1, int $x2, int $y2, int $color)
// 画一个矩阵并填充
bool imagefilledrectangle(resource $image, int $x1, int $y1, int $x2, int $y2, int $color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制多边形&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagepolygon(resource $image, array $point, int $num_points, int $color)
bool imagefilledpolygon(resource $image, array $point, int $num_points, int $color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制椭圆&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imageellipse(resource $image, int $cx, int $cy, int $w, int $h, int $color)
bool imagefilledellipse(resource $image, int $cx, int $cy, int $w, int $h, int $color)
// ($cx, $cy) 中心坐标
// $w, $h 宽、高
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制弧线&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagearc(int $cx, int $cy, int $w, int $h, int $s, int $e, int $color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制文字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagestring(resource $image, int $font, int $x, int $y, string $s, int $color) // 水平
bool imagestringup(resource $image, int $font, int $x, int $y, string $s, int $color) // 垂直
bool imagechar(resource $image, int $font, int $x, int $y, char $c, int $color)
bool imagecharup(resource $image, int $font, int $x, int $y, char $c, int $color)
// 以ttf字体绘制文本
array imagettftext(resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生成图像&#34;&gt;生成图像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagegif(resource $image [, string $filename])
bool imagejpeg(resource $image [, string $filename [, int $quality]])
bool imagepng(resource $image [, string $filename])
bool imagewbmp(resource $image [, string $filename [, int $foreground]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;销毁图像&#34;&gt;销毁图像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagedestory(resource $img)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;图像处理&#34;&gt;图像处理&lt;/h2&gt;
&lt;p&gt;以图片为背景创建图像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;resource imagecreatefromjpeg(string $file)
resource imagecreatefrompng(string $file)
resource imagecreatefromgif(string $file)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取图片大小和类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;array getimagesize(string $file [, array &amp;amp;$imageinfo])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图片缩放、剪切&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagecopyresampled (resource $dst_img, resource $src_img, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h)
// 该函数可以将图像中的一块正方形区域复制到另一个图像中
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加水印&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;bool imagecopy(resource $des_img, resource $src_img, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h)
// 将源图像的(src_x, src,y)的宽src_w，高src_h的一部分复制到目标图像的(dst_x, dst_y)处
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图片旋转、翻转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;resource imagerotate(resource $src_img, float $angle, int $bg_color [, int $ignore_transport])
// 图片旋转angle角度，旋转后未覆盖到的部分使用bg_color填充，igno_transport为非零值，则透明色被忽略。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pdo&#34;&gt;PDO&lt;/h2&gt;
&lt;h3 id=&#34;pdo驱动&#34;&gt;PDO驱动&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;PDO驱动&lt;/th&gt;
&lt;th&gt;对应访问的数据库&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PDO_BDLIB&lt;/td&gt;
&lt;td&gt;FreeTDS/Microsoft SQL Server/Sybase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_FIREBIRD&lt;/td&gt;
&lt;td&gt;Firbird/Interbase 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_MYSQL&lt;/td&gt;
&lt;td&gt;MySQL 3.x/4.x/5.x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_OCI&lt;/td&gt;
&lt;td&gt;Oracle (OCI=Oracle Call Interface)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_ODBC&lt;/td&gt;
&lt;td&gt;ODBC v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_PGSQL&lt;/td&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO_SQLITE&lt;/td&gt;
&lt;td&gt;SQLite 2.x/3.x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;pdo类的方法&#34;&gt;PDO类的方法&lt;/h3&gt;
&lt;h4 id=&#34;构造方法&#34;&gt;构造方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;__construct(string $dsn [, string $username [, string $pwd [, array $driver_options]]])
// dsn：Data Source Name，数据源名，如：
// mysql:dbname=test;host=127.0.0.1;port=3306;charset=utf8
// DSN也可指定文件为参数（如果该文件中存放着DSN字符串），如：
// uri:file:///user/local/dbconnect
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attribute&#34;&gt;Attribute&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 获取或设置一个数据库连接对象的属性
getAttribute() // 参数：属性名
setAttribute() // 参数：属性名，属性值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PDO的一些属性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_AUTOCOMMIT&lt;/td&gt;
&lt;td&gt;确定PDO是否关闭自动提交功能，设置FALSE值时关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_CASE&lt;/td&gt;
&lt;td&gt;强制PDO获取的表字段字符大小写转换，或原样使用列信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_ERRMODE&lt;/td&gt;
&lt;td&gt;设置错误处理模式，PDO::ERRMODE_SILENT, PDO::ERRMODE_WARNING, PDO::ERRMODE_EXCEPTION&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_PERSISTENT&lt;/td&gt;
&lt;td&gt;确定连接是否为持久连接，默认为FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_ORACLE_NULLS&lt;/td&gt;
&lt;td&gt;将返回的空字符串转换为SQL的NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_PREFETCH&lt;/td&gt;
&lt;td&gt;设置应用程序提前获取的数据大小(单位：K)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_TIMEOUT&lt;/td&gt;
&lt;td&gt;设置超时之前等待的时间(单位：s)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_SERVER_INFO&lt;/td&gt;
&lt;td&gt;包含与数据库特有的服务器信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_SERVER_VERSION&lt;/td&gt;
&lt;td&gt;包含与数据库服务器版本号有关的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_CLIENT_VERSION&lt;/td&gt;
&lt;td&gt;包含与数据库客户端版本号有关的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PDO::ATTR_CONNECTION_STATUS&lt;/td&gt;
&lt;td&gt;包含数据库特有的与连接状态有关的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;错误&#34;&gt;错误&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 获取最后一次数据库操作的错误码
errorCode()
// 获取最后一次数据库操作的错误信息
errorInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;sql&#34;&gt;SQL&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;exec() // 执行一条SQL语句，并返回受影响的行数
query() // 执行一条SQL语句，并返回PDOStatement对象（结果集）
quote() // 为SQL语句中的字符串添加引号
lastInsertId() // 获取插入到表中的最后一条数据的主键值
prepare() // 准备要执行的SQL语句，返回PDOStatement对象
getAvailableDrivers() // 获取有效的PDO驱动器名称
beginTransaction() // 开始事务
commit() //提交事务
rollback() // 回滚事务
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;预处理语句和pdostatement类&#34;&gt;预处理语句和PDOStatement类&lt;/h3&gt;
&lt;p&gt;通过PDO的prepare方法传入一条预处理语句，返回一个PDOStatement查询对象，可以使用该对象传入参数，执行语句。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;PDOStatement类的成员方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bindColumn()&lt;/td&gt;
&lt;td&gt;将列名绑定到一个PHP变量，这样获取到记录后，会将相应的列值赋给该变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bindParam()&lt;/td&gt;
&lt;td&gt;将参数绑定到相应的占位符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bindValue()&lt;/td&gt;
&lt;td&gt;将一个值绑定到对应的一个参数中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;closeCursor()&lt;/td&gt;
&lt;td&gt;关闭游标，使该声明再次被执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;columnCount()&lt;/td&gt;
&lt;td&gt;在结果集中返回列的数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;errorCode()&lt;/td&gt;
&lt;td&gt;获取错误码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;errorInfo()&lt;/td&gt;
&lt;td&gt;获取错误信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;execute()&lt;/td&gt;
&lt;td&gt;执行一个预处理查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fetch()&lt;/td&gt;
&lt;td&gt;获取结果集的下一行，到结尾返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fetchAll()&lt;/td&gt;
&lt;td&gt;获取结果集的所有行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fetchColumn()&lt;/td&gt;
&lt;td&gt;获取某一列的下一个值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fetchObject()&lt;/td&gt;
&lt;td&gt;获取结果集的下一行，作为对象返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getAttribute()&lt;/td&gt;
&lt;td&gt;获取属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setAttribute()&lt;/td&gt;
&lt;td&gt;设置属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nextRowset()&lt;/td&gt;
&lt;td&gt;获取下一行结果集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rowCount()&lt;/td&gt;
&lt;td&gt;获取结果集的行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getColumnMeta()&lt;/td&gt;
&lt;td&gt;获取某一列的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setFetchMode()&lt;/td&gt;
&lt;td&gt;设置获取结果集的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;memcached&#34;&gt;MemCached&lt;/h2&gt;
&lt;h3 id=&#34;memcached命令&#34;&gt;MemCached命令&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;stats: 当前所有memcached服务器运行的状态信息&lt;br&gt;
add: 添加一个数据到服务器&lt;br&gt;
set: 替换一个已经存在的数据，如果数据不存在，则与add命令相同&lt;br&gt;
get: 从服务器端获取指定的数据&lt;br&gt;
delete: 删除指定的单个数据&lt;br&gt;
flush_all: 删除所有数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;在php中使用memcached&#34;&gt;在PHP中使用MemCached&lt;/h3&gt;
&lt;p&gt;需要安装memcached扩展包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Memcached::connect  // 打开一个到memcached的连接
Memcached::pconnect  // 打开一个到memcached的长连接
Memcached::addServer  // 分布式服务器添加一个服务器
Memcached::close  // 关闭一个memcached的连接
Memcached::getStats // 获取当前memcached服务器的状态
Memcached::add  // 添加一个值，若存在，返回false
Memcached::set  // 添加一个值，若存在，覆盖
Memcached::replace  // 替换一个值，类似于set                               
Memcached::get  // 获取一个数据                
Memcached::delete  // 删除一个数据
Memcached::flush   // 清空所有数据
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;框架&#34;&gt;框架&lt;/h2&gt;
&lt;p&gt;一个框架需要的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录组织结构&lt;/li&gt;
&lt;li&gt;类加载&lt;/li&gt;
&lt;li&gt;基础类&lt;/li&gt;
&lt;li&gt;URL处理&lt;/li&gt;
&lt;li&gt;输入处理&lt;/li&gt;
&lt;li&gt;错误异常处理&lt;/li&gt;
&lt;li&gt;扩展类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;php安全和优化&#34;&gt;PHP安全和优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不信任用户输入、验证用户数据&lt;/li&gt;
&lt;li&gt;及时修补漏洞&lt;/li&gt;
&lt;li&gt;隐藏Apache和PHP（Apache的ServerSignature、ServerToken指令、PHP的expose_php()函数）&lt;/li&gt;
&lt;li&gt;删除phpinfo()调用的所有实例&lt;/li&gt;
&lt;li&gt;修改文档扩展名&lt;/li&gt;
&lt;li&gt;拒绝访问某些类型的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用循环时，应该先计算长度，不要每次都计算一遍&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;isset($str{10})&lt;/code&gt;比&lt;code&gt;strlen($str) &amp;gt; 10&lt;/code&gt;更快，对于数组也一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$i++&lt;/code&gt;比&lt;code&gt;++$i&lt;/code&gt;稍慢（仅适用PHP）&lt;/li&gt;
&lt;/ul&gt;
">读《细说PHP》</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/sQNETQWN2/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;查询性能优化&#34;&gt;查询性能优化&lt;/h2&gt;
&lt;h3 id=&#34;理解查询执行的过程&#34;&gt;理解查询执行的过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送一条查询给服务器&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一个阶段&lt;/li&gt;
&lt;li&gt;服务器进行SQL解析、预处理，再由优化器生成对应的执行计划&lt;/li&gt;
&lt;li&gt;MySQL根据优化计划，调用存储引擎的API来执行查询&lt;/li&gt;
&lt;li&gt;将结果返回给客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优化数据访问&#34;&gt;优化数据访问&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;① 确认应用程序是否在检索大量超过需要的数据；&lt;/p&gt;
&lt;p&gt;② 确认MySQL服务器层是否在分析大量超过需要的数据行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;是否向数据库请求了不需要的数据&#34;&gt;是否向数据库请求了不需要的数据&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;查询不需要的记录: 有时候我们查询数据并不需要查询所有的数据，这个时候可以&lt;strong&gt;在查询后加上LIMIT&lt;/strong&gt;，以限制查询结果的数目。&lt;/li&gt;
&lt;li&gt;查询所有列: 取出所有列，会让优化器无法完成索引覆盖扫描这类优化，还会带来额外的I/O、内存和CPU消耗。&lt;strong&gt;应避免&lt;code&gt;SELECT *&lt;/code&gt;的写法，只取出需要使用到的列&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;重复查询相同的数据: 当需要重复查询相同数据时，应&lt;strong&gt;将相同的数据缓存起来&lt;/strong&gt;，这样可以提高系统性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;mysql是否在扫描额外的记录&#34;&gt;MySQL是否在扫描额外的记录&lt;/h4&gt;
&lt;p&gt;判断MySQL查询开销的三个重要指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间&lt;/li&gt;
&lt;li&gt;扫描的行数&lt;/li&gt;
&lt;li&gt;返回的行数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们大致反映了MySQL在内部执行查询时需要访问多少数据，并大概推算出查询运行的时间。&lt;/p&gt;
&lt;p&gt;需要注意，响应时间是服务时间和等待时间之和。&lt;/p&gt;
&lt;h3 id=&#34;重构查询&#34;&gt;重构查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;合适地选择一次重复的查询还是多个简单的查询&lt;/li&gt;
&lt;li&gt;将较大的语句切分为小的语句多次执行，例如，删除很多的数据记录，可以拆分为多次小的删除（两次删除相隔一段时间，也可以降低服务器压力）&lt;/li&gt;
&lt;li&gt;将关联查询分解为多个单表查询。可以提高缓存效率、减少锁的竞争等，很多时候将关联查询放到应用程序中将会更加高效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;特定类型查询的优化&#34;&gt;特定类型查询的优化&lt;/h3&gt;
&lt;h4 id=&#34;优化count&#34;&gt;优化COUNT()&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;COUNT()用于统计某一个列值的数量。并且&lt;strong&gt;要求列值是非空的（不统计NULL）&lt;/strong&gt;。使用COUNT()统计行数时，&lt;strong&gt;最好使用&lt;code&gt;COUNT(*)&lt;/code&gt;&lt;/strong&gt;，性能比较好，意义清晰。&lt;/li&gt;
&lt;li&gt;MyISAM存储引擎的&lt;code&gt;COUNT(*)&lt;/code&gt;并不总是非常快的，只有当没有任何where条件时，才会非常快，因为此时不需要实际地去计算结果的行数。有时可以简单地优化一下，例如：需要查询所有ID大于5的城市数，可以用全部行数减去ID&amp;lt;=5的城市数，从而缩小需要扫描的记录行数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化关联查询&#34;&gt;优化关联查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;确保ON或者USING字句中的列上有索引。&lt;/li&gt;
&lt;li&gt;确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化子查询&#34;&gt;优化子查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;子查询尽量使用关联查询代替&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化limit分页&#34;&gt;优化LIMIT分页&lt;/h4&gt;
&lt;p&gt;当LIMIT的偏移量很大时，例如LIMIT 1000, 20，这时MySQL需要查询1020条记录然后只返回20条数据，这样代价很高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法是：&lt;strong&gt;尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作，再返回所需要的列&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;另一个解决方法是：&lt;strong&gt;使用书签保存上次取记录的位置，下次从这个位置开始即可&lt;/strong&gt;，例如：&lt;code&gt;SELECT * FROM user LIMIT 20&lt;/code&gt;，如果前面语句返回的是1~20，下一页的查询则为：&lt;code&gt;SELECT * FROM user WHERE user_id&amp;gt;20 LIMIT 20&lt;/code&gt;，该做法可行是因为主键user_id是单调递增的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优化union查询&#34;&gt;优化UNION查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;除非确实需要消除重复行，否则一定要使用UNION ALL。因为单独使用UNION，MySQL会对整个临时表的数据做唯一性检查，造成不必要的性能消耗。&lt;/li&gt;
&lt;/ul&gt;
">读《高性能MySQL》---（三）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/eYNTZFhJ-/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;表与数据类型的优化&#34;&gt;表与数据类型的优化&lt;/h2&gt;
&lt;h3 id=&#34;选择数据类型的原则&#34;&gt;选择数据类型的原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;更小的通常更好&lt;/strong&gt;：尽量使用可以正确存储数据的最小数据类型。因为更小通常更快，性能更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单就好&lt;/strong&gt;：简单数据类型通常需要更少的CPU周期。例，使用MySQL内建的类型而不是字符串来存储日期和时间；应该用整型存储IP地址，因为IP本身就是一串数字，使用点分割只是为了更容易让我们识别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量避免NULL&lt;/strong&gt;：使用NULL会让MySQL更难优化，因为可为NULL的列使得索引、索引统计和值更复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;整数&#34;&gt;整数&lt;/h3&gt;
&lt;p&gt;TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别使用8, 16, 24, 32, 64位存储空间。&lt;/p&gt;
&lt;p&gt;MySQL可以为整数类型指定宽度，但是不会限制值的合法范围，只是规定一些MySQL交互工具用来显示字符的个数。&lt;/p&gt;
&lt;h3 id=&#34;实数&#34;&gt;实数&lt;/h3&gt;
&lt;p&gt;FLOAT, DOUBLE, DECIMAL。FLOAT使用4个字节，DOUBLE使用8个字节。&lt;/p&gt;
&lt;p&gt;其中FLOAT、DOUBLE使用浮点运算实现，而DECIMAL是由MySQL服务器实现其计算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;decimal(总位数, 小数点后位数)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;
&lt;p&gt;VARCHAR, CHAR。VARCHAR为变长，CHAR为定长。当使用VARCHAR时，ROW_FORMAT不应该指定为FIXED，因为FIXED表示行长度不可变。&lt;/p&gt;
&lt;h3 id=&#34;枚举&#34;&gt;枚举&lt;/h3&gt;
&lt;p&gt;ENUM。底层使用整数存储，存在“数字-字符串”的映射关系表。&lt;strong&gt;需要注意的是排序时是按照内部整数进行排序，而不是按照字符串&lt;/strong&gt;。在定义时，可以将枚举的项按字符串排好序，已解决排序问题。&lt;/p&gt;
&lt;h3 id=&#34;时间&#34;&gt;时间&lt;/h3&gt;
&lt;p&gt;DATETIME: 1001~9999，占8个字节，与时区无关。&lt;/p&gt;
&lt;p&gt;TIMESTAMP: 1970~2038，占4个字节，与时区有关。在插入数据时，若未指定值，则自动取当前时间作为值填充。&lt;/p&gt;
&lt;h3 id=&#34;mysql设计中应避免的问题&#34;&gt;MySQL设计中应避免的问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;① 使用太多的列；&lt;/p&gt;
&lt;p&gt;② 使用太多的关联：如果希望查询执行得快速且并发性好，单个查询最好在12个表内做关联。&lt;/p&gt;
&lt;p&gt;③ 过度使用枚举；&lt;/p&gt;
&lt;p&gt;④ 完全不使用NULL，有时候使用NULL能更好的处理业务逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;范式&#34;&gt;范式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;范式的优点&lt;/strong&gt;：范式化的更新操作通常比反范式化要快；范式化的表更小，执行操作会更快；冗余数据更少，查询数据时更少使用DISTINCT或GROUP BY。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;范式的缺点&lt;/strong&gt;：范式化的表需要关联操作。&lt;/p&gt;
&lt;p&gt;在实际使用中，通常&lt;strong&gt;混合使用范式化和反范式化&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;alter-table操作&#34;&gt;ALTER TABLE操作&lt;/h3&gt;
&lt;p&gt;当对表使用ALTER TABLE操作时，大部分时候会导致MySQL服务中断。常用的解决方法有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换。&lt;/p&gt;
&lt;p&gt;② 影子拷贝：用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;创建高性能的索引&#34;&gt;创建高性能的索引&lt;/h2&gt;
&lt;h3 id=&#34;b-tree索引&#34;&gt;B-Tree索引&lt;/h3&gt;
&lt;p&gt;B-Tree索引是最通用的索引类型。B-Tree索引适用于全键值、键值范围、键前缀查找、ORDER BY。&lt;/p&gt;
&lt;h3 id=&#34;hash索引&#34;&gt;Hash索引&lt;/h3&gt;
&lt;p&gt;哈希索引，对所有索引列计算一个哈希码，并将哈希码存储在索引中，同时在哈希表中保存指向数据行的指针。哈希冲突时，使用链表保存相同哈希码的数据。&lt;/p&gt;
&lt;p&gt;Hash索引的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 只有精确匹配索引的每一列才有效，因为Hash索引需要使用所有列计算出hash码才能找到对应的数据行。&lt;/p&gt;
&lt;p&gt;② 无法用于排序；&lt;/p&gt;
&lt;p&gt;③ 速度快；&lt;/p&gt;
&lt;p&gt;④ 只能用于等值查询，不能用于范围查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模拟hash索引&#34;&gt;模拟Hash索引&lt;/h3&gt;
&lt;p&gt;例如：存储大量URL时，需要根据URL进行搜索查找。这时，可以添加一个被索引的url_crc列，使用CRC32作为hash。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id from url where url_crc=CRC32(&amp;quot;http://&amp;quot;) and url=&amp;quot;http://&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;全文索引&#34;&gt;全文索引&lt;/h3&gt;
&lt;p&gt;全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。&lt;/p&gt;
&lt;h3 id=&#34;高性能的索引策略&#34;&gt;高性能的索引策略&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;① 索引列不能是表达式的一部分，也不能是函数的参数。应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。&lt;/p&gt;
&lt;p&gt;② 当需要索引很长的字符列时，可以索引开始的部分前缀字符，以节约索引空间。&lt;/p&gt;
&lt;p&gt;③ 当创建多列索引时，需要注意索引列的顺序，应遵循前缀原则进行排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;聚簇索引&#34;&gt;聚簇索引&lt;/h3&gt;
&lt;p&gt;聚簇索引不同于B-Tree索引、Hash索引，其不是一种索引类型，而是一种数据存储方式。&lt;/p&gt;
&lt;p&gt;InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;聚簇索引的优点：① 可以把相关数据保存在一起；② 数据访问更快；③ 使用覆盖索引扫描的查询可以直接使用叶节点中的主键值。&lt;/p&gt;
&lt;p&gt;聚簇索引的缺点：① 插入速度严重依赖于插入顺序；② 更新聚簇索引列的代价很高；③ 聚簇索引可能导致全盘扫描变慢。&lt;/p&gt;
&lt;/blockquote&gt;
">读《高性能MySQL》---（二）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/_vhnkfsn5/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;mysql逻辑结构&#34;&gt;MySQL逻辑结构&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB;
  subgraph 第一层
    A(客户端)
  end
  subgraph 第二层
    B(连接/线程处理)--&amp;gt;C(查询缓存)
    B--&amp;gt;D(解析器)
    D--&amp;gt;C
    D--&amp;gt;E(优化器)
  end
  subgraph 第三层
    F(存储引擎)
  end
  A--&amp;gt;B
  E--&amp;gt;F
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;：一个事务是一个不可分割的最小单元，整个事务的所有操作要么全部完成，要么全部不执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;：数据库总是从一个一致性的状态转换到另外一个一致性的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：事务之间相互独立，一个事务在提交之前对其他事务是不可见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;：一旦事务提交，其所作的修改将会永久保存到数据库中。&lt;/p&gt;
&lt;h3 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;READ UNCOMMITTED（未提交读）&lt;/strong&gt;：在该级别中，事务的修改即使在没有提交的情况下，也会对其他事务可见。即，可以读取未提交的数据（脏读）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;READ COMMITTED（提交读）&lt;/strong&gt;：一个事务从开始到提交前，所做的任何操作对其他事务都是不可见的。但会出现不可重复读的问题，即，执行两次相同的查询，可能会得到不一样的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REPEATABLE READ（可重复读）&lt;/strong&gt;：该级别保证了在同一事务中多次读取同样记录的结果是一致的。但该级别无法解决幻读问题，即，当某个事务在读取某一范围内的记录时，另一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SERIALIZABLE（可串行化）&lt;/strong&gt;：强制事务串行执行，避免幻读问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;幻读和不可重复读的区别：&lt;/p&gt;
&lt;p&gt;不可重复读注重两次查询之间，数据发生了修改，例如，两次查询账户余额之间，另一事务修改了账户余额，从而导致两次相同查询的结果不同；&lt;/p&gt;
&lt;p&gt;而幻读注重两次相同的范围查询之间，插入了新的数据行，即出现了幻行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;p&gt;InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。&lt;/p&gt;
&lt;h3 id=&#34;事务日志&#34;&gt;事务日志&lt;/h3&gt;
&lt;p&gt;存储引擎在修改数据时，只需要修改其内存拷贝，然后将修改行为以追加的形式持久化到事务日志文件中，最后在后台将修改数据从内存中持久化到磁盘。&lt;/p&gt;
&lt;p&gt;事务日志可以提高事务的效率。&lt;/p&gt;
&lt;h3 id=&#34;mysql的事务&#34;&gt;MySQL的事务&lt;/h3&gt;
&lt;p&gt;① MySQL默认使用自动提交（AUTOCOMMIT），即，如果不是显式地开始事务，则每个查询都会当做一个事务执行提交操作。&lt;/p&gt;
&lt;p&gt;② 如果在事务中混用存储引擎，在回滚时会导致数据库处于不一致的状态，应避免这种情况的发生。&lt;/p&gt;
&lt;p&gt;③ MySQL支持LOCK TABLES和UNLOCK TABLES语句，其是在服务器层实现的，和存储引擎无关，不同于事务。避免显式地使用LOCK TABLES，除非事务中禁用了AUTOCOMMIT，否则会导致情况变得非常复杂。&lt;/p&gt;
&lt;h3 id=&#34;多版本并发控制mvcc&#34;&gt;多版本并发控制（MVCC）&lt;/h3&gt;
&lt;p&gt;MVCC可以说是行级锁的变种，但它在很多情况下避免了加锁操作，因此开销更低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InnoDB的MVCC实现&lt;/strong&gt;：通过每行记录后保存两个隐藏的列来实现的。一列保存行的创建时间，另一列保存行的过期时间（这里的时间指系统版本号，而不是真实的时间值）.保存这两个额外的系统版本号，可以使大多数读操作都可以不用加锁，简化读数据操作，提高性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在InnoDB中，MVCC只在READ COMMITTED（提交读）和REPEATABLE READ（可重复读）两个级别下工作，而READ UNCOMMITTED会读取最新的数据行，而不是当前版本的数据，SERIALIZABLE则会对所有读取的行都加锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;剖析mysql查询&#34;&gt;剖析MySQL查询&lt;/h2&gt;
&lt;h3 id=&#34;使用explain&#34;&gt;使用EXPLAIN&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; explain select * from test;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | test  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;select_type&lt;/strong&gt;: 查询的类型，simple表示简单查询，不包含子查询和union；primary表示包含union和子查询，且最外层部分被标志为primary；等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;table&lt;/strong&gt;: 查询的表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;: 访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; fulltext &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;possible_keys&lt;/strong&gt;: 可能用到的索引，但是在实际优化过程中可能有些索引未被用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key&lt;/strong&gt;: MySQL实际决定使用的键（索引）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key_len&lt;/strong&gt;: MySQL决定使用的键长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt;: 使用哪个列或常数与key一起从表中选择行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt;: MySQL认为它执行查询时必须检查的行数（预估值）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt;: MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;慢查询日志&#34;&gt;慢查询日志&lt;/h3&gt;
&lt;p&gt;慢查询日志最初只是用来捕获比较慢的查询，但在MySQL 5.1及以后的版本中，&lt;strong&gt;慢查询日志可以通过设置long_query_time为0来捕获所有的查询&lt;/strong&gt;，且响应时间单位已经可以做到微秒级。&lt;/p&gt;
&lt;p&gt;慢查询日志相关的一些值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slow_query_log: 是否打开慢查询日志&lt;/li&gt;
&lt;li&gt;slow_query_log_file: 慢查询日志文件&lt;/li&gt;
&lt;li&gt;long_query_time: 默认为10秒，大于该时间的会被记录到慢查询日志中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查看慢查询日志状态&#34;&gt;查看慢查询日志状态&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show variables like &#39;%slow_query_log%&#39;;
+---------------------+--------------------------------------------+
| Variable_name       | Value                                      |
+---------------------+--------------------------------------------+
| slow_query_log      | OFF                                        |
| slow_query_log_file | /usr/local/mysql/data/Alan-Albert-slow.log |
+---------------------+--------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看long_query_time
mysql&amp;gt; show variables like &#39;%long_query_time%&#39;;
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;打开或关闭慢查询日志&#34;&gt;打开或关闭慢查询日志&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 打开慢查询日志，关闭设为0
mysql&amp;gt; set global slow_query_log=1;
Query OK, 0 rows affected (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用该语句开启慢查询日志只对当前数据库生效，如果MySQL重启后则会生效。如果要永久开启，则需要修改配置文件my.cnf，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;slow_query_log=1
# slow_query_log_file=/tmp/mysql_slow.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;show-profile命令&#34;&gt;SHOW PROFILE命令&lt;/h3&gt;
&lt;h4 id=&#34;查看show-profile命令状态&#34;&gt;查看SHOW PROFILE命令状态&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show variables like &#39;%profiling%&#39;;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| have_profiling         | YES   |
| profiling              | ON    |
| profiling_history_size | 15    |
+------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;开启show-profile命令&#34;&gt;开启SHOW PROFILE命令&lt;/h4&gt;
&lt;p&gt;SHOW PROFILE命令默认是禁用的，开启方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; set profiling = 1;
Query OK, 0 rows affected, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;使用show-profiles&#34;&gt;使用show profiles&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;show profiles&lt;/strong&gt;: 显示最近发送到服务器上执行的语句的资源使用情况。显示的记录数由变量profiling_history_size控制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show profiles;
+----------+------------+-----------------------------------+
| Query_ID | Duration   | Query                             |
+----------+------------+-----------------------------------+
|        1 | 0.00163200 | show variables like &#39;profiling&#39;   |
+----------+------------+-----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;使用show-profile&#34;&gt;使用show profile&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;show profile&lt;/strong&gt;: 展示最近一条语句执行的详细资源占用信息，默认显示 Status和Duration两列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show profile;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000074 |
| checking permissions | 0.000037 |
| Opening tables       | 0.000026 |
| init                 | 0.000059 |
| System lock          | 0.000012 |
| optimizing           | 0.000007 |
| optimizing           | 0.000006 |
| statistics           | 0.000015 |
| preparing            | 0.000018 |
| statistics           | 0.000019 |
| preparing            | 0.000011 |
| executing            | 0.000011 |
| Sending data         | 0.000020 |
| executing            | 0.000005 |
| Sending data         | 0.001458 |
| end                  | 0.000009 |
| query end            | 0.000010 |
| removing tmp table   | 0.000021 |
| query end            | 0.000007 |
| closing tables       | 0.000012 |
| freeing items        | 0.000027 |
| logging slow query   | 0.001444 |
| cleaning up          | 0.000022 |
+----------------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以根据show profiles的Query_ID，选择显示某条记录的性能信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show profile for query 1;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000062 |
| checking permissions | 0.000018 |
| Opening tables       | 0.000020 |
| init                 | 0.000084 |
| System lock          | 0.000009 |
| optimizing           | 0.000010 |
| optimizing           | 0.000004 |
| statistics           | 0.000012 |
| preparing            | 0.000015 |
| statistics           | 0.000015 |
| preparing            | 0.000008 |
| executing            | 0.000009 |
| Sending data         | 0.000008 |
| executing            | 0.000004 |
| Sending data         | 0.001124 |
| end                  | 0.000008 |
| query end            | 0.000014 |
| removing tmp table   | 0.000018 |
| query end            | 0.000006 |
| closing tables       | 0.000011 |
| freeing items        | 0.000032 |
| logging slow query   | 0.000117 |
| cleaning up          | 0.000024 |
+----------------------+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以指定消耗的资源查询：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show profile cpu for query 1;
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| starting             | 0.000062 | 0.000056 |   0.000006 |
| checking permissions | 0.000018 | 0.000015 |   0.000003 |
| Opening tables       | 0.000020 | 0.000019 |   0.000002 |
| init                 | 0.000084 | 0.000056 |   0.000027 |
| System lock          | 0.000009 | 0.000008 |   0.000005 |
| optimizing           | 0.000010 | 0.000004 |   0.000002 |
| optimizing           | 0.000004 | 0.000003 |   0.000001 |
| statistics           | 0.000012 | 0.000011 |   0.000001 |
| preparing            | 0.000015 | 0.000013 |   0.000002 |
| statistics           | 0.000015 | 0.000013 |   0.000001 |
| preparing            | 0.000008 | 0.000007 |   0.000002 |
| executing            | 0.000009 | 0.000007 |   0.000002 |
| Sending data         | 0.000008 | 0.000007 |   0.000001 |
| executing            | 0.000004 | 0.000002 |   0.000001 |
| Sending data         | 0.001124 | 0.001109 |   0.000016 |
| end                  | 0.000008 | 0.000006 |   0.000007 |
| query end            | 0.000014 | 0.000008 |   0.000001 |
| removing tmp table   | 0.000018 | 0.000016 |   0.000002 |
| query end            | 0.000006 | 0.000003 |   0.000002 |
| closing tables       | 0.000011 | 0.000011 |   0.000002 |
| freeing items        | 0.000032 | 0.000015 |   0.000016 |
| logging slow query   | 0.000117 | 0.000032 |   0.000086 |
| cleaning up          | 0.000024 | 0.000021 |   0.000003 |
+----------------------+----------+----------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用show-status&#34;&gt;使用SHOW STATUS&lt;/h3&gt;
&lt;p&gt;MySQL的SHOW STATUS命令会返回一些计数器。可以使用该命令查看该语句使用了多少个临时表、是否用到索引的读操作等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; flush status;
mysql&amp;gt; select * from test;
mysql&amp;gt; show status;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;：使用show status本身也会创建一个临时表，而且也会通过句柄操作访问此临时表，这也会影响到输出的结果。&lt;/p&gt;
&lt;h3 id=&#34;show-processlist&#34;&gt;SHOW PROCESSLIST&lt;/h3&gt;
&lt;p&gt;该命令用于查看线程，观察是否有大量线程处于不正常状态或者有其他不正常的特征。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql&amp;gt; show processlist;
+----+-----------------+-----------+-------+---------+-------+------------------------+------------------+
| Id | User            | Host      | db    | Command | Time  | State                  | Info             |
+----+-----------------+-----------+-------+---------+-------+------------------------+------------------+
|  4 | event_scheduler | localhost | NULL  | Daemon  | 23210 | Waiting on empty queue | NULL             |
| 13 | root            | localhost | test2 | Query   |     0 | starting               | show processlist |
+----+-----------------+-----------+-------+---------+-------+------------------------+------------------+
&lt;/code&gt;&lt;/pre&gt;
">读《高性能MySQL》---（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/e3pUd7NWO/"" data-c="
          &lt;p&gt;每个React Native组件从加载到卸载都经历了一个完整的生命周期。在这个生命周期中，React提供了一些钩子函数，开发者可以实现这些函数，来完成在某个特定时间执行一些操作。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;各周期函数如图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/react-native/4/1.svg&#34; alt=&#34;React Native周期函数&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;&lt;em&gt;Tips：上述的getDefaultProps和getInitialState分别是ES5使用的定义默认属性props的函数和定义初始状态state的函数。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;getdefaultprops&#34;&gt;getDefaultProps&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;getDefaultProps ()&lt;/p&gt;
&lt;p&gt;return: 对象，设置的默认props&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设置组件的一些默认属性。定义后可以使用this.props获取在这里初始化的属性。组件初始化后，再次使用该组件不会调用getDefaultProps，所以组件不能修改自己的props，只能由其他组件在调用它时在外部修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;getDefaultProps () {
  return {
    name: &#39;Alan&#39;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数只能在ES5中配合createClass使用，不能使用在ES6中。在ES6中定义默认属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;export default class MyProject extends Component {
  static defaultProps = {
    name: &#39;Alan&#39;
  };
  // ...
}
// 或
export default class MyProject extends Component {
  // ...
}
MyProject.defaultProps = {
  name: &#39;Alan&#39;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getinitialstate&#34;&gt;getInitialState&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;getInitialState ()&lt;/p&gt;
&lt;p&gt;return: 对象，设置的初始state&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该函数对组件的状态state进行初始化。该函数不同于getDefaultProps，其在后续过程中会被再次调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;getInitialState () {
  return {
    name: &#39;Alan&#39;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数也是只能在ES5中使用，在ES6中初始化state：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;export default class MyProject extends Component {
  constructor (props) {
    super(props);
    this.state = {
      name: &#39;Alan&#39;
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constructor&#34;&gt;constructor&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;constructor (props)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React Native组件的构造函数，其第一条语句必须是super(props)。该周期函数在组件加载前最先调用，且只调用一次。可在该函数中定义状态机变量。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;constructor (props) {
  super(props);
  this.state = {
    text: &#39;&#39;
  };
}
// 以上为ES6定义初始state的方法
// ES5使用getInitialState进行定义
getInitialState () {
  return {
    text: &#39;&#39;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;render&#34;&gt;render&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;render ()&lt;br&gt;
return: JSX组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;render是一个组件中必须有的方法，返回JSX或其他组件构成DOM（只能返回一个顶级元素）。&lt;/p&gt;
&lt;h2 id=&#34;componentwillmount&#34;&gt;componentWillMount&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentWillMount ()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该函数在组件渲染（render函数执行）前被调用执行，且在一个生命周期中只执行一次。子组件的componentWillMount函数在父组件的ComponentWillMount函数之后被调用。&lt;/p&gt;
&lt;h2 id=&#34;componentdidmount&#34;&gt;componentDidMount&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentDidMount ()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该函数在组件渲染完成后被调用，且在一个生命周期中只执行一次。子组件的componentDidMount函数在父组件的componentDidComponent函数之前执行。&lt;/p&gt;
&lt;h2 id=&#34;componentwillreceiveprops&#34;&gt;componentWillReceiveProps&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentWillReceiveProps (newProps)&lt;/p&gt;
&lt;p&gt;param: 接受一个对象作为参数，该对象为新的props&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：函数内，this.props表示旧的props，新的props为参数newProps&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在初次渲染完成后，当组件接收到新的props时，这个函数被调用。如果新的props会造成界面重新渲染，该函数会在渲染前执行。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color: red&#34;&gt;&lt;strong&gt;在初次渲染时，该函数不会被执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;shouldcomponentupdate&#34;&gt;shouldComponentUpdate&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;shouldComponentUpdate (newProps, newState)&lt;/p&gt;
&lt;p&gt;param: 接受两个对象作为参数，分别为新的props、新的state&lt;/p&gt;
&lt;p&gt;return: 需返回Bool值，是否重新渲染该组件&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：函数内，this.props(this.state)表示旧的props(state)，新的props(state)为参数newProps(newState)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在初始渲染完成后，当组件接收到新的state或props时，该函数被调用。React Native默认返回true。&lt;/p&gt;
&lt;h2 id=&#34;componentwillupdate&#34;&gt;componentWillUpdate&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentWillUpdate (newProps, newState)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;初次渲染完成后，在该组件重新渲染前被调用。&lt;/p&gt;
&lt;h2 id=&#34;componentdidupdate&#34;&gt;componentDidUpdate&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentDidUpdate (oldProps, oldState)&lt;/p&gt;
&lt;p&gt;param：渲染前的props、state&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;初次渲染完成后，当该组件重新渲染完成会被调用。&lt;/p&gt;
&lt;h2 id=&#34;componentwillunmount&#34;&gt;componentWillUnmount&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;componentWillUnmount ()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在组件被卸载前，该函数被调用。&lt;/p&gt;
&lt;h2 id=&#34;获取真实的dom节点&#34;&gt;获取真实的DOM节点&lt;/h2&gt;
&lt;p&gt;在原生的JS中，获取DOM使用getElementById等一系列函数。而在React中，获取DOM前，需要给组件指定ref属性，通过ref属性获取DOM。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;constructor (props) {
  super (props);
  this.pressText = this.pressText.bind(this);
}

pressText () {
  console.log(this.refs.myTextInput);
}

render () {
  return (
    &amp;lt;View&amp;gt;
      &amp;lt;TextInput ref=&amp;quot;myTextInput&amp;quot; /&amp;gt;
      &amp;lt;Text onPress={this.pressText}&amp;gt;点击&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;react中es5-es6的差别&#34;&gt;React中ES5、ES6的差别&lt;/h2&gt;
&lt;h3 id=&#34;创建类&#34;&gt;创建类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// ES5(React 15.4及之前版本)
var React = require(&#39;react&#39;);
var Example = React.createClass({
  render () {
    return (&amp;lt;View&amp;gt;&amp;lt;/View&amp;gt;);
  }
});

// ES5(React 15.5之后的版本，React的createClass被移除)
var React = require(&#39;react&#39;);
var createReactClass = require(&#39;create-react-class&#39;);
var Example = createReactClass({
  render () {
    return (&amp;lt;View&amp;gt;&amp;lt;/View&amp;gt;);
  }
});

// ES6
import React, {Component} from &#39;React&#39;;
class Example extends Component {
  render () {
    return (&amp;lt;View&amp;gt;&amp;lt;/View&amp;gt;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置默认props&#34;&gt;设置默认props&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// ES5
getDefaultProps () {
  return {
    text: &amp;quot;This is default props&amp;quot;
  };
}

// ES6
static defaultProps = {
  text: &amp;quot;This is default props&amp;quot;
};
// 或
class MyProject extends Component {
  // ...
}
MyProject.defaultProps = {
  text: &amp;quot;This is default props&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置初始state&#34;&gt;设置初始state&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// ES5
getInitialState () {
  return {
    text: &amp;quot;This is initial state&amp;quot;
  };
}

// ES6
constructor (props) {
  super (props);
  this.state = {
    text: &amp;quot;This is initial state&amp;quot;
  };
}
&lt;/code&gt;&lt;/pre&gt;
">React Native篇---（四）组件的生命周期</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/T31psDuzV/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;状态机state&#34;&gt;状态机state&lt;/h2&gt;
&lt;h3 id=&#34;写法一&#34;&gt;写法一&lt;/h3&gt;
&lt;p&gt;状态机state是React框架中的一个重要概念，&lt;strong&gt;每种UI场景对应状态机的一种状态&lt;/strong&gt;。随着状态机变量的改变，UI场景也在重新渲染。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;export default class MyProject extends Component {
  constructor (props) {
    super(prpos);
    // 构造方法中，声明需要用到的状态机变量
    this.state = {
      textContent: &#39;&#39;
    };
  }
  
  // 更新状态机方法
  updateTextContent (newText) {
    // 使用setState函数更新状态机
    this.setState((state) =&amp;gt; {
      return {
        textContent: newText
      };
    });
  }
  
  // 渲染
  render () {
    return (
      &amp;lt;View&amp;gt;
        {/* onChangeText触发时调用箭头函数 */}
        &amp;lt;TextInput 
          onChangeText={(newText) =&amp;gt; this.updateTextContent(newText)} /&amp;gt;
        {/* 使用this.state.变量名的形式获取状态机的变量值 */}
        &amp;lt;Text&amp;gt;输入框内容：{this.state.textContent}&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，给TextInput组件的onChangeText绑定一个箭头回调函数（onChangeText的回调函数接受改变后的文本作为参数），箭头函数内部调用updateTextContent方法。&lt;/p&gt;
&lt;h3 id=&#34;写法二&#34;&gt;写法二&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;export default class MyProject extends Component {
  constructor (props) {
    ...
    // 前面不变，后面为增加代码
    this.updateTextContent = this.updateTextContent.bind(this);
  }
  
  // 保持不变
  updateTextContent (newText) {
    ...
  }
  
  render () {
    return (
      &amp;lt;View&amp;gt;
        {/* 改变部分 */}
        &amp;lt;TextInput onChangeText={this.updateTextContent} /&amp;gt;
        ...
      &amp;lt;/View&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，如果你想要使用this.updateTextContent作为onChangeText的回调函数，你需要在构造方法中结合this.updateTextContent = this.updateTextContent.bind(this)使用。那这条语句到底什么作用呢？我们来测试一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 如果不加上该语句，当输入框的内容变化时，会报错：this.setState is not a function。&lt;/p&gt;
&lt;p&gt;② 我们在不加上面那条语句的基础上，在updateTextContent中使用console.log输出this。打开Remote JS Debugging，改变输入框内容，输出为：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/react-native/3/1.png&#34; alt=&#34;结果1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可见，this包含allowFontScaling和onChangeText，可以推测出这个“this”代表TextInput组件。而TextInput组件是没有setState方法的，所以才会出现上面的报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;③ 加上那条语句，再次输出this，结果为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/react-native/3/2.png&#34; alt=&#34;结果2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在这，“this”代表RNApp。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;由此可知绑定操作是为了让回调函数能够正确的解析出this。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;写法三&#34;&gt;写法三&lt;/h3&gt;
&lt;p&gt;updateTextContent函数若使用箭头函数的形式定义，则不需要进行绑定操作。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;updateTextContent = (newText) =&amp;gt; {
  this.setState({
    textContent: newText
  });
}

render () {
  return (
    &amp;lt;View&amp;gt;
      &amp;lt;TextInput onChangeText={this.updateTextContent} /&amp;gt;
    &amp;lt;/View&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为JavaScript中每个普通函数都有自己的this值，而箭头函数会捕获其上下文的this值作为其自身的this值。&lt;em&gt;详细内容见&lt;a href=&#34;&#34;&gt;这篇文章&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;setstate函数&#34;&gt;setState函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;setState(partialState, callback); // callback为成功设置State后的回调函数，可选
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;updateTextContent (newText) {
  this.setState({
    textContent: newText
  }, () =&amp;gt; {
    console.log(&amp;quot;textContent has changed&amp;quot;);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以降低一个参数换为函数，其接受oldState作为参数，且需返回改变后的状态机变量，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;updateTextContent (newText) {
  this.setState((oldState) =&amp;gt; {
    console.log(oldState); // 输出为：textContent: &amp;quot;&amp;quot;
    return {
      textContent: newText
    };
  }, () =&amp;gt; {
    console.log(&amp;quot;textContent have changed.&amp;quot;);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;① 勿将上述代码中的回调函数写成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;onChangeText = {this.updateTextContent(newText)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this.updateTextContent代表函数，其值就是整个函数；而this.updateTextContent()表示执行函数，其值为执行函数后的返回值&lt;/p&gt;
&lt;p&gt;② 更新状态机变量时，勿使用this.state.var = value;形式，而应该使用this.setState方法进行更新。虽然从语法上来说this.state的方式是正确的，但从React原则是不合法的。读取状态机变量可直接使用this.state的形式。&lt;/p&gt;
&lt;p&gt;③ 尽量让自定义的组件不使用状态机变量，设计思路是：将多个无状态的组件封装在一个有状态的组件中，并把有状态的组件的状态机变量通过props传给无状态的组件。有状态的组件负责UI的交互逻辑，无状态的组件负责UI的渲染。&lt;/p&gt;
&lt;p&gt;④ 尽可能让UI中可变的数据来源是状态机变量与属性。&lt;/p&gt;
&lt;p&gt;⑤ 在状态机变量中存放与显示无关的变量，会导致React Native无必要地判断是否需要重新渲染UI，从而导致应用性能下降。&lt;/p&gt;
&lt;/blockquote&gt;
">React Native篇---（三）state</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/P1VyGpUUL/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;以下环境搭建以Mac系统为例，Windows大同小异。&lt;/p&gt;
&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h2&gt;
&lt;h3 id=&#34;1-安装node&#34;&gt;1、安装Node&lt;/h3&gt;
&lt;p&gt;首先需要安装Node，Mac下可以使用Homebrew（&lt;a href=&#34;https://brew.sh/index_zh-cn&#34;&gt;安装Homebrew传送门&lt;/a&gt;）进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以给npm设置淘宝镜像，可以加速国内下载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm config set registry https://registry.npm.taobao.org --global
npm config set disturl https://npm.taobao.org/dist --global
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-安装watchman&#34;&gt;2、安装watchman&lt;/h3&gt;
&lt;p&gt;watchman是Facebook的开源项目，用于监控、记录文件的改动情况。其安装与Node的安装类似，都是使用Homebrew进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install watchman
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-安装react-native命令行工具react-native-cli-yarn包管理工具&#34;&gt;3、安装React Native命令行工具(react-native-cli)、yarn包管理工具&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install -g react-native-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yarn是Facebook推出的包管理工具，可以加速node模块的下载，安装后即可使用yarn来替代npm命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install -g yarn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，也可以使用Homebrew来进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install yarn
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-安装jdk-android-studio和xcode&#34;&gt;4、安装JDK、Android Studio和Xcode&lt;/h3&gt;
&lt;p&gt;Android开发需要安装Java Development Kit、Android Studio。JDK的安装不赘述，需要注意的是Android Studio安装时需要选择以下几项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android SDK&lt;/li&gt;
&lt;li&gt;Android SDK Platform&lt;/li&gt;
&lt;li&gt;Performance (Intel ® HAXM)&lt;/li&gt;
&lt;li&gt;Android Virtual Device&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而iOS的开发需要用到mac系统，在mac系统下的App Store中搜索下载Xcode即可。&lt;/p&gt;
&lt;h2 id=&#34;项目初始化&#34;&gt;项目初始化&lt;/h2&gt;
&lt;p&gt;终端进入目标目录，使用下列命令初始化React Native项目MyProject：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;react-native init MyProject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令初始化一个最新版的React Native项目，但有时候我们需要初始化一个旧版本的React Native项目，这时可以使用rninit的工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 安装rninit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install -g rninit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 初始化指定版本的RN项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rninit init MyProject --source react-native@0.38.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，可以使用npm查看React Native的所有版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm view react-native versions -json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令初始化一个名为MyProject的、版本为0.38.0的React Native项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;android手机调试&#34;&gt;Android手机调试&lt;/h2&gt;
&lt;p&gt;使用真机进行调试，需要手机在“开发者选项”中打开“USB调试”，连接电脑后使用命令查看手机是否连接成功：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;adb devices
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果中有设备则连接成功，如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;List of devices attached
48a4deb2	device   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，可以将应用安装到手机：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;react-native run-android
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这条命令会下载相关依赖包（可能时间稍长），然后编译项目得到安装包，并将安装包安装到手机中（手机可能会有提示窗口询问是否安装，选择“是”即可）。&lt;/p&gt;
&lt;h2 id=&#34;ios手机调试&#34;&gt;iOS手机调试&lt;/h2&gt;
&lt;p&gt;本人没有iOS设备，所以使用虚拟机进行调试。&lt;/p&gt;
&lt;p&gt;① 使用Xcode打开：项目路径/ios/项目名.xcodeproj&lt;/p&gt;
&lt;p&gt;② 在Xcode中选择虚拟设备，点击运行便会打开对应的虚拟机，并安装项目应用。&lt;/p&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;① 项目运行中会打开一个新的命令行窗口launchPackager，并处于运行状态，&lt;strong&gt;请勿关闭它！&lt;/strong&gt;&lt;br&gt;
② 如果调试的手机中已经安装了项目软件（不是首次运行），再次进行调试时并不需要重新编译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，使用adb反向代理端口，将电脑的端口反向代理到测试机上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;adb -s 48a4deb2 reverse tcp:8081 tcp:8081 
# -s后接手机id（通过adb devices查看）
# 若电脑只连接了一个设备，可以省略-s参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，执行以下命令运行launchPackager：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;react-native start
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;③ 需要重新进行编译的情况：当项目中的android或ios目录下的文件发生改动、电脑分配的IP地址发生变化。&lt;br&gt;
④ 只改动外部的JS代码可以在App中打开菜单，选择“Reload”项进行更新。&lt;br&gt;
⑤ 在App的菜单中选择Remote JS Debugging便可以在电脑浏览器中查看控制台的输出内容。&lt;/p&gt;
">React Native篇---（二）环境搭建与项目初始化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/BB03rxJyG/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;virtual-dom&#34;&gt;Virtual DOM&lt;/h2&gt;
&lt;p&gt;在传统的前端开发中，我们在更新页面时是使用JavaScript直接操作DOM，而DOM操作的性能消耗是前端开发中最大的，并且代码也会变得难以维护。&lt;/p&gt;
&lt;p&gt;React引进了Virtual DOM，其将真实的DOM转化为JavaScript对象树，这将会带来以下优势：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 性能提升：每次数据更新后，重新计算Virtual DOM，并和上次的Virtual DOM做对比，对发生变化的部分做批量更新。&lt;/p&gt;
&lt;p&gt;② 方便与其他平台集成：例如React Native是基于Virtual DOM渲染出的原生控件，因为React组件可以映射为对应的原生控件。在输出时，具体是Web DOM、Android控件或iOS控件，由平台本身决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Virtual DOM，举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
  &amp;lt;button class=&amp;quot;btn&amp;quot;&amp;gt;提交&amp;lt;button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述HTML DOM可以转换为如下的JavaScript对象树：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: &#39;div&#39;,
  props: {
    children: {
      type: &#39;button&#39;,
      props: {
        className: &#39;btn&#39;,
        children: &#39;提交&#39;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为属性class、for在JavaScript中是保留字，因此，分别使用className、htmlFor进行替代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;jsx&#34;&gt;JSX&lt;/h2&gt;
&lt;p&gt;使用JavaScript对象树去描述真实的DOM是很贴切的，可是在上面的例子中，使用HTML只是一小段，转化为JavaScript对象树却是很冗长的代码。如果要描述更复杂的DOM呢？另外一方面，JavaScript对象树的可读性较差，没有HTML来的简单直接。JSX正是在这样的环境下应运而生，其是JavaScript和XML结合的一种格式。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const RegisterForm = () =&amp;gt; (
  &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;/reg&amp;quot; &amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userName&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;userPwd&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
  &amp;lt;/form&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，JSX将HTML代码直接加入到JavaScript中，通过翻译器转化为纯JavaScript再由浏览器执行。JSX类似于CoffeeScript，会在产品上线之前，打包编译为纯JavaScript代码。&lt;/p&gt;
&lt;h3 id=&#34;xml&#34;&gt;XML&lt;/h3&gt;
&lt;p&gt;JSX是使用的是类XML语法，在使用时需要注意的有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 定义标签时，只允许被一个标签包裹，如：&lt;code&gt;const Example = &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;会报错。&lt;/p&gt;
&lt;p&gt;② 标签一定要闭合，否则会报错，这和XML的语法一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;dom元素和组件元素&#34;&gt;DOM元素和组件元素&lt;/h3&gt;
&lt;p&gt;DOM元素是指HTML中的标签，例如：&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;组件元素是根据具体的功能将DOM元素组合在一起形成的元素，例如：&lt;code&gt;const Example = &amp;lt;div&amp;gt;&amp;lt;button&amp;gt;例子&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，Example就是一个组件元素，其可以在其他地方被使用：&lt;code&gt;&amp;lt;Example&amp;gt;&amp;lt;/Example&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;DOM元素的命名规范：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DOM元素的标签首字母为小写，组件元素的标签首字母为大写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;使用变量&#34;&gt;使用变量&lt;/h3&gt;
&lt;p&gt;在JSX中使用变量需要用{}将变量包裹住，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const Example = (param) =&amp;gt; (
  &amp;lt;div&amp;gt;{param}&amp;lt;/div&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;p&gt;在HTML中，注释使用&lt;code&gt;&amp;lt;!-- 注释 --&amp;gt;&lt;/code&gt;的形式，而在JSX中，使用&lt;code&gt;{/* 注释 */}&lt;/code&gt;作为注释。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const Example = (&amp;lt;div&amp;gt;{/* 这是注释 */}&amp;lt;/div&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以理解为，{}中为JavaScript代码，使用的是JavaScript注释方式。&lt;/p&gt;
&lt;h3 id=&#34;自定义属性&#34;&gt;自定义属性&lt;/h3&gt;
&lt;p&gt;在JSX中，往DOM元素中传入自定义属性会被忽略，不被渲染：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;&amp;lt;div cus=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要使用自定义属性，可以是加上data-前缀（与HTML一致）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;&amp;lt;div data-cus=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在自定义的标签中，任何属性都会被支持。&lt;/p&gt;
&lt;h3 id=&#34;转义字符&#34;&gt;转义字符&lt;/h3&gt;
&lt;p&gt;React会将显示到DOM的字符串进行转义，防止XSS。所以，如果在JSX中加入&lt;code&gt;&amp;amp;copy;&lt;/code&gt;并不会显示为©，如果需要使用特殊字符，可以使用一下方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 直接使用UTF-8的字符&lt;/p&gt;
&lt;p&gt;② 使用对应字符的Unicode编码&lt;/p&gt;
&lt;p&gt;③ 使用数组组装&lt;code&gt;&amp;lt;div&amp;gt;{[&#39;cc &#39;, &amp;lt;span&amp;gt;&amp;amp;copy;&amp;lt;/span&amp;gt;, &#39; 2018&#39;]}&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;④ 直接插入原始 的HTML&lt;/p&gt;
&lt;/blockquote&gt;
">React Native篇---（一）React简介</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/vjiIJ1__0/"" data-c="
          &lt;p&gt;箭头函数，ES6标准新增的一种函数语法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;定义方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let func1 = a =&amp;gt; a * 2;       // 单参数
let func2 = (a, b) =&amp;gt; a + b;  // 双参数
let func3 = a =&amp;gt; ({value: a});// 返回对象
let func4 = a =&amp;gt; {            // 包含函数体
  console.log(a);
  return a*2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;箭头函数与普通函数的区别&#34;&gt;箭头函数与普通函数的区别&lt;/h2&gt;
&lt;h3 id=&#34;1-this值&#34;&gt;1、this值&lt;/h3&gt;
&lt;p&gt;每个新定义的普通函数都有一个自己的this值，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  value: 0,
  func: function () {
    return function () {
      this.value += 1;
    }
  }
}

console.log(obj.value); // 0
obj.func()();
console.log(obj.value); // 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在ES5中，可以使用一个变量来传递this，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  value: 0,
  func: function () {
    var that = this;
    return function () {
      this.value += 1;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用bind函数来将this值传递给目标函数，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  value: 0,
  func: function () {
    return function () {
      this.value += 1;
    }
  }.bind(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而箭头函数会自动捕获上下文中的this值作为自身的this值，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  value: 0,
  func: function () {
    return function () {
      this.value += 1;
    }
  }
}

console.log(obj.value); // 0
obj.func()();
console.log(obj.value); // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-获取传递参数数组&#34;&gt;2、获取传递参数数组&lt;/h3&gt;
&lt;p&gt;普通函数使用arguments获取传入的参数数组，而箭头函数使用与PHP中一样的形式：...args来获取参数数组，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = function () {
  console.log(arguments);
}

var b = () =&amp;gt; {
  console.log(arguments);
}

var c = function (...agrs) {
  console.log(args);
}

var d = (...args) =&amp;gt; {
  console.log(args);
}

a(1,2,3,4,5);  // [Arguments] { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4, &#39;4&#39;: 5 }
b(1,2,3,4,5);  // 输出相关环境信息
c(1,2,3,4,5);  // 报错
d(1,2,3,4,5);  // [ 1, 2, 3, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-构造器&#34;&gt;3、构造器&lt;/h3&gt;
&lt;p&gt;箭头函数不能用于构造器，所以不能使用new来创建实例，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let A = function () {
  this.value = &amp;quot;A&amp;quot;;
}

let B = () =&amp;gt; {
  this.value = &amp;quot;B&amp;quot;;
}

let a = new A();
console.log(a.value); // A

let b= new B();  // 报错
console.log(b.value); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-原型属性&#34;&gt;4、原型属性&lt;/h3&gt;
&lt;p&gt;箭头函数没有原型属性&lt;/p&gt;
&lt;h3 id=&#34;5-作为对象方法出现&#34;&gt;5、作为对象方法出现&lt;/h3&gt;
&lt;p&gt;当作为对象的方法出现时，没有定义this绑定。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {
  value: 1,
  printValue: () =&amp;gt; {
    console.log(this.obj.value);
  },
  printValue2: function () {
    console.log(this.value);
  }
};

obj.printValue();   // undefined
obj.printValue2();  // 1
&lt;/code&gt;&lt;/pre&gt;
">箭头函数与普通函数的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/SChbXFUEf/"" data-c="
          &lt;p&gt;Promise是JavaScript社区针对异步编程提出的一套解决方案，现已被纳入ES6的标准中。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise拥有三个状态：未完成态(pending)、完成态(fulfilled)、失败态(rejected   )，其关系如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A(未完成态)--&amp;gt;B(完成态)
  A--&amp;gt;C(失败态)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;promise的使用&#34;&gt;Promise的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var promise = new Promise(function (resolve, reject) {
  if (成功) {
    resolve(result);
  } else {
    reject(error);
  }
});

promise.then((result) =&amp;gt; {
  console.log(&amp;quot;Success&amp;quot;);
}, (error) =&amp;gt; {
  console.log(&amp;quot;Error&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，第一段实例化Promise得到promise变量，其构造函数接受一个函数作为参数，该函数用于决定在何时调用成功或失败的回调函数。这个参数函数有两个参数：resolve、reject，分别是成功的回调函数、失败的回调函数。&lt;/p&gt;
&lt;p&gt;第二段代码中，使用Promise的成员方法then传入回调函数，其接受两个参数，分别为成功后的回调函数和失败后的回调函数（失败的回调函数为可选 ）。&lt;/p&gt;
&lt;p&gt;例如，读取一个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
var promise = new Promise((resolve, reject) =&amp;gt; {
  fs.readFile(&amp;quot;a.txt&amp;quot;, &amp;quot;utf8&amp;quot;, function (error, data) {
    if (error) {
      reject(error);
    } else {
      resolve(data);
    }
  });
});

promise.then((data) =&amp;gt; {
  console.log(data);
}, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promise的成员方法&#34;&gt;Promise的成员方法&lt;/h2&gt;
&lt;h3 id=&#34;then&#34;&gt;then()&lt;/h3&gt;
&lt;p&gt;前面的实例已经使用到了then方法，其接受两个参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;promise.then(resolve[, reject]);&lt;/p&gt;
&lt;p&gt;@param Function resolve: 成功回调函数&lt;br&gt;
@param Function reject: 失败回调函数]&lt;br&gt;
@return Promise 新的Promise实例，并不是原来的Promise实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;then方法的作用是向Promise实例中添加状态改变时的回调函数。&lt;/p&gt;
&lt;p&gt;因为then方法返回一个新的Promise实例，所以支持链式调用。&lt;/p&gt;
&lt;h3 id=&#34;catch&#34;&gt;catch()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;catch(callback)&lt;/p&gt;
&lt;p&gt;@param Function callback: 异步操作中发生错误时的回调函数&lt;br&gt;
@return Promise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;catch(callback)的实际就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;then(null, callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其用于指定发生错误时的回调函数。当Promise的状态变为resolved时，调用then方法传入的成功回调函数，当异步操作发生错误时，Promise的状态变为rejected时，调用catch传入的回调函数。另外，then方法指定的回调函数，如果在运行中抛出错误，也会被catch方法捕获。&lt;/p&gt;
&lt;h3 id=&#34;finally&#34;&gt;finally()&lt;/h3&gt;
&lt;p&gt;finally方法中的代码不管最后Promise对象是什么状态都会执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;finally(callback)&lt;/p&gt;
&lt;p&gt;@param Function callback: 回调函数&lt;br&gt;
@return Promise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其底层代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&amp;gt; P.resolve(callback()).then(() =&amp;gt; value),
    reason =&amp;gt; P.resolve(callback()).then(() =&amp;gt; { throw reason })
  );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见，finally也是通过then方法实现的。&lt;/p&gt;
&lt;h3 id=&#34;all&#34;&gt;all()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;all(promiseArray)&lt;/p&gt;
&lt;p&gt;@param Array promiseArray: Promise对象数组&lt;br&gt;
@return Promise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只有当Promise数组中的所有实例的状态都变为resolved时，或者其中一个变为rejected时，才会执行回调函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var firstPromise = new Promise((resolve, reject) =&amp;gt; {
    var res1 = 1;
    console.log(&amp;quot;res1:&amp;quot;, res1);
    return Promise.resolve(res1);
});

var secondPromise = new Promise((resolve, reject) =&amp;gt; {
    var res2 = 2;
    console.log(&amp;quot;res2:&amp;quot;, res2);
    return Promise.resolve(res2);
});

Promise.all([firstPromise, secondPromise])
    .then(([res1, res2]) =&amp;gt; {
        console.log(res1);
        console.log(res2);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，当firstPromise和secondPromise的状态全部都为resolved时，执行后面的成功回调，当任意一个对象的状态为rejected时，执行后面的失败回调。&lt;/p&gt;
&lt;h3 id=&#34;race&#34;&gt;race()&lt;/h3&gt;
&lt;p&gt;与all方法一样，race方法接受一个Promise数组作为参数，与all不同的是，当race的参数数组中任意一个Promise对象的状态变为resolved时，后续回调执行。&lt;/p&gt;
&lt;h3 id=&#34;promiseresolve&#34;&gt;Promise.resolve()&lt;/h3&gt;
&lt;p&gt;Promise.resolve()可以将现有对象转化为Promise对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Promise.resolve(params);
// 等价于
new Promise(params =&amp;gt; resolve(params));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-参数为thenable对象&#34;&gt;1、参数为thenable对象&lt;/h4&gt;
&lt;p&gt;thenable对象是指具有then方法的对象，Promise.resolve()会将该对象转化为Promise对象，然后立即执行该对象中的then方法，对象的状态就变为resolved。&lt;/p&gt;
&lt;h4 id=&#34;2-参数为promise实例&#34;&gt;2、参数为Promise实例&lt;/h4&gt;
&lt;p&gt;如果参数是一个Promise实例，Promise.resolve()将直接返回这个实例。&lt;/p&gt;
&lt;h4 id=&#34;3-参数为其他值&#34;&gt;3、参数为其他值&lt;/h4&gt;
&lt;p&gt;参数作为成功回调函数的参数，返回一个状态为resolved的Promise对象&lt;/p&gt;
&lt;h4 id=&#34;4-无参数&#34;&gt;4、无参数&lt;/h4&gt;
&lt;p&gt;只返回一个resolved状态的Promise对象&lt;/p&gt;
&lt;h3 id=&#34;promisereject&#34;&gt;Promise.reject()&lt;/h3&gt;
&lt;p&gt;返回一个rejected状态的Promise对象，参数作为后续方法的参数。&lt;/p&gt;
">Node篇---（四）Promise</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/84d3iUMFT/"" data-c="
          &lt;p&gt;异步编程很好用，但在很多时候也会因为与我们的思维方式不一致而产生一些问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-异常处理的捕获&#34;&gt;1、异常处理的捕获&lt;/h2&gt;
&lt;p&gt;在介绍这个之前，我们需要了解Node的时间循环机制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;循环机制：Node进程在启动时会创建一个循环，每次循环都会检查是否有待处理事件，若存在就执行相对应的回调函数。每一次循环称为一个&lt;strong&gt;Tick&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，进入主题。&lt;br&gt;
在PHP或者Java中，我们常会用try、catch、finally等来捕获异常，因此，我么很有可能会写出以下的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;try {
  someFunction(function(){
    // 回调函数的具体实现
  });
} catch (e) {
  console.log(e.getMessage());
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但实际上，在调用someFunction()方法后，回调函数会被保存起来，直至下一个Tick才会被执行，而try/catch只能捕获当前Tick内的异常。&lt;/p&gt;
&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;Node约定将异常作为回调函数的第一个参数传回，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;someFunction(function (error, result) {
  if (error) {
    // 出现异常
  } else {
    // 正常执行
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果存在异常，error为具体的异常；如果正常执行，没有异常，error则为null。&lt;/p&gt;
&lt;h2 id=&#34;2-不能阻塞代码&#34;&gt;2、不能阻塞代码&lt;/h2&gt;
&lt;p&gt;在JavaScript中，没有提供sleep()线程沉睡功能的函数，只有setInterval()和setTimeout()这两个延时执行的函数，且不会阻塞后续代码的执行。&lt;/p&gt;
&lt;h4 id=&#34;解决方案-2&#34;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;当需要用到阻塞时，考虑用setTimeout去实现😂。&lt;/p&gt;
&lt;h2 id=&#34;3-多线程编程&#34;&gt;3、多线程编程&lt;/h2&gt;
&lt;p&gt;Node属于单线程的编程语言，一个Node进程不能充分利用多核CPU的资源，而复杂的业务逻辑往往要求需要很好的利用多核CPU以提供更多的计算服务。&lt;/p&gt;
&lt;h4 id=&#34;解决方案-3&#34;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;当需要充分利用多核CPU时，可以参考Web Worker的实现，即Mater-Worker模型，通过Master创建工作线程，使用子线程去计算，以充分利用CPU资源。&lt;/p&gt;
&lt;p&gt;在Node中，我们可以使用Node的child_process的API去进行相关的需求实现。&lt;/p&gt;
&lt;h2 id=&#34;4-嵌套问题&#34;&gt;4、}}}}}嵌套问题&lt;/h2&gt;
&lt;h3 id=&#34;1-无顺序-a-b全部完成-c&#34;&gt;① 无顺序 ((A、B全部完成)-&amp;gt;C)&lt;/h3&gt;
&lt;p&gt;多个操作存在先后依赖关系，执行C需要A、B过程的结果（虽然A、B之间并不存在依赖关系，但C的执行A、B的结果缺一不可）。如图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;
graph LR;
    A--结果1--&amp;gt;C;
    B--结果2--&amp;gt;C;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在同步编程中，我们是这样做的（PHP）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$result1 = A();
$result2 = B();
$result = C($result1, $result2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在JavaScript中是使用异步编程的，通过回调函数来执行后续操作，而且A、B、C三个回调函数的执行并不存在顺序关系，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;A(callbackA);
B(callbackB);
C(callbackC);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，callbackA、callbackB、callbackC的执行顺序是不固定的，我们不能保证C在A、B之后执行。&lt;br&gt;
那如何实现这个需求呢？&lt;br&gt;
我们可以使用函数嵌套将整个执行过程串行化，将上面的代码调整下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;A(function (result1) {
  B(function (result2) {
    C(function (result) {
      // ...
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样确实可以实现目标需求，但却出现了}}}}}嵌套问题，也称为恶魔金字塔，过多的嵌套让代码显得很难看，不优雅。而且，上述整个过程的执行时间为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A的耗时 + B的耗时 + C的耗时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;解决方案1&#34;&gt;解决方案1&lt;/h4&gt;
&lt;p&gt;如何更好地处理这个呢？使用变量进行计数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var count = 0;
var results = {};
var done = function (key, value) {
  results[key] = value;
  count++;
  if (count === 2) { // A, B两次
    C(results);
  }
}

// 在A、B的回调函数中调用done
A(function (data) {
  done(&#39;A&#39;, data);
});
B(function (data) {
  done(&#39;B&#39;, data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以避免使用嵌套，同时还能降低耗时，上述代码的总执行时间为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;max(A的耗时, B的耗时) + C的耗时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;优化&#34;&gt;优化&lt;/h5&gt;
&lt;p&gt;上述代码还可以用偏函数、事件发布/订阅模式进行优化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;偏函数&lt;/strong&gt;：用于生成已预置参数或变量的函数的函数，首先它是一个函数，其作用是生成参数或变量已预置的函数。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var add = function (a, b) {
  return a + b;
}
var add_1 = function (num) { // 将add()函数的参数预置为1，得到加1函数
  return add(num, 1);
}
var sub_1 = function (num) { // 将add()函数的参数预置为-1，得到减1函数
  return add(num, -1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;事件发布/订阅模式&lt;/strong&gt;：在JavaScript中很常见，对应的就是触发事件/监听事件，在Node中的具体实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 订阅
emitter.on(&amp;quot;eventName&amp;quot;, function (param1, param2) {
  console.log(param1, param2);
  // console.log(arguments); // arguments为传入的参数数组
});
// 发布
emitter.emit(&amp;quot;eventName&amp;quot;, &amp;quot;This is param1&amp;quot;, &amp;quot;This is param2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;PHP中获取参数：function test(...$args) {}或使用函数func_get_args、func_get_arg、func_num_args&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化后的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 偏函数
var after = function (times, callback) {
  var count = 0;
  var results = {};
  return function (key, value) {
    results[key] = value;
    count++;
    if (count === times) {
       callback(results);
    }
  }
}

var done = after(2, C);
emitter.on(&amp;quot;done&amp;quot;, done);  // 添加监听事件

A(function (data) {
  emitter.emit(&amp;quot;done&amp;quot;, &amp;quot;A&amp;quot;, data);  // 触发done事件，并将结果传回
});
B(function (data) {
  emitter.emit(&amp;quot;done&amp;quot;, &amp;quot;B&amp;quot;, data);  // 触发done事件，并将结果传回
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;解决方案2&#34;&gt;解决方案2&lt;/h4&gt;
&lt;p&gt;使用EventProxy模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const EventProxy = require(&amp;quot;eventproxy&amp;quot;);
var proxy = new EventProxy();

// 使用all监听event1、event2事件，当两个事件都完成时，调用C回调函数。
proxy.all(&amp;quot;event1&amp;quot;, &amp;quot;event2&amp;quot;, C); 

A(function (result1) {
  // 触发event1事件
  proxy.emit(&amp;quot;event1&amp;quot;, &amp;quot;This is event1 argument&amp;quot;, result1);
});
B(function (result2) {
  // 触发event2事件
  proxy.emit(&amp;quot;event2&amp;quot;, &amp;quot;This is event2 argument&amp;quot;, result2);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EventProxy在每一次触发非all事件时，都会触发一次all事件。&lt;/p&gt;
&lt;h4 id=&#34;解决方案3&#34;&gt;解决方案3&lt;/h4&gt;
&lt;p&gt;使用Promise（后续介绍）&lt;/p&gt;
&lt;h3 id=&#34;2-有顺序a-b-c&#34;&gt;② 有顺序（A-&amp;gt;B-&amp;gt;C）&lt;/h3&gt;
&lt;p&gt;C依赖于B，B依赖于A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;
graph LR;
    A--结果1--&amp;gt;B;
    B--结果2--&amp;gt;C;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况也能通过函数嵌套来将整个过程串行化，从而实现该需求，时间消耗为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A的耗时 + B的耗时 + C的耗时&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;解决方案-4&#34;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;因为这种情况存在先后依赖关系，所以耗时不能进行优化，只能优化代码的函数嵌套问题。&lt;br&gt;
同样可以使用Promise进行优化（后续介绍）&lt;/p&gt;
">Node篇---（三）异步编程的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/qWQnQmCU3/"" data-c="
          &lt;p&gt;随着前端功能的增多，JavaScript的文件数量和复杂度也不断提升，使用script标签引入js代码显得无力、混乱，而在其他高级语言中都有类似模块的概念（PHP有include、require，Java有包、类文件）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-javascript的模块规范&#34;&gt;1、JavaScript的模块规范&lt;/h2&gt;
&lt;p&gt;JavaScript在强大的社区力量下，也出现了很多模块规范：CommonJS、AMD、ES6 Module等。&lt;/p&gt;
&lt;h3 id=&#34;amd&#34;&gt;AMD&lt;/h3&gt;
&lt;p&gt;特点：异步加载&lt;br&gt;
具体实现：requireJS&lt;br&gt;
模块定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// test1.js
define(function () {
  return {
    name: &#39;Alan&#39;,
    age: 18
  };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// test2.js
require([&#39;./test1.js&#39;], function (moduleName) {
  console.log(moduleName.name);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;es6-module&#34;&gt;ES6 Module&lt;/h3&gt;
&lt;p&gt;特点：按需加载（编译时加载）&lt;br&gt;
具体实现：ES6最新语法&lt;br&gt;
模块定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// a.js
export function test1() {
  console.log(&amp;quot;This is function test1&amp;quot;);
}
export function test2() {
  console.log(&amp;quot;This is function test2&amp;quot;);
}
export default function test3() {
  console.log(&amp;quot;This is default function test3&amp;quot;);
}
// export default表示默认导出，在import引用时可以指定任意名称
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {test1, test2} from &#39;./a&#39;;

test1();
test2();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 导入默认模块（可为模块指定任意名称）
import test from &#39;./a&#39;;

test();  // 输出This is default function test3
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;① import具有提升效果，会提升到整个模块的头部，因为import是在编译阶段执行；&lt;/p&gt;
&lt;p&gt;② export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var name = &#39;Alan&#39;;
// export name; // 错误
// export &#39;Alan&#39;; // 错误
export {name};  // 正确

export var name = &#39;Alan&#39;; // 正确

function test() {
  console.log(&amp;quot;This is test&amp;quot;);
}

// export test; // 错误
export {test}; // 正确

export function test() {} // 正确
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h3&gt;
&lt;p&gt;特点：&lt;br&gt;
① 模块在第一次加载时运行一次，然后将结果放到缓存中，以后加载直接读取缓存结果。&lt;br&gt;
② 同步加载。&lt;br&gt;
具体实现：NodeJS&lt;br&gt;
模块定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// a.js
exports.test1 = function () {
  console.log(&#39;This is function test1&#39;);
}
module.exports.test2 = function () {
  console.log(&amp;quot;This is function test2&amp;quot;);
}
// module.exports与exports等效
// exports只是module.exports的一个引用
// Node为每个模块都提供一个变量exports，指向module.exports
// 可以理解为在每个模块的头部隐藏了一行代码：var exports = module.exports;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var moduleName = require(&#39;./a&#39;); // 模块使用小驼峰命名规则，可不加文件后缀.js
moduleName.test();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-node的模块实现&#34;&gt;2、Node的模块实现&lt;/h2&gt;
&lt;p&gt;Node模块是参照CommonJS规范实现的，并对其进行了一定的取舍，并不是完全按照其规范实现的。&lt;br&gt;
在Node中引入模块的过程分为三个阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 路径分析：核心模块、相对路径文件模块、绝对路径文件模块、非路径形式的文件模块&lt;/p&gt;
&lt;p&gt;（当前目录下的node_module、父目录下的node_module、父目录的父目录下的node_module...）&lt;/p&gt;
&lt;p&gt;② 文件定位：当模块标识符不包含文件扩展名时，Node会按.js、.json、.node的次序补全，依次尝试&lt;/p&gt;
&lt;p&gt;（如果是.node或.json文件，带上扩展名性能会更好）&lt;/p&gt;
&lt;p&gt;③ 编译执行&lt;/p&gt;
&lt;p&gt;注意：Node的核心模块已被编译为二进制文件，因此文件定位和编译执行省略，而文件模块（用户编写的模块）则需要经历全部过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-cc模块&#34;&gt;3、C/C++模块&lt;/h2&gt;
&lt;p&gt;C/C++模块在不同平台的编译和加载过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB;
  subgraph Linux
  A(C/C++源码)--&amp;gt;B(g++/gcc) 
  B--编译源码--&amp;gt;C(.so文件)
  C--生成.node文件--&amp;gt;D(加载.so文件)
  D--dlopen加载--&amp;gt;E(导出给JavaScript)
  end
  
  subgraph Windows
  F(C/C++源码)--&amp;gt;G(VC++) 
  G--编译源码--&amp;gt;H(.dll文件)
  H--生成.node文件--&amp;gt;I(加载.dll文件)
  I--dlopen加载--&amp;gt;J(导出给JavaScript)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;注意：Linux和Windows下的.node文件不一样。实际上，在Windows上，它是.dll文件，在Linux上是.so文件。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-npm&#34;&gt;4、NPM&lt;/h2&gt;
&lt;p&gt;NPM(Node Package Manager)，Node包管理器，类似于PHP中的composer，可以让用户快速安装和管理依赖包。&lt;/p&gt;
&lt;h3 id=&#34;安装依赖包&#34;&gt;安装依赖包&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install PackageName # 如: npm install express
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令会在当前目录下创建node_module文件夹，然后在node_module下创建相应的包目录（如：安装express时创建express文件夹），最后将包解压到这个包目录下。使用时用require(&#39;PackageName&#39;)即可引入该包。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;注意：-g全局安装是指将一个包安装为全局可用的可执行命令，如：npm install es-checker -g安装完成后可以使用es-checker命令检测本地Node对es6的支持程度&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;从非官方源安装&#34;&gt;从非官方源安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从非官方源安装包
npm install PackageName --registry=http://registry.url
# 设置默认源
npm config set registry http://registry.url
&lt;/code&gt;&lt;/pre&gt;
">Node篇---（二）模块</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/JYJs07YkE/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;1-异步io&#34;&gt;1、异步I/O&lt;/h2&gt;
&lt;p&gt;异步在前端JavaScript是很常见的，例如使用JQuery发起ajax请求：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$.ajax({
  url: &#39;/url&#39;,
  data: {},
  type: post,
  dataType: json,
  success: function (data) {
    console.log(&#39;数据请求成功：&#39;, data);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异步I/O相对于同步I/O来说，其优势在于可以大大缩短多个I/O需要的时间，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let fs = require(&#39;fs&#39;);

fs.readFile(&#39;./file1&#39;, function (error, file) {
  console.log(&#39;file1读取完成&#39;);
});
fs.readFile(&#39;./file2&#39;, funciton (error, file) {
  console.log(&#39;file2读取完成&#39;);
});
// 这段脚本的耗时取决于两个文件之间读取耗时最多的那个
// 而在同步I/O中，相同功能的脚本耗时为两个文件读取耗时之和
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此可见异步I/O的优势是很大的。&lt;/p&gt;
&lt;h2 id=&#34;2-单线程&#34;&gt;2、单线程&lt;/h2&gt;
&lt;p&gt;Node是单线程的，不用像多线程编程一样在意状态的同步问题，也无法像多线程一样利用多核的CPU。&lt;/p&gt;
&lt;p&gt;另外的问题在于，大量计算占用CPU将导致无法继续调用异步I/O。在Node中的解决方案是通过使用Master-Worker模型，将大量计算拆分为小量的计算，并分发给工作线程进行处理。&lt;/p&gt;
&lt;h2 id=&#34;3-跨平台&#34;&gt;3、跨平台&lt;/h2&gt;
&lt;p&gt;Node在操作系统之上搭建了一层平台层---libuv，其与不同的操作系统进行交互，向上层的Node模块提供统一的接口，如图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB;
  A[Node.js]--&amp;gt;B[libuv]
  B--&amp;gt;C[Linux或Unix]
  B--&amp;gt;D[Windows]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-cc扩展&#34;&gt;4、C/C++扩展&lt;/h2&gt;
&lt;p&gt;在Node中，可以像PHP一样，通过C/C++编写Node扩展，来提高性能。&lt;/p&gt;
">Node篇---（一）特点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/nQ_auU4ob/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;Nginx的配置结构大致如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;events {
  use epoll;
}

http {
  #http
  server {
    listen 80;
    ...
    
    location / {
        if() {
          ...
        }
    }
    ...
  }
  
  #https
  server {
    listen 443;
    ...
  }
  
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一-location规则&#34;&gt;一、location规则&lt;/h2&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location [ = | ^~ | ~ | ~* | / ] [字符串 | 正则表达式] {
    [相关处理]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;① = 表示精确匹配，例如：location = / {...}表示只匹配根目录的请求，后加字符串的不能匹配&lt;/li&gt;
&lt;li&gt;② ^~ 表示匹配URI以常规字符串开头的请求，不是正则匹配，例如：location ^~ /home {...}只能匹配/home/index、/home/other/other等以其开头的请求&lt;/li&gt;
&lt;li&gt;③ ~ 表示区分大小写的正则匹配&lt;/li&gt;
&lt;li&gt;④ ~* 表示不区分大小写的正则匹配&lt;/li&gt;
&lt;li&gt;⑤ / 表示通用匹配，任何请求都会匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先级：(location =) &amp;gt; (location 完整路径) &amp;gt; (location ^~) &amp;gt; (location &lt;sub&gt;,&lt;/sub&gt;*) &amp;gt; (location 部分起始路径) &amp;gt; (location /)&lt;/p&gt;
&lt;h2 id=&#34;二-rewrite规则&#34;&gt;二、rewrite规则&lt;/h2&gt;
&lt;p&gt;作用：使用nginx的全局变量及自定义变量实现URL的重写及重定向（放在server、location、if中）。&lt;/p&gt;
&lt;p&gt;rewrite和location具有相似之处，其区别在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;location主要用于访问控制、反向代理&lt;br&gt;
rewrite主要用于实现URL的重写、跳转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;rewrite规则格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;rewrite 正则表达式 目标URL 标志位;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server {
  rewrite /(.*)$ /index.php/$1 last; # 隐藏URL中的index.php

  location ~ (.*)/index\.php$ {
    ...
  }
}
# http://www.xxxx.com/home/controller/action/param请求到来
# ① server中的rewrite匹配到该请求，并将URL重写为http://www.xxxx.com/index.php/home/controller/action/param
# ② location匹配到重写后的URL（http://www.xxxx.com/index.php/home/controller/action/param），执行location中的操作
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1-标志位&#34;&gt;1、标志位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;① last 表示完成rewrite&lt;/li&gt;
&lt;li&gt;② break 表示停止当前虚拟主机的后续rewrite指令&lt;/li&gt;
&lt;li&gt;③ redirect 表示返回302临时重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;li&gt;④ permanent 表示返回301永久重定向，地址栏显示跳转后的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-if指令&#34;&gt;2、if指令&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;if(condition) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;① 判断是否相等使用 = 或 !=&lt;/li&gt;
&lt;li&gt;② ~ 正则表达式匹配，~* 不区分大小写的匹配，!~ 区分大小写的不匹配&lt;/li&gt;
&lt;li&gt;③ -f 和 !-f 用于判断是否存在文件&lt;/li&gt;
&lt;li&gt;④ -d 和 !-d 用来判断是否存在目录&lt;/li&gt;
&lt;li&gt;⑤ -e 和 !-e 用来判断是否存在文件或目录&lt;/li&gt;
&lt;li&gt;⑥ -x 和 !-x 用来判断文件是否可执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if使用用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;if ($http_user_agent ~ MSIE) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-nginx全局变量&#34;&gt;3、Nginx全局变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;这&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;等&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;于&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;请&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;求&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;同&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;args：这个变量等于请求行中的参数，同&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;这&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;等&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;于&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;请&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;求&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;query_string&lt;/li&gt;
&lt;li&gt;$content_length：请求头中的Content-length字段。&lt;/li&gt;
&lt;li&gt;$content_type：请求头中的Content-Type字段。&lt;/li&gt;
&lt;li&gt;$document_root：当前请求在root指令中指定的值。&lt;/li&gt;
&lt;li&gt;$host：请求主机头字段，否则为服务器名称。&lt;/li&gt;
&lt;li&gt;$http_user_agent：客户端agent信息&lt;/li&gt;
&lt;li&gt;$http_cookie：客户端cookie信息&lt;/li&gt;
&lt;li&gt;$limit_rate：这个变量可以限制连接速率。&lt;/li&gt;
&lt;li&gt;$request_method：客户端请求的动作，通常为GET或POST。&lt;/li&gt;
&lt;li&gt;$remote_addr：客户端的IP地址。&lt;/li&gt;
&lt;li&gt;$remote_port：客户端的端口。&lt;/li&gt;
&lt;li&gt;$remote_user：已经经过Auth Basic Module验证的用户名。&lt;/li&gt;
&lt;li&gt;$request_filename：当前请求的文件路径，由root或alias指令与URI请求生成。&lt;/li&gt;
&lt;li&gt;$scheme：HTTP方法（如http，https）。&lt;/li&gt;
&lt;li&gt;$server_protocol：请求使用的协议，通常是HTTP/1.0或HTTP/1.1。&lt;/li&gt;
&lt;li&gt;$server_addr：服务器地址，在完成一次系统调用后可以确定这个值。&lt;/li&gt;
&lt;li&gt;$server_name：服务器名称。&lt;/li&gt;
&lt;li&gt;$server_port：请求到达服务器的端口号。&lt;/li&gt;
&lt;li&gt;$request_uri：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;不&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;带&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;请&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;求&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;当&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;前&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;uri：不带请求参数的当前URI，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;不&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;带&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;请&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;求&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;当&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;前&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;uri不包含主机名，如”/foo/bar.html”。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;与&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;document_uri：与&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;与&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;uri相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-upstream模块与负载均衡&#34;&gt;三、upstream模块与负载均衡&lt;/h2&gt;
&lt;p&gt;Nginx的反向代理是其出色的特点之一，通过反向代理可以实现负载均衡，将请求分发到其他服务器。而upstream节点就是配置反向代理的关键所在。&lt;/p&gt;
&lt;h3 id=&#34;配置步骤&#34;&gt;配置步骤&lt;/h3&gt;
&lt;p&gt;① 在http节点下加入upstream节点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName {
    server ip1:port1;
    server ip2:port2;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 在server节点下的location节点中，将相应的请求通过proxy_pass转发到http://upstreamName下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location / {
    ...
    proxy_pass http://upstreamName;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，负载均衡已经配置完毕，Nginx会根据轮询的策略将请求按时间顺序逐一分配到不同的后端服务器上。&lt;/p&gt;
&lt;p&gt;当然，还存在其他的分配策略。&lt;/p&gt;
&lt;h3 id=&#34;请求分配策略&#34;&gt;请求分配策略&lt;/h3&gt;
&lt;h4 id=&#34;1-轮询&#34;&gt;① 轮询&lt;/h4&gt;
&lt;p&gt;默认情况下，Nginx使用轮询的方式进行请求的分配，这种方式虽然配置简单，但缺点在于可靠性不高、请求分发不均衡。&lt;/p&gt;
&lt;h4 id=&#34;2-weight权重&#34;&gt;② weight权重&lt;/h4&gt;
&lt;p&gt;在upstream节点中指定server的weight权重，Nginx会根据每个服务器的权重调整分发请求的几率，weight与分发请求的几率成正比，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName{
    server ip1:port1 weight=1;
    server ip2:port2 weight=2;
    # 转发请求给ip2服务器的几率是转发给ip1服务器的两倍
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-ip_hash&#34;&gt;③ ip_hash&lt;/h4&gt;
&lt;p&gt;每个请求都按照访问ip的hash结果进行分配，即访问ip与服务器绑定，同一个用户的请求都会固定转发到一台服务器上进行处理（该方法可以用于解决分布式session不一致的问题）。使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName{
    ip_hash;
    server ip1:port1;
    server ip2:port2;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-fair&#34;&gt;④ fair&lt;/h4&gt;
&lt;p&gt;使用后端服务器的响应时间作为依据，响应时间短的服务器分配到更多的请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName{
    fair;
    server ip1:port1;
    server ip2:port2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-url_hash&#34;&gt;⑤ url_hash&lt;/h3&gt;
&lt;p&gt;通过访问url的hash结果来分配请求，让url定向到同一个后端服务器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName{
    server ip1:port1;
    server ip2:port2;
    hash $request_uri;  
    hash_method crc32;  # 计算hash时使用的hash算法
    ### 使用hash后，不能使用weight等其他参数
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;状态值&#34;&gt;状态值&lt;/h3&gt;
&lt;p&gt;upstream节点中，可以为每一个设备设置状态值，如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;down: 表示当前的server不参与负载均衡&lt;br&gt;
weight: weight越大，收到的请求就越多&lt;br&gt;
max_fails: 允许请求失败的最大次数，当超过该值时，返回proxy_next_upstream模块定义的错误&lt;br&gt;
fail_timeout: 达到max_fails次失败时，暂停的时间&lt;br&gt;
backup: 后备服务器，当其他全部的非backup机器down或者忙的时候，请求backup机器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;upstream upstreamName{
    server ip1:port1 down;
    server ip2:port2 weight=2;
    server ip3:port3 backup;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分布式系统session的处理方法&#34;&gt;分布式系统session的处理方法&lt;/h3&gt;
&lt;p&gt;① session复制：当某一台服务器的session发生改变时，将session的改变复制到其他所有服务器上（毫无疑问，该方法的性能较低）&lt;br&gt;
② 请求ip与服务器绑定：客户端的ip与服务器绑定在一起，同一用户的请求都转发到同一台机器上进行处理&lt;br&gt;
③ 将session信息存放在MySQL等数据库中&lt;br&gt;
④ 将session存放在Redis、memcached内存数据库中&lt;/p&gt;
&lt;h2 id=&#34;四-events事件模型-阻塞非阻塞和同步异步&#34;&gt;四、Events事件模型、阻塞/非阻塞和同步/异步&lt;/h2&gt;
&lt;p&gt;Nginx的I/O模型包括标准事件模型、高效事件模型。&lt;/p&gt;
&lt;h3 id=&#34;阻塞非阻塞与同步异步&#34;&gt;阻塞/非阻塞与同步/异步&lt;/h3&gt;
&lt;p&gt;我相信有很大一部分人会把非阻塞I/O和异步I/O混为一谈，因为我在写这篇博客之前也是这么认为的。&lt;/p&gt;
&lt;h4 id=&#34;阻塞io-非阻塞io&#34;&gt;阻塞I/O、非阻塞I/O&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;阻塞I/O：应用程序需要等待I/O完成后才返回结果，阻塞I/O造成CPU等待I/O，CPU的能力不能得到充分利用。&lt;br&gt;
非阻塞I/O：在调用后直接返回，不等待I/O完成，但之后需要使用轮询或者其他事件模型（select、poll、epoll、kqueue）来判断是否完成I/O，若I/O完成，则执行后续操作。&lt;br&gt;
在非阻塞I/O返回后，CPU的时间片可以用来处理其他事务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;同步io-异步io&#34;&gt;同步I/O、异步I/O&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;同步I/O：导致请求进程阻塞，直到I/O操作完成；&lt;br&gt;
异步I/O：不导致请求进程阻塞，I/O完成发出通知&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;关系&#34;&gt;关系&lt;/h4&gt;
&lt;p&gt;阻塞I/O、非阻塞I/O都属于同步I/O，用知乎的一个回答来说明吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;作者：愚抄&lt;/em&gt;&lt;br&gt;
&lt;em&gt;链接：https://www.zhihu.com/question/19732473/answer/23434554&lt;/em&gt;&lt;br&gt;
&lt;em&gt;来源：知乎&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;老张爱喝茶，废话不说，煮开水。&lt;br&gt;
出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。&lt;/p&gt;
&lt;p&gt;1 老张把水壶放到火上，立等水开。（同步阻塞）&lt;br&gt;
老张觉得自己有点傻&lt;br&gt;
2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）&lt;br&gt;
老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。&lt;br&gt;
3 老张把响水壶放到火上，立等水开。（异步阻塞）&lt;br&gt;
老张觉得这样傻等意义不大&lt;br&gt;
4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）&lt;br&gt;
老张觉得自己聪明了。&lt;/p&gt;
&lt;p&gt;所谓同步异步，只是对于水壶而言。&lt;br&gt;
普通水壶，同步；响水壶，异步。&lt;br&gt;
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。&lt;/p&gt;
&lt;p&gt;所谓阻塞非阻塞，仅仅对于老张而言。&lt;br&gt;
立等的老张，阻塞；看电视的老张，非阻塞。&lt;br&gt;
情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。&lt;br&gt;
——来源网络，作者不明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;标准事件模型&#34;&gt;标准事件模型&lt;/h3&gt;
&lt;p&gt;如果当前系统不存在更高效的方法，则使用标准事件模型select或poll&lt;/p&gt;
&lt;h4 id=&#34;read&#34;&gt;read&lt;/h4&gt;
&lt;p&gt;read是最原始、最低效的事件模型。其通过重复调用来检查I/O状态，即轮询。&lt;/p&gt;
&lt;h4 id=&#34;select&#34;&gt;select&lt;/h4&gt;
&lt;p&gt;select是read的改进版，它通过轮询监视文件描述符集合，来获取发生变化的文件描述符（集合中的文件描述符会被内核进行标志位修改）。&lt;br&gt;
缺点：① 文件描述符的数量具有限制；② 当文件描述符数量增多时，采取轮询的性能会降低；&lt;/p&gt;
&lt;h4 id=&#34;poll&#34;&gt;poll&lt;/h4&gt;
&lt;p&gt;poll的处理机制与select类似，区别在于poll使用链表，而不是数组，避免了长度限制。但文件描述符较多时，性能还是十分低下。&lt;/p&gt;
&lt;h3 id=&#34;高效事件模型&#34;&gt;高效事件模型&lt;/h3&gt;
&lt;h4 id=&#34;epoll&#34;&gt;Epoll&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;使用于Linux内核2.6版本及以后的系统&lt;/em&gt;&lt;br&gt;
相对于poll，epoll只会处理发生改变的文件描述符，这样避免了不必要的事件处理，提升了性能及效率。&lt;/p&gt;
&lt;h4 id=&#34;kqueue&#34;&gt;Kqueue&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X&lt;/em&gt;&lt;br&gt;
实现方式与epoll类似，不过它仅在FreeBSD系统下存在。&lt;/p&gt;
&lt;h2 id=&#34;五-nginx配置文件-注释&#34;&gt;五、Nginx配置文件 + 注释&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# Nginx的用户和组
user www www;

# 工作进程的数目
worker_processes auto;

# 错误日志存放位置，格式为：error_log 文件路径 错误级别（debug | info | notice | warn | error | crit | alert | emerg），级别越高记录的信息越少
error_log /wwwlogs/error_nginx.log crit;

# 进程标识符
pid /var/run/nginx.pid;

# 进程可以打开最大描述符的数目
worker_rlimit_nofile 51200;

events {
  # 使用的I/O模型（epoll、kqueue、select、poll etc.）
  use epoll;

  # 若该项设置为off，当一个请求到来时，所有休眠的worker进程都会被唤醒，来争夺这个请求，但只有一个进程可以处理该请求，其他未获得请求的进程继续进入休眠，这就是惊群现象，会造成极大地资源浪费
  # 该项设置为on后，Nginx规定同一时刻只能有唯一一个持有mutex锁的worker进程会接受并处理请求
  accept_mutex on;

  # worker进程的等待时间，过了等待时间后，下一个worker进程取得mutex锁
  accept_mutex_delay 500ms;

  # 每个工作进程的最大连接数，与前面的
  worker_connections 51200;

  # 让worker进程尽可能多的接受请求
  # 设置为on时，让worker进程一次性地接受监听队列里的所有请求；设置为off则必须一个一个地接受监听队列里的请求
  multi_accept on;
}

# http服务器
http {
  # 包含mime.types文件，该文件为MIME类型映射表（例如图片、文本、视频等）
  # types {
  #  text/html                                        html htm shtml;
  #  text/css                                         css;
  #  text/xml                                         xml;
  #  image/gif                                        gif;
  #  image/jpeg                                       jpeg jpg;
  #  application/javascript                           js;
  #  application/atom+xml                             atom;
  #  application/rss+xml                              rss;
  #  ......
  # }
  include mime.types;

  # 指定默认MIME类型（application/octet-stream为普通的文件流，浏览器会提示用户下载）
  default_type application/octet-stream;

  # 保存服务器名字的Hash表大小（若增加多个域名后无法启动，可能需要将该项适当调大，并保持为处理器缓存大小的倍数）
  server_names_hash_bucket_size 128;
  # 服务器最大个数
  server_names_hash_max_size 512;

  # 客户端请求头部的缓存区大小
  client_header_buffer_size 32k;
  # nginx默认使用client_header_buffer_size来读取header的值，若header过大，则使用large_client_header_buffers来读取
  large_client_header_buffers 4 32k;

  # 客户端请求body的最大值（nginx上传文件的大小）
  client_max_body_size 1024m;
  # 客户端请求body缓冲区大小
  client_body_buffer_size 10m;

  # sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。
  sendfile on;
  # 允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用
  tcp_nopush on;

  # keep-alive超时时间
  keepalive_timeout 120;

  # 开启或关闭nginx的版本信息 
  server_tokens off;

  # 提高数据的实时响应性，仅在将连接转变为长连接的时候才被启用（在upstream发送响应到客户端时也会启用）
  tcp_nodelay on;

  # fastcgi相关配置
  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 64k;
  fastcgi_buffers 4 64k;
  fastcgi_busy_buffers_size 128k;
  fastcgi_temp_file_write_size 128k;
  fastcgi_intercept_errors on;

  # Gzip压缩
  gzip on;
  # 16 8k代表以8k为单位，按照原始数据大小以8k为单位的16倍申请内存
  gzip_buffers 16 8k;
  # 压缩级别，等级越高，消耗CPU越多
  gzip_comp_level 6;
  # 设置支持http协议的最小压缩版本
  gzip_http_version 1.1;
  # 允许压缩页面的最小字节数
  gzip_min_length 256;
  # Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含&amp;quot;Via&amp;quot;的 header头。
  # off - 关闭所有的代理结果数据的压缩
  # expired - 启用压缩，如果header头中包含 &amp;quot;Expires&amp;quot; 头信息
  # no-cache - 启用压缩，如果header头中包含 &amp;quot;Cache-Control:no-cache&amp;quot; 头信息
  # no-store - 启用压缩，如果header头中包含 &amp;quot;Cache-Control:no-store&amp;quot; 头信息
  # private - 启用压缩，如果header头中包含 &amp;quot;Cache-Control:private&amp;quot; 头信息
  # no_last_modified - 启用压缩,如果header头中不包含 &amp;quot;Last-Modified&amp;quot; 头信息
  # no_etag - 启用压缩 ,如果header头中不包含 &amp;quot;ETag&amp;quot; 头信息
  # auth - 启用压缩 , 如果header头中包含 &amp;quot;Authorization&amp;quot; 头信息
  # any - 无条件启用压缩
  gzip_proxied any;
  # 在http头文件中加个“Vary: Accept-Encoding”，给代理服务器用的，有的浏览器支持压缩，有的不支持所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
  gzip_vary on;
  # 压缩的MIME类型
  gzip_types
    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml
    text/javascript application/javascript application/x-javascript
    text/x-json application/json application/x-web-app-manifest+json
    text/css text/plain text/x-component
    font/opentype application/x-font-ttf application/vnd.ms-fontobject
    image/x-icon;
  gzip_disable &amp;quot;MSIE [1-6]\.(?!.*SV1)&amp;quot;;

  #If you have a lot of static files to serve through Nginx then caching of the files&#39; metadata (not the actual files&#39; contents) can save some latency.
  open_file_cache max=1000 inactive=20s;
  open_file_cache_valid 30s;
  open_file_cache_min_uses 2;
  open_file_cache_errors on;

  # 隐藏头部信息，格式为：proxy_hide_header 响应头部字段
  proxy_hide_header Vary;
  proxy_hide_header X-Powered-By;

######################## default ############################
   #http
   server {
    listen 80;
    # 服务器名
    server_name www.xxxx.com;
    
    # 重定向
    rewrite ^(.*) https://www.xxxx.com;
    
    # 访问日志
    access_log /www/LOG/access_nginx.log combined;

    # 默认主页
    index index.html index.htm index.php;

    # 错误页面，格式：error_page 错误码 错误页面路径
    #error_page 404 /404.html;
    #error_page 502 /502.html
    
    # http://www.xxxx.com/nginx_status查看nginx状态
    location /nginx_status {
      stub_status on;
      access_log off;
      allow 127.0.0.1; # 允许访问的ip
      deny all;   # 拒绝除allow之外的所有访问
    }

    # 转发PHP请求到php-fpm，[^/]匹配非/的字符
    location ~ [^/]\.php(/|$) {
      fastcgi_pass 127.0.0.1:9000; # 转发到本地9000端口，php-fpm默认端口
      #fastcgi_pass unix:/dev/shm/php-cgi.sock;
      fastcgi_index index.php;
      include fastcgi.conf;
    }
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ {
      expires 30d; # 规定时间后过期
      access_log off;
    }
    location ~ .*\.(js|css)?$ {
      expires 7d;
      access_log off;
    }
    location ~ /\.ht {
      deny all;
    }

  }

  #https 
  server{
    listen 443;
    server_name www.xxxx.com; 

    root  /www/website;
    index index.html index.htm index.php;
    access_log /www/LOG/access_nginx.log combined;

    # ssl配置
    ssl on;
    ssl_certificate &amp;quot;xxxx.crt&amp;quot;;
    ssl_certificate_key &amp;quot;xxxx.key&amp;quot;;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   

    location /nginx_status {
      stub_status on;
      access_log off;
      allow 127.0.0.1;
      deny all;
    }
    location ~ [^/]\.php(/|$) {
      #fastcgi_pass 127.0.0.1:9000;
      fastcgi_pass unix:/dev/shm/php-cgi.sock;
      fastcgi_index index.php;
      include fastcgi.conf;
    }
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ {
      expires 30d;
      access_log off;
    } 
    location ~ .*\.(js|css)?$ {
      expires 7d;
      access_log off;
    } 
    location ~ /\.ht {
      deny all;
    } 
  }
########################## vhost #############################
  # 包含其他配置信息
  include vhost/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx服务器配置详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/upmzqiH5w/"" data-c="
          &lt;p&gt;最近接触到Vue.js，首先碰到的就是数据绑定，对其原理实现十分好奇，于是深入了解一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-实现原理与技术&#34;&gt;一、实现原理与技术&lt;/h2&gt;
&lt;p&gt;Vue.js的数据绑定是通过ES5中的Object.defineProperty() + 订阅者-发布者模式实现的。其通过object.defineProperty()劫持各个属性的set、get事件，在数据发生变动时发送消息给订阅者，触发相应的监听回调。&lt;/p&gt;
&lt;p&gt;在此也顺带捎一下简单介绍一下其他框架的实现：&lt;br&gt;
&lt;strong&gt;Backbone.js&lt;/strong&gt;: 在Model到View的数据传递过程中，可以在View中监听Model的change事件，当Model数据更新时，刷新View；在View到Model的数据传递过程中，可以监听View的DOM元素的事件，当检测到View状态变更后，将变更的数据发送到Model。&lt;br&gt;
&lt;strong&gt;Angular.js&lt;/strong&gt;: 采用&amp;quot;脏值检测&amp;quot;的方式，数据发生变更后，对于所有数据和视图的绑定关系进行一次检测，识别是否有数据发生改变，有改变进行处理，可能进一步引发其他数据的改变，进入循环，直至没有数据发生变化，然后将数据更新到视图。若手动对ViewModel的数据进行变更，则需要手动触发一次&amp;quot;脏值检测&amp;quot;。&lt;/p&gt;
&lt;h3 id=&#34;1-objectdefineproperty&#34;&gt;1、Object.defineProperty()&lt;/h3&gt;
&lt;p&gt;defineProperty()是Object类的一个方法，其作用是在一个对象上定义一个新的属性或修改其原有属性，并返回这个对象。&lt;/p&gt;
&lt;h4 id=&#34;用法&#34;&gt;用法：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.defineProperty(obj, prop, descriptor);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;defineProperty方法接受三个参数和返回值：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① &lt;strong&gt;obj&lt;/strong&gt;: 目标对象&lt;br&gt;
② &lt;strong&gt;prop&lt;/strong&gt;: 定义或修改的属性名称&lt;br&gt;
③ &lt;strong&gt;descriptor&lt;/strong&gt;: 被定义或被修改的属性描述符（对象）&lt;br&gt;
返回值： 被传递给函数的经过修改的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中参数descriptor(描述符)主要有两种形式：&lt;strong&gt;数据描述符&lt;/strong&gt;和&lt;strong&gt;存取描述符&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;数据描述符&lt;/strong&gt;是一个具有值的属性，该值可能是可写的，也可能不是可写的。&lt;br&gt;
&lt;strong&gt;存取描述符&lt;/strong&gt;是由getter-setter函数对描述的属性。描述符必须是两种形式之一，且不能同时为两者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;① 数据描述符和存取描述符都具有的键值&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;configurable&lt;/strong&gt;: 当且仅当该属性的configurable为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。&lt;strong&gt;默认为false&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;enumerable&lt;/strong&gt;: 当且仅当该属性的enumerable为true时，该属性才能出现在对象的枚举属性中（在for...in和Object.keys()）。&lt;strong&gt;默认为false&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;② 数据描述符具有的键值&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;value&lt;/strong&gt;: 该属性对应的值。可以是任何有效的JavaScript值。&lt;strong&gt;默认为undefined&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;writable&lt;/strong&gt;: 当且仅当该属性的writable为true时，value才能被改变。&lt;strong&gt;默认为false&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;③ 存取描述符具有的键值&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;get&lt;/strong&gt;: 一个给属性提供getter的方法，若没有getter则为undefined。当访问该属性时，该方法被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。&lt;strong&gt;默认为undefined&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;set&lt;/strong&gt;: 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。&lt;strong&gt;默认为undefined&lt;/strong&gt;。&lt;br&gt;
&lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;综上，数据描述符可含有的键值为：configurable、enumerable、value、writable；存取描述符可含有的键值为：configurable、enumerable、get、set；且数据描述符和存取描述符能且只能存在一种。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {};
Object.defineProperty(obj, &#39;x&#39;, {
    value: 123,
    writable: true,
    configurable: true,
    enumerable: true
});
/*
 * 上述代码为obj对象定义一个名为x的属性，并赋值为123（数据描述符）
 */

var obj2 = {
    x: 123
};
Object.defineProperty(obj2, &#39;x&#39;, {
    get: function () {
        return &#39;This is x&#39;;
    },
    set: function (value) {
        console.log(&amp;quot;update x: &amp;quot; + value);
    }
});
/*
 * 以上代码为obj2创建属性x的存取描述符，当获取obj2的x属性时，返回&amp;quot;This is x&amp;quot;；当设置obj2的x属性时，控制台输出更新信息。
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-订阅者-发布者模式&#34;&gt;2、订阅者-发布者模式&lt;/h3&gt;
&lt;p&gt;订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心，由调用中心统一调度订阅者注册到调度中心的处理代码。如下图：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/vue/1.png&#34; alt=&#34;订阅者-发布者模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在此顺带介绍一下观察者模式：观察者把自己注册到目标（发布者）里，在具体目标发生变化时候，调度观察者的更新方法。如下图：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/vue/2.png&#34; alt=&#34;观察者模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;&lt;em&gt;观察者模式与订阅者-发布者模式的区别：最大的区别是调度的地方。虽然两种模式都存在订阅者和发布者，但观察者模式是由目标调度的，而订阅者-发布者模式是由调度中心统一调度的，因此观察者模式的观察者和目标之间会存在着依赖，而订阅者-发布者不会，且订阅者-发布者是松耦合的。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
">Vue.js的数据绑定原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/Qqu8tZkzh/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;博客内容为&lt;a href=&#34;https://github.com/colinlet/PHP-Interview-QA&#34;&gt;PHP-Interview-QA&lt;/a&gt;读后笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;计算机网络体系结构&#34;&gt;计算机网络体系结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;物理层：管理物理连接，并进行数据比特流传输&lt;/li&gt;
&lt;li&gt;数据链路层：建立逻辑连接，进行物理地址寻址，将上层数据封装成帧、进行差错校验、硬件地址寻址等&lt;/li&gt;
&lt;li&gt;网络层：进行逻辑地址寻址，实现不同网络之间的路径选择&lt;/li&gt;
&lt;li&gt;传输层：定义传输数据的端口号，负责向两台主机间进程的通信提供通用的数据传输服务&lt;/li&gt;
&lt;li&gt;应用层：定义应用进程间的通信与交互规则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp三次握手&#34;&gt;TCP三次握手&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;服务器端进程监听端口&lt;/li&gt;
&lt;li&gt;客户端向服务器端发送SYN标志报文&lt;/li&gt;
&lt;li&gt;服务器端收到请求报文后，返回携带SYN、ACK标志的确认报文&lt;/li&gt;
&lt;li&gt;客户端接收到确认报文后，返回ACK标志的确认报文，此时，客户端进入已建立连接状态&lt;/li&gt;
&lt;li&gt;服务器收到确认报文后，也进入建立连接状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么要进行三次握手&#34;&gt;为什么要进行三次握手&lt;/h2&gt;
&lt;p&gt;如果只有两次握手，已失效的请求报文传到服务器会引起错误&lt;/p&gt;
&lt;h2 id=&#34;tcp与udp&#34;&gt;TCP与UDP&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向报文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全双工&lt;/td&gt;
&lt;td&gt;一对一、一对多、多对一、多对多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有流量控制与拥塞控制&lt;/td&gt;
&lt;td&gt;无流量控制与拥塞控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;速度慢&lt;/td&gt;
&lt;td&gt;速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开销大&lt;/td&gt;
&lt;td&gt;开销小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保证数据顺序&lt;/td&gt;
&lt;td&gt;不保证数据顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;UDP适用于对速度要求比较高，对安全性、可靠性要求相对较低的场景&lt;br&gt;
TCP适用于文件传输、远程登录等对数据准确性要求比较高的场景&lt;/p&gt;
&lt;h2 id=&#34;tcp粘包问题&#34;&gt;TCP粘包问题&lt;/h2&gt;
&lt;p&gt;发送方发送两个包：Hello World、Hello Alan，粘包后接收方接收到的结果可能为Hello WorldHello Alan。&lt;/p&gt;
&lt;p&gt;造成粘包问题的原因：发送时需要等缓冲区满才能发送；接收时不及时接收缓冲区的包。&lt;/p&gt;
&lt;h2 id=&#34;创建socket的步骤&#34;&gt;创建socket的步骤&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建socket&lt;/li&gt;
&lt;li&gt;绑定socket到指定地址及端口&lt;/li&gt;
&lt;li&gt;监听连接&lt;/li&gt;
&lt;li&gt;读取客户端输入&lt;/li&gt;
&lt;li&gt;关闭socket&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http报文组成&#34;&gt;HTTP报文组成&lt;/h2&gt;
&lt;p&gt;起始行、首部字段、主体&lt;/p&gt;
&lt;h2 id=&#34;常用状态码&#34;&gt;常用状态码&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态码&lt;/th&gt;
&lt;th&gt;短语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching Protocol&lt;/td&gt;
&lt;td&gt;切换协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;部分请求成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;永久性重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Found&lt;/td&gt;
&lt;td&gt;找到资源，临时重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;Not Modified&lt;/td&gt;
&lt;td&gt;未修改，资源未被修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;请求格式错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;禁止访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;未找到资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;服务器遇到错误，PHP代码问题；文件权限问题；资源限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;网关错误，当PHP-CGI得到一个无效响应时出现，此时PHP-CGI停止运行或卡死&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;504&lt;/td&gt;
&lt;td&gt;Gateway Timeout&lt;/td&gt;
&lt;td&gt;网关超时，PHP-CGI没有在指定时间响应请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;常见的http请求&#34;&gt;常见的HTTP请求&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否包含主体&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;从服务器获取资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;创建资源&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;创建或更新资源、幂等&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;从服务器删除资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;从服务器获取头部信息&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;获取服务器支持的方法&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;对可能经过代理服务器传送到服务器上的报文进行追踪&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;get与post请求的区别&#34;&gt;GET与POST请求的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;GET&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;POST&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可后退、刷新无害&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据被重新提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;浏览器会限制URL的长度，因此数据长度存在限制&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;长度无限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据可见、安全性差&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据不可见、安全性高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可被缓存、可存为书签&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不可被缓存、不可存为书签&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;http的优缺点&#34;&gt;HTTP的优缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优点：使用方便&lt;/li&gt;
&lt;li&gt;缺点：传输速度慢，数据包大；实现实时交互，服务器性能压力大；数据传输安全性差&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;keep-alive&#34;&gt;Keep Alive&lt;/h2&gt;
&lt;p&gt;定时发送一个探测包，以确保连接是活动状态&lt;/p&gt;
">面试问题之计算机网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/goEKUdWvk/"" data-c="
          &lt;p&gt;玩黑苹果也有一段时间了，从一开始照着别人的教程一步一步安装的小白，到现在知道一些引导文件的、驱动文件的作用，可以自己组合EFI去驱动电脑，从10.12到10.14，这个过程中学到了很多。&lt;/p&gt;
&lt;p&gt;macOS 10.14正式版开始推送了，写个博客放下我的引导。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-macos-mojave的引导&#34;&gt;1. macOS Mojave的引导&lt;/h2&gt;
&lt;p&gt;关于EFI是什么我就不多说了，合理利用度娘、Google&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先说一下电脑的相关信息：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;神船K610系列、大麦2S系列*（两个机型主板相同）* &lt;strong&gt;---机型不同可能不能进入mac系统---&lt;/strong&gt;&lt;br&gt;
CPU: i5 4210m&lt;br&gt;
显卡: GT960m*（笔记本的独显驱动不了）*&lt;br&gt;
网卡：换了TB买的黑苹果免驱的网卡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，直接上我使用的黑苹果引导：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**升级时用的引导：**链接: https://pan.baidu.com/s/1F8OG6gQ9gnXb0XcXQ7KmeA 密码: 4dwj&lt;/p&gt;
&lt;p&gt;**升级后日常使用的引导：**链接: https://pan.baidu.com/s/1XkfYyDI8cRWUgShoumuugg 密码: ts8m&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这两个引导的区别在于前面一个更精简，删除了一些升级非必需的引导文件，可以提升升级的成功率（在远景论坛找的，不记得是哪个帖子了，当然也可以自己精简第二个引导用于升级，不过我不想搞了，能用就先用着吧😝）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-efi目录结构&#34;&gt;2. EFI目录结构&lt;/h2&gt;
&lt;p&gt;说一下efi目录下的各个文件夹的作用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ tree EFI -L 2

EFI
├── APPLE               // 白果用到的启动固件，由系统自动生成，删除后仍会生成，忽略即可
│   ├── EXTENSIONS
│   └── FIRMWARE
├── BOOT                
│   └── BOOTX64.efi     // UEFI必需引导文件
└── CLOVER
    ├── ACPI            // 必需
    ├── CLOVERX64.efi   // 四叶草Clover引导文件
    ├── config.plist    // Clover引导配置文件
    ├── drivers64UEFI   // 硬盘文件系统的驱动文件
    ├── kexts           // 硬件驱动文件
    ├── misc            
    ├── themes          // Clover引导界面的主题，可自定义
    └── tools           // 必需
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kexts目录下存放的驱动可以根据自己的需求增删，驱动文件的具体作用直接输入文件名百度就行了。😆&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;在安装黑苹果时，ESP分区的大小需要不小于200M，否则会报错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
">黑苹果(Hackintosh)的相关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/about/"" data-c="
          &lt;p&gt;Hello，欢迎访问我的博客，我是anhoder，目前是一位PHP码农。&lt;/p&gt;
&lt;h2 id=&#34;联系我&#34;&gt;联系我&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邮箱: &lt;a href=&#34;mailto:anhoder@88.com&#34;&gt;anhoder@88.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/anhoder&#34;&gt;https://github.com/anhoder&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微博: &lt;a href=&#34;https://weibo.com/u/5794659803&#34;&gt;https://weibo.com/u/5794659803&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/Alan_Albert_&#34;&gt;https://twitter.com/Alan_Albert_&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微信公众号: anhoder的进阶日志&lt;br&gt;
&lt;br /&gt;&lt;img src=&#34;/media/images/custom-array-imgSocials-1617614181832-socialImg.png&#34; alt=&#34;anhoder的进阶日志&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">关于我</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/l9oHb1QpJ/"" data-c="
          &lt;p&gt;很早就接触到了这个东西，只是没有系统的去了解，写个博客加深记忆 😃。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-概念&#34;&gt;一、概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;浅复制&lt;/strong&gt;：引用赋值，复制的变量和被复制的变量指向同一个位置，对其中一个进行修改会导致从另一个变量访问的值也发生改变；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深复制&lt;/strong&gt;：完全复制，两个变量相互独立，不产生影响。&lt;/p&gt;
&lt;h2 id=&#34;二-详细区别&#34;&gt;二、详细区别&lt;/h2&gt;
&lt;h3 id=&#34;1-情况一&#34;&gt;1、情况一&lt;/h3&gt;
&lt;p&gt;最常见的就是&lt;strong&gt;普通变量&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;之间的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通变量赋值时是深拷贝，具体采用的是&lt;em&gt;引用计数+写时复制&lt;/em&gt;，因此在进行值的修改时两个变量之间是互不影响的。&lt;br&gt;
而对于对象来说，则是使用引用赋值（赋值、作为函数参数传递），即浅复制，两个变量之间会相互影响、相互羁绊😏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个栗子🌰：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 普通变量
$a = &#39;原值&#39;;
$b = $a;        // 此时，$a和$b的值都为&#39;原值&#39;
$b = &#39;修改的值&#39;; // $a为&#39;原值&#39;，$b为&#39;修改的值&#39;

// 对象
class C
{
    public $var = &#39;原值&#39;;
}
$c = new C();   // $c-&amp;gt;var的值为&#39;原值&#39;
$d = $c;
$d-&amp;gt;var = &#39;修改的值&#39;;   // 此时$c-&amp;gt;var为&#39;修改的值&#39;，$d-&amp;gt;var也为&#39;修改的值&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那如果想要对对象进行深拷贝应该如何做呢？在PHP中提供了&lt;strong&gt;clone&lt;/strong&gt;可以实现。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class A
{
    public $var = &#39;原值&#39;;
}
$a = new A();
$b = clone $a;
$b-&amp;gt;var = &#39;修改的值&#39;;
echo $a-&amp;gt;var, PHP_EOL;  // 原值
echo $b-&amp;gt;var, PHP_EOL;  // 修改的值
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-情况二&#34;&gt;2、情况二&lt;/h3&gt;
&lt;p&gt;用上述方法很多情况下可以进行浅赋值，但如果被复制对象中存在对象属性的话，原对象的普通对象会被深复制，而原对象的对象属性还是进行浅复制（引用赋值）。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class A
{
    public $var_a = &#39;class A&#39;;
}
class B
{
    public $var_b = &#39;class B&#39;;
    public $var_b_obj;
    
    public function __construct()
    {
        $this-&amp;gt;var_b_obj = new A();
    }
}
$one = new B();
$two = clone $one;
// $one-&amp;gt;var_b和$two-&amp;gt;var_b都为&#39;classB&#39;
// $one-&amp;gt;var_b_obj-&amp;gt;var_a和$two-&amp;gt;var_b_obj-&amp;gt;var_a都为&#39;classA&#39;
$two-&amp;gt;var_b = &#39;new class B&#39;;
$two-&amp;gt;var_b_obj-&amp;gt;var_a = &#39;new class A&#39;; 
// 至此，$one-&amp;gt;var_b=&#39;class B&#39;，$two-&amp;gt;var_b=&#39;new class B&#39;
// $one-&amp;gt;var_b_obj-&amp;gt;var_a和$two-&amp;gt;var_b_obj-&amp;gt;var_a都为&#39;new class A&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这种办法如何实现深复制呢？&lt;/p&gt;
&lt;h4 id=&#34;方法一&#34;&gt;方法一&lt;/h4&gt;
&lt;p&gt;使用__clone魔术方法进行复制。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class A{}
class B
{
    public $obj;
    
    public function __construct()
    {
        $this-&amp;gt;obj = new A();
    }
    
    public function __clone()
    {
        $this-&amp;gt;obj = clone $this-&amp;gt;obj;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法二&#34;&gt;方法二&lt;/h4&gt;
&lt;p&gt;使用序列化(serialize)和反序列化(unserialize)实现。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class A {}
class B
{
    public $a;
    
    public function __construct()
    {
        $this-&amp;gt;a = new A();
    }
}
$one = new A();
$temp = serialize($one);
$two = unserialize($temp); // 此时的$two与$one是不会影响的两个变量
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;br&gt;
① 使用序列化和反序列化时，将会触发__sleep和__wakeup魔术方法&lt;br&gt;
② 同样的原理我们也可以使用json相关函数进行对象复制，若使用json_encode和json_decode将丢失原对象中的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">PHP的浅复制和深复制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/N2amIMO_J/"" data-c="
          &lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;转自GitHub---&lt;a href=&#34;https://github.com/xingshaocheng/architect-awesome&#34;&gt;传送门&lt;/a&gt;（如侵删）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;留意到的一个很好的后端技术图谱，害怕以后忘记，因此记录一下。&lt;/p&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lemon-flm/p/7877898.html&#34;&gt;《java队列——queue详细分析》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。&lt;/li&gt;
&lt;li&gt;阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/mantu/p/5802393.html&#34;&gt;《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;集合&#34;&gt;集合&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33642117/article/details/52040345&#34;&gt;《Java Set集合的详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链表-数组&#34;&gt;链表、数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wz249863091/article/details/52853360&#34;&gt;《Java集合详解--什么是List》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字典-关联数组&#34;&gt;字典、关联数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.xsoftlab.net/view/250.html&#34;&gt;《Java map 详解 - 用法、遍历、排序、常用API等》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/javazejian/article/details/53362993&#34;&gt;《java数据结构与算法之栈（Stack）设计与实现》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/java/java-stack-class.html&#34;&gt;《Java Stack 类》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/f2006116/article/details/51375225&#34;&gt;《java stack的详细实现分析》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Stack 是线程安全的。&lt;/li&gt;
&lt;li&gt;内部使用数组保存数据，不够时翻倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树&lt;/h3&gt;
&lt;p&gt;每个节点最多有两个叶子节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/cai2016/article/details/52589952&#34;&gt;《二叉树》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;完全二叉树&#34;&gt;完全二叉树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin&#34;&gt;《完全二叉树》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h3&gt;
&lt;p&gt;左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/polly333/p/4798944.html&#34;&gt;《浅谈数据结构-平衡二叉树》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html&#34;&gt;《浅谈算法和数据结构: 八 平衡查找树之2-3树》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉查找树bst&#34;&gt;二叉查找树（BST）&lt;/h3&gt;
&lt;p&gt;二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html&#34;&gt;《浅谈算法和数据结构: 七 二叉查找树》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;红黑树&#34;&gt;红黑树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sun_tttt/article/details/65445754&#34;&gt;《最容易懂得红黑树》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;添加阶段后，左旋或者右旋从而再次达到平衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&#34;&gt;《浅谈算法和数据结构: 九 平衡查找树之红黑树》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-bb树&#34;&gt;B-，B+，B*树&lt;/h3&gt;
&lt;p&gt;MySQL是基于B+树聚集索引组织表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/aqzwss/article/details/53074186&#34;&gt;《B-树，B+树，B*树详解》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/bigtree_3721/article/details/73632405&#34;&gt;《B-树，B+树与B*树的优缺点比较》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lsm-树&#34;&gt;LSM 树&lt;/h3&gt;
&lt;p&gt;LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。&lt;br&gt;
Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/dbanote/article/details/8897599&#34;&gt;《LSM树 VS B+树》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。&lt;/li&gt;
&lt;li&gt;LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u014774781/article/details/52105708&#34;&gt;《LSM树（Log-Structured Merge Tree）存储引擎》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。&lt;/li&gt;
&lt;li&gt;优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。&lt;/li&gt;
&lt;li&gt;Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bitset&#34;&gt;BitSet&lt;/h2&gt;
&lt;p&gt;经常用于大规模数据的排重检查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/java/java-bitset-class.html&#34;&gt;《Java Bitset类》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/caiandyong/article/details/51581160&#34;&gt;《Java BitSet（位集）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常用算法&#34;&gt;常用算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/gane_cheng/article/details/52652705&#34;&gt;《常见排序算法及对应的时间复杂度和空间复杂度》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;排序-查找算法&#34;&gt;排序、查找算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/gane_cheng/article/details/52652705&#34;&gt;《常见排序算法及对应的时间复杂度和空间复杂度》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择排序&#34;&gt;选择排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/shen-hua/p/5424059.html&#34;&gt;《Java中的经典算法之选择排序（SelectionSort）》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/shuaizai88/article/details/73250615&#34;&gt;《冒泡排序的2种写法》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;相邻元素前后交换、把最大的排到最后。&lt;/li&gt;
&lt;li&gt;时间复杂度 O(n²)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入排序&#34;&gt;插入排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hapjin/p/5517667.html&#34;&gt;《排序算法总结之插入排序》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快速排序&#34;&gt;快速排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.51cto.com/art/201403/430986.htm&#34;&gt;《坐在马桶上看算法：快速排序》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;一侧比另外一次都大或小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;归并排序&#34;&gt;归并排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/chengxiao/p/6194356.html&#34;&gt;《图解排序算法(四)之归并排序》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;分而治之，分成小份排序，在合并(重建一个新空间进行复制)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/chengxiao/p/6129630.html&#34;&gt;《图解排序算法(三)之堆排序》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计数排序&#34;&gt;计数排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/suvllian/p/5495780.html&#34;&gt;《计数排序和桶排序》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;和桶排序过程比较像，差别在于桶的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;桶排序&#34;&gt;桶排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.51cto.com/ahalei/1362789&#34;&gt;《【啊哈！算法】最快最简单的排序——桶排序》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sunjinshengli/article/details/70738527&#34;&gt;《排序算法（三）：计数排序与桶排序》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。&lt;/li&gt;
&lt;li&gt;每个桶单独进行排序，然后再遍历每个桶。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基数排序&#34;&gt;基数排序&lt;/h3&gt;
&lt;p&gt;按照个位、十位、百位、...依次来排。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lemon_tree12138/article/details/51695211&#34;&gt;《排序算法系列：基数排序》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/skywang12345/p/3603669.html&#34;&gt;《基数排序》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二分查找&#34;&gt;二分查找&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/coderising/p/5708632.html&#34;&gt;《二分查找(java实现)》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求待查找的序列有序。&lt;/li&gt;
&lt;li&gt;时间复杂度 O(logN)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/maoyuanming0806/article/details/78176957&#34;&gt;《java实现二分查找-两种方式》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;while + 递归。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java-中的排序工具&#34;&gt;Java 中的排序工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;amp;fps=1&#34;&gt;《Arrays.sort和Collections.sort实现原理解析》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Collections.sort算法调用的是合并排序。&lt;/li&gt;
&lt;li&gt;Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;布隆过滤器&#34;&gt;布隆过滤器&lt;/h2&gt;
&lt;p&gt;常用于大数据的排重，比如email，url 等。&lt;br&gt;
核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。&lt;br&gt;
优点：空间和时间效率都很高。&lt;br&gt;
缺点：随着存入的元素数量增加，误算率随之增加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000002729689&#34;&gt;《布隆过滤器 -- 空间效率很高的数据结构》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zdxiq000/article/details/57626464&#34;&gt;《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_30242609/article/details/71024458&#34;&gt;《基于Redis的布隆过滤器的实现》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;基于 Redis 的 Bitmap 数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lemon_tree12138/article/details/47973715&#34;&gt;《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;使用Java中的 BitSet 类 和 加权和hash算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;
&lt;h3 id=&#34;kmp-算法&#34;&gt;KMP 算法&lt;/h3&gt;
&lt;p&gt;KMP：Knuth-Morris-Pratt算法（简称KMP）&lt;br&gt;
核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&#34;&gt;《字符串匹配的KMP算法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;深度优先-广度优先&#34;&gt;深度优先、广度优先&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/0kk470/p/7555033.html&#34;&gt;《广度优先搜索BFS和深度优先搜索DFS》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;贪心算法&#34;&gt;贪心算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/MrSaver/p/8641971.html&#34;&gt;《算法：贪婪算法基础》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/a345017062/article/details/52443781&#34;&gt;《常见算法及问题场景——贪心算法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;回溯算法&#34;&gt;回溯算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qfikh/article/details/51960331&#34;&gt;《 五大常用算法之四：回溯法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;剪枝算法&#34;&gt;剪枝算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/luningcsdn/article/details/50930276&#34;&gt;《α-β剪枝算法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/little-YTMM/p/5372680.html&#34;&gt;《详解动态规划——邹博讲动态规划》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yao_zi_jie/article/details/54580283&#34;&gt;《动态规划算法的个人理解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;朴素贝叶斯&#34;&gt;朴素贝叶斯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/amds123/article/details/70173402&#34;&gt;《带你搞懂朴素贝叶斯分类算法》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(B|A)=P(A|B)P(B)/P(A)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html&#34;&gt;《贝叶斯推断及其互联网应用1》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html&#34;&gt;《贝叶斯推断及其互联网应用2》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推荐算法&#34;&gt;推荐算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01&#34;&gt;《推荐算法综述》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems&#34;&gt;《TOP 10 开源的推荐系统简介》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最小生成树算法&#34;&gt;最小生成树算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/luoshixian099/article/details/51908175&#34;&gt;《算法导论--最小生成树（Kruskal和Prim算法）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最短路径算法&#34;&gt;最短路径算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35644234/article/details/60870719&#34;&gt;《Dijkstra算法详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;并发&#34;&gt;并发&lt;/h1&gt;
&lt;h2 id=&#34;java-并发&#34;&gt;Java 并发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CL0610/Java-concurrency&#34;&gt;Java 并发知识合集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CL0610/Java-concurrency/blob/master/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.png&#34;&gt;JAVA并发知识图谱&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/18459.html&#34;&gt;《40个Java多线程问题总结》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/zhanht/p/5450325.html&#34;&gt;《Java并发编程——线程安全及解决机制简介》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一致性-事务&#34;&gt;一致性、事务&lt;/h2&gt;
&lt;h3 id=&#34;事务-acid-特性&#34;&gt;事务 ACID 特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u012440687/article/details/52116108&#34;&gt;《数据库事务ACID特性》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序列化：所有事物串行处理（牺牲了效率）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33290787/article/details/51924963&#34;&gt;《理解事务的4种隔离级别》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/z-sm/p/7245981.html&#34;&gt;数据库事务的四大特性及事务隔离级别&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html&#34;&gt;《MySQL的InnoDB的幻读问题 》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幻读的例子非常清楚。&lt;/li&gt;
&lt;li&gt;通过 SELECT ... FOR UPDATE 解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://database.51cto.com/art/201804/570101.htm&#34;&gt;《一篇文章带你读懂MySQL和InnoDB》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图解脏读、不可重复读、幻读问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc&#34;&gt;MVCC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/chenpingzhao/p/5065316.html&#34;&gt;《【mysql】关于innodb中MVCC的一些理解》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innodb 中 MVCC 用在 Repeatable-Read 隔离级别。&lt;/li&gt;
&lt;li&gt;MVCC 会产生幻读问题（更新时异常。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/whoamiyang/article/details/51901888&#34;&gt;《轻松理解MYSQL MVCC 实现机制》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间&lt;/li&gt;
&lt;li&gt;每次只操作比当前版本小（或等于）的 行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;h3 id=&#34;java中的锁和同步类&#34;&gt;Java中的锁和同步类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/qifengshi/p/6831055.html&#34;&gt;《Java中的锁分类》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要包括 synchronized、ReentrantLock、和 ReadWriteLock。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/waterystone/p/4920797.html&#34;&gt;《Java并发之AQS详解》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://cuisuqiang.iteye.com/blog/2020146&#34;&gt;《Java中信号量 Semaphore》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有数量控制&lt;/li&gt;
&lt;li&gt;申请用 acquire，申请不要则阻塞；释放用 release。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/davidwang456/p/6094947.html&#34;&gt;《java开发中的Mutex vs Semaphore》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;公平锁-非公平锁&#34;&gt;公平锁 &amp;amp; 非公平锁&lt;/h3&gt;
&lt;p&gt;公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/EthanWhite/article/details/55508357&#34;&gt;《公平锁与非公平锁》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;悲观锁&#34;&gt;悲观锁&lt;/h3&gt;
&lt;p&gt;悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhiqian-ali/p/6200874.html&#34;&gt;《【MySQL】悲观锁&amp;amp;乐观锁》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乐观锁的方式：版本号+重试方式&lt;/li&gt;
&lt;li&gt;悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/Lawson/p/5008741.html&#34;&gt;《Mysql查询语句使用select.. for update导致的数据库死锁分析》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。&lt;/li&gt;
&lt;li&gt;锁相同数据的不同索引条件可能会引起死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zejin2008/p/5262751.html&#34;&gt;《Mysql并发时经典常见的死锁原因及解决方法》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;乐观锁-cas&#34;&gt;乐观锁 &amp;amp; CAS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/20472.html&#34;&gt;《乐观锁的一种实现方式——CAS》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;和MySQL乐观锁方式相似，只不过是通过和原值进行比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aba-问题&#34;&gt;ABA 问题&lt;/h3&gt;
&lt;p&gt;由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/549294286/p/3766717.html&#34;&gt;《Java CAS 和ABA问题》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/li954644351/article/details/50511879&#34;&gt;《Java 中 ABA问题及避免》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;AtomicStampedReference 和 AtomicStampedReference。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;copyonwrite容器&#34;&gt;CopyOnWrite容器&lt;/h3&gt;
&lt;p&gt;可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/hapjin/p/4840107.html&#34;&gt;《JAVA中写时复制(Copy-On-Write)Map实现》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现读写分离，读取发生在原始数据上，写入发生在副本上。&lt;/li&gt;
&lt;li&gt;不用加锁，通过最终一致实现一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/a494303877/article/details/53404623&#34;&gt;《聊聊并发-Java中的Copy-On-Write容器》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ringbuffer&#34;&gt;RingBuffer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/l00l/p/4115001.html&#34;&gt;《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可重入锁-不可重入锁&#34;&gt;可重入锁 &amp;amp; 不可重入锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/dj3839/p/6580765.html&#34;&gt;《可重入锁和不可重入锁》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过简单代码举例说明可重入锁和不可重入锁。&lt;/li&gt;
&lt;li&gt;可重入锁指同一个线程可以再次获得之前已经获得的锁。&lt;/li&gt;
&lt;li&gt;可重入锁可以用户避免死锁。&lt;/li&gt;
&lt;li&gt;Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/baizhanshi/p/7211802.html&#34;&gt;《ReenTrantLock可重入锁（和synchronized的区别）总结》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized 使用方便，编译器来加锁，是非公平锁。&lt;/li&gt;
&lt;li&gt;ReenTrantLock 使用灵活，锁的公平性可以定制。&lt;/li&gt;
&lt;li&gt;相同加锁场景下，推荐使用 synchronized。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁-共享锁&#34;&gt;互斥锁 &amp;amp; 共享锁&lt;/h3&gt;
&lt;p&gt;互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。&lt;br&gt;
共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/liang1101/p/6475555.html&#34;&gt;《ReadWriteLock场景应用》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yunfenglw/article/details/45950305&#34;&gt;《“死锁”四个必要条件的合理解释》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥、持有、不可剥夺、环形等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u014039577/article/details/52351626&#34;&gt;Java如何查看死锁？&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JConsole 可以识别死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/bohu83/article/details/51135061&#34;&gt;java多线程系列：死锁及检测&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jstack 可以显示死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;操作系统&#34;&gt;操作系统&lt;/h1&gt;
&lt;h2 id=&#34;计算机原理&#34;&gt;计算机原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000003692840&#34;&gt;《操作系统基础知识——操作系统的原理，类型和结构》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;h3 id=&#34;多级缓存&#34;&gt;多级缓存&lt;/h3&gt;
&lt;p&gt;典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zero__007/article/details/54089730&#34;&gt;《从Java视角理解CPU缓存和伪共享》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/asdf_1024/article/details/78978437&#34;&gt;《线程的生命周期及状态转换详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;协程&#34;&gt;协程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thinksaas.cn/group/topic/839375/&#34;&gt;《终结python协程----从yield到actor模型的实现》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;线程的调度是由操作系统负责，协程调度是程序自行负责&lt;/li&gt;
&lt;li&gt;与线程相比，协程减少了无谓的操作系统切换.&lt;/li&gt;
&lt;li&gt;实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/linux/linux-command-manual.html&#34;&gt;《Linux 命令大全》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;设计模式&#34;&gt;设计模式&lt;/h1&gt;
&lt;h2 id=&#34;设计模式的六大原则&#34;&gt;设计模式的六大原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/q291611265/article/details/48465113&#34;&gt;《设计模式的六大原则》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。&lt;/li&gt;
&lt;li&gt;里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。&lt;/li&gt;
&lt;li&gt;依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。&lt;/li&gt;
&lt;li&gt;接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。&lt;/li&gt;
&lt;li&gt;迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。&lt;/li&gt;
&lt;li&gt;合成复用原则：尽量使用合成/聚合,而不是使用继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23种常见设计模式&#34;&gt;23种常见设计模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/design-pattern/design-pattern-tutorial.html&#34;&gt;《设计模式》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/susanws/p/5510229.html&#34;&gt;《23种设计模式全解析》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.jobbole.com/62314/&#34;&gt;《细数JDK里的设计模式》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构型模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。&lt;/li&gt;
&lt;li&gt;桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；&lt;/li&gt;
&lt;li&gt;组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。&lt;/li&gt;
&lt;li&gt;装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。&lt;/li&gt;
&lt;li&gt;享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。&lt;/li&gt;
&lt;li&gt;代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。&lt;/li&gt;
&lt;li&gt;建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。&lt;/li&gt;
&lt;li&gt;工厂方法：就是 &lt;strong&gt;一个返&lt;/strong&gt;* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。&lt;/li&gt;
&lt;li&gt;原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。&lt;/li&gt;
&lt;li&gt;单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行为模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。&lt;/li&gt;
&lt;li&gt;命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。&lt;/li&gt;
&lt;li&gt;解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。&lt;/li&gt;
&lt;li&gt;迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。&lt;/li&gt;
&lt;li&gt;中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。&lt;/li&gt;
&lt;li&gt;空对象模式：如 java.util.Collections#emptyList()。&lt;/li&gt;
&lt;li&gt;观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。&lt;/li&gt;
&lt;li&gt;模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/hwaggLee/p/4510687.html&#34;&gt;《Spring-涉及到的设计模式汇总》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u012387062/article/details/54719114&#34;&gt;《Mybatis使用的设计模式》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/YECrazy/article/details/79481964&#34;&gt;《单例模式的三种实现 以及各自的优缺点》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ttylinux/p/6498822.html&#34;&gt;《单例模式－－反射－－防止序列化破坏单例模式》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;使用枚举类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/design-pattern/mvc-pattern.html&#34;&gt;《MVC 模式》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;模型(model)－视图(view)－控制器(controller)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ioc&#34;&gt;IOC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/23277575&#34;&gt;《理解 IOC》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/NancyStartOnce/p/6813162.html&#34;&gt;《IOC 的理解与解释》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;正向控制：传统通过new的方式。反向控制，通过容器注入对象。&lt;/li&gt;
&lt;li&gt;作用：用于模块解耦。&lt;/li&gt;
&lt;li&gt;DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/yanquan345/blog/203415&#34;&gt;《轻松理解AOP(面向切面编程)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hongwz/p/5764917.html&#34;&gt;《Spring AOP详解》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/24305.html&#34;&gt;《Spring AOP的实现原理》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/&#34;&gt;《Spring AOP 实现原理与 CGLIB 应用》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uml&#34;&gt;UML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3cschool.cn/uml_tutorial/&#34;&gt;《UML教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;微服务思想&#34;&gt;微服务思想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wintersun/p/6219259.html&#34;&gt;《微服务架构设计》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/micro-service-technology-stack&#34;&gt;《微服务架构技术栈选型手册》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;康威定律&#34;&gt;康威定律&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/8611&#34;&gt;《微服务架构的理论基础 - 康威定律》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。&lt;/li&gt;
&lt;li&gt;定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。&lt;/li&gt;
&lt;li&gt;定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。&lt;/li&gt;
&lt;li&gt;定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf&#34;&gt;《微服务架构核⼼20讲》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;运维-统计-技术支持&#34;&gt;运维 &amp;amp; 统计 &amp;amp; 技术支持&lt;/h1&gt;
&lt;h2 id=&#34;常规监控&#34;&gt;常规监控&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/enweitech/article/details/77849205&#34;&gt;《腾讯业务系统监控的修炼之路》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控的方式：主动、被动、旁路(比如舆情监控)&lt;/li&gt;
&lt;li&gt;监控类型： 基础监控、服务端监控、客户端监控、&lt;br&gt;
监控、用户端监控&lt;/li&gt;
&lt;li&gt;监控的目标：全、块、准&lt;/li&gt;
&lt;li&gt;核心指标：请求量、成功率、耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oschina.net/news/67525/monitoring-tools&#34;&gt;《开源还是商用？十大云运维监控工具横评》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.51cto.com/art/201612/525373.htm&#34;&gt;《监控报警系统搭建及二次开发经验》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令行监控工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html&#34;&gt;《常用命令行监控工具》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;top、sar、tsar、nload&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.jobbole.com/96846/&#34;&gt;《20个命令行工具监控 Linux 系统性能》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/feichexia/blog/196575&#34;&gt;《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;apm&#34;&gt;APM&lt;/h2&gt;
&lt;p&gt;APM —  Application Performance Management&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://bigbully.github.io/Dapper-translation/&#34;&gt;《Dapper，大规模分布式系统的跟踪系统》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://opentracing.io&#34;&gt;CNCF OpenTracing&lt;/a&gt;，&lt;a href=&#34;https://github.com/opentracing-contrib/opentracing-specification-zh&#34;&gt;中文版&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要开源软件，按字母排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;Apache SkyWalking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dianping/cat&#34;&gt;CAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jaegertracing/jaeger&#34;&gt;CNCF jaeger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/naver/pinpoint&#34;&gt;Pinpoint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openzipkin/zipkin&#34;&gt;Zipkin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/apm-Pinpoint-practice&#34;&gt;《开源APM技术选型与实战》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;统计分析&#34;&gt;统计分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/25195217&#34;&gt;《流量统计的基础：埋点》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.25xt.com/company/17066.html&#34;&gt;《APP埋点常用的统计工具、埋点目标和埋点内容》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tech.meituan.com/mt-mobile-analytics-practice.html&#34;&gt;《美团点评前端无痕埋点实践》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;持续集成cicd&#34;&gt;持续集成(CI/CD)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&#34;&gt;《持续集成是什么？》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.testwo.com/article/1170&#34;&gt;《8个流行的持续集成工具》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000&#34;&gt;《使用Jenkins进行持续集成》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;环境分离&#34;&gt;环境分离&lt;/h3&gt;
&lt;p&gt;开发、测试、生成环境分离。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/sancuo/blog/214904&#34;&gt;《开发环境、生产环境、测试环境的基本理解和区》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自动化运维&#34;&gt;自动化运维&lt;/h2&gt;
&lt;h3 id=&#34;ansible&#34;&gt;Ansible&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ansible.com.cn/&#34;&gt;《Ansible中文权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/heiye123/articles/7855890.html&#34;&gt;《Ansible基础配置和企业级项目实用案例》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;puppet&#34;&gt;puppet&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/keerya/p/8040071.html&#34;&gt;《自动化运维工具——puppet详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;chef&#34;&gt;chef&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/&#34;&gt;《Chef 的安装与使用》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;h3 id=&#34;tdd-理论&#34;&gt;TDD 理论&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/62f16cd4fef3&#34;&gt;《深度解读 - TDD（测试驱动开发）》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.&lt;/li&gt;
&lt;li&gt;好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单元测试&#34;&gt;单元测试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/happyzm/p/6482886.html&#34;&gt;《Java单元测试之JUnit篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hotdust/article/details/53406086&#34;&gt;《JUnit 4 与 TestNG 对比》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;TestNG 覆盖 JUnit 功能，适用于更复杂的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wqetfg/article/details/50900512&#34;&gt;《单元测试主要的测试功能点》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;压力测试&#34;&gt;压力测试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/blueheart20/article/details/52170790&#34;&gt;《Apache ab 测试使用指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/binyue/p/6141088.html&#34;&gt;《大型网站压力测试及优化方案》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.chinabyte.com/466/14126966.shtml&#34;&gt;《10大主流压力/负载/性能测试工具推荐》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://quentinxxz.iteye.com/blog/2249799&#34;&gt;《真实流量压测工具 tcpcopy应用浅析》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/jwentest/p/7136727.html&#34;&gt;《nGrinder 简易使用教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全链路压测&#34;&gt;全链路压测&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot&#34;&gt;《京东618：升级全链路压测方案，打造军演机器人ForceBot》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/30306892&#34;&gt;《饿了么全链路压测的探索与实践》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28355759&#34;&gt;《四大语言，八大框架｜滴滴全链路压测解决之道》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/27060fd61f72&#34;&gt;《全链路压测经验》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ab-灰度-蓝绿测试&#34;&gt;A/B 、灰度、蓝绿测试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://testerhome.com/topics/11165&#34;&gt;《技术干货 | AB 测试和灰度发布探索及实践》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.51cto.com/purplegrape/1403123&#34;&gt;《nginx 根据IP 进行灰度发布》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.v2ex.com/t/344341&#34;&gt;《蓝绿部署、A/B 测试以及灰度发布》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/enweitech/article/details/52910082&#34;&gt;《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kvm&#34;&gt;KVM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-20201831-id-5775661.html&#34;&gt;《KVM详解，太详细太深入了，经典》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coderxing.com/kvm-install.html&#34;&gt;《【图文】KVM 虚拟机安装详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xen&#34;&gt;Xen&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/sddai/p/5931201.html&#34;&gt;《Xen虚拟化基本原理详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;openvz&#34;&gt;OpenVZ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/longerzone/article/details/44829255&#34;&gt;《开源Linux容器 OpenVZ 快速上手指南》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;容器技术&#34;&gt;容器技术&lt;/h2&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/SzeCheng/p/6822905.html&#34;&gt;《几张图帮你理解 docker 基本原理及快速入门》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://draveness.me/docker&#34;&gt;《Docker 核心技术与实现原理》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/docker/docker-tutorial.html&#34;&gt;《Docker 教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云技术&#34;&gt;云技术&lt;/h2&gt;
&lt;h3 id=&#34;openstack&#34;&gt;OpenStack&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/klb561/p/8660264.html&#34;&gt;《OpenStack构架知识梳理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;devops&#34;&gt;DevOps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/jetzhang/p/6068773.html&#34;&gt;《一分钟告诉你究竟DevOps是什么鬼？》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/detail-analysis-of-devops&#34;&gt;《DevOps详解》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文档管理&#34;&gt;文档管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.confluence.cn/&#34;&gt;Confluence-收费文档管理系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitLab?&lt;/li&gt;
&lt;li&gt;Wiki&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中间件&#34;&gt;中间件&lt;/h1&gt;
&lt;h2 id=&#34;web-server&#34;&gt;Web Server&lt;/h2&gt;
&lt;h3 id=&#34;nginx&#34;&gt;Nginx&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_25797077/article/details/52200722&#34;&gt;《Ngnix的基本学习-多进程和Apache的比较》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。&lt;/li&gt;
&lt;li&gt;事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/cunkouzh/p/5410154.html&#34;&gt;《nginx与Apache的对比以及优缺点》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nginx只适合静态和反向代理，不适合处理动态请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;openresty&#34;&gt;OpenResty&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openresty.org/cn/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linkedkeeper.com/detail/blog.action?bid=1034&#34;&gt;《浅谈 OpenResty》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;通过 Lua 模块可以在Nginx上进行开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;apache-httpd&#34;&gt;Apache Httpd&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://httpd.apache.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tomcat&#34;&gt;Tomcat&lt;/h3&gt;
&lt;h4 id=&#34;架构原理&#34;&gt;架构原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/hggen/p/6264475.html&#34;&gt;《TOMCAT原理详解及请求过程》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/crazylqy/p/4706223.html&#34;&gt;《Tomcat服务器原理详解》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/&#34;&gt;《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/xlgen157387/article/details/79006434&#34;&gt;《四张图带你了解Tomcat系统架构》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/&#34;&gt;《JBoss vs. Tomcat: Choosing A Java Application Server》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。&lt;/li&gt;
&lt;li&gt;Jboss 实现全部了JEE特性，软件开源免费、文档收费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调优方案&#34;&gt;调优方案&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/sunfenqing/p/7339058.html&#34;&gt;《Tomcat 调优方案》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-20662363-id-3012760.html&#34;&gt;《tomcat http协议与ajp协议》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://dmouse.iteye.com/blog/1354527&#34;&gt;《AJP与HTTP比较和分析》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。&lt;/li&gt;
&lt;li&gt;并发高时，AJP协议优于HTTP协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jetty&#34;&gt;Jetty&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;《Jetty 的工作原理以及与 Tomcat 的比较》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/doutao6677/article/details/51957288&#34;&gt;《jetty和tomcat优势比较》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;架构比较:Jetty的架构比Tomcat的更为简单。&lt;/li&gt;
&lt;li&gt;性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。&lt;/li&gt;
&lt;li&gt;其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/clementad/article/details/48229243&#34;&gt;《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地缓存&#34;&gt;本地缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html&#34;&gt;《HashMap本地缓存》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html&#34;&gt;《EhCache本地缓存》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆内、堆外、磁盘三级缓存。&lt;/li&gt;
&lt;li&gt;可按照缓存空间容量进行设置。&lt;/li&gt;
&lt;li&gt;按照时间、次数等过期策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html&#34;&gt;《Guava Cache》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单轻量、无堆外、磁盘缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html&#34;&gt;《Nginx本地缓存》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html&#34;&gt;《Pagespeed—懒人工具，服务器端加速》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;客户端缓存&#34;&gt;客户端缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html&#34;&gt;《浏览器端缓存》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是利用 Cache-Control 参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w&#34;&gt;《H5 和移动端 WebView 缓存机制解析与实战》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务端缓存&#34;&gt;服务端缓存&lt;/h2&gt;
&lt;h3 id=&#34;web缓存&#34;&gt;Web缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jiangwenyuan/nuster&#34;&gt;nuster&lt;/a&gt; - nuster cache&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/varnishcache/varnish-cache&#34;&gt;varnish&lt;/a&gt; - varnish cache&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/squid-cache/squid&#34;&gt;squid&lt;/a&gt; - squid cache&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memcached&#34;&gt;Memcached&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.runoob.com/Memcached/Memcached-tutorial.html&#34;&gt;《Memcached 教程》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/chenleixing/article/details/47035453&#34;&gt;《深入理解Memcached原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用多路复用技术提高并发性。&lt;/li&gt;
&lt;li&gt;slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/36e5cd400580&#34;&gt;《Memcached软件工作原理》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://zhihuzeye.com/archives/2361&#34;&gt;《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liu251890347/article/details/37690045&#34;&gt;《memcache 中 add 、 set 、replace 的区别》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别在于当key存在还是不存在时，返回值是true和false的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://pan.baidu.com/s/1qX00Lti?errno=0&amp;amp;errmsg=Auth%20Login%20Sucess&amp;amp;&amp;amp;bduss=&amp;amp;ssnerror=0&amp;amp;traceid=&#34;&gt;&lt;strong&gt;《memcached全面剖析》&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.runoob.com/redis/redis-tutorial.html&#34;&gt;《Redis 教程》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/wcf373722432/article/details/78678504&#34;&gt;《redis底层原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。&lt;/li&gt;
&lt;li&gt;使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://doc.redisfans.com/topic/persistence.html&#34;&gt;《Redis持久化方式》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。&lt;/li&gt;
&lt;li&gt;AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。&lt;/li&gt;
&lt;li&gt;也可以两者结合使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/chunlongyu/article/details/53346436&#34;&gt;《分布式缓存--序列3--原子操作与CAS乐观锁》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;架构&#34;&gt;架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sunhuiliang85/article/details/73656830&#34;&gt;《Redis单线程架构》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;回收策略&#34;&gt;回收策略&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_29108585/article/details/63251491&#34;&gt;《redis的回收策略》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tair&#34;&gt;Tair&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/tair&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/farphone/article/details/53522383&#34;&gt;《Tair和Redis的对比》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;特点：可以配置备份节点数目，通过异步同步到备份节点&lt;/li&gt;
&lt;li&gt;一致性Hash算法。&lt;/li&gt;
&lt;li&gt;架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种存储引擎:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MDB，完全内存性，可以用来存储Session等数据。&lt;/li&gt;
&lt;li&gt;Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作&lt;/li&gt;
&lt;li&gt;LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。&lt;/li&gt;
&lt;li&gt;Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列&#34;&gt;消息队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/charlesblc/p/6045238.html&#34;&gt;《消息队列-推/拉模式学习 &amp;amp; ActiveMQ及JMS学习》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RabbitMQ 消费者默认是推模式（也支持拉模式）。&lt;/li&gt;
&lt;li&gt;Kafka 默认是拉模式。&lt;/li&gt;
&lt;li&gt;Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。&lt;/li&gt;
&lt;li&gt;Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yunfeng482/article/details/72856762&#34;&gt;《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息总线&#34;&gt;消息总线&lt;/h3&gt;
&lt;p&gt;消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yanghua_kobe/article/details/43877281&#34;&gt;《消息总线VS消息队列》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息的顺序&#34;&gt;消息的顺序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/cjsblog/p/8267892.html&#34;&gt;《如何保证消费者接收消息的顺序》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rabbitmq&#34;&gt;RabbitMQ&lt;/h3&gt;
&lt;p&gt;支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/whoamiyang/article/details/54954780&#34;&gt;《RabbitMQ的应用场景以及基本原理介绍》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/79ca08116d57&#34;&gt;《消息队列之 RabbitMQ》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u013256816/article/details/55515234&#34;&gt;《RabbitMQ之消息确认机制（事务+Confirm）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rocketmq&#34;&gt;RocketMQ&lt;/h3&gt;
&lt;p&gt;Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/824066d70da8&#34;&gt;《RocketMQ 实战之快速入门》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iocoder.cn/categories/RocketMQ/?vip&amp;amp;architect-awesome&#34;&gt;《RocketMQ 源码解析》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;activemq&#34;&gt;ActiveMQ&lt;/h3&gt;
&lt;p&gt;纯Java实现，兼容JMS，可以内嵌于Java应用中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wintersun/p/3962302.html&#34;&gt;《ActiveMQ消息队列介绍》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kafka&#34;&gt;Kafka&lt;/h3&gt;
&lt;p&gt;高吞吐量、采用拉模式。适合高IO场景，比如日志同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/allthesametome/article/details/47362451&#34;&gt;《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lxw1234.com/archives/2015/10/538.htm&#34;&gt;《Kafka分区机制介绍与示例》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis-消息推送&#34;&gt;Redis 消息推送&lt;/h3&gt;
&lt;p&gt;生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_34212276/article/details/78455004&#34;&gt;《Redis学习笔记之十：Redis用作消息队列》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zeromq&#34;&gt;ZeroMQ&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;定时调度&#34;&gt;定时调度&lt;/h2&gt;
&lt;h3 id=&#34;单机定时调度&#34;&gt;单机定时调度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/shuaiqing/p/7742382.html&#34;&gt;《linux定时任务cron配置》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/daquan/blog/483305&#34;&gt;《Linux cron运行原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork 进程 + sleep 轮询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/drift-ice/p/3817269.html&#34;&gt;《Quartz使用总结》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/wenniuwuren/article/details/42082981/&#34;&gt;《Quartz源码解析 ---- 触发器按时启动原理》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/bab8e4e32952&#34;&gt;《quartz原理揭秘和源码解读》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式定时调度&#34;&gt;分布式定时调度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_16216221/article/details/70314337&#34;&gt;《这些优秀的国产分布式任务调度系统，你用过几个？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html&#34;&gt;《Quartz任务调度的基本实现原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;amp;architect-awesome&#34;&gt;《Elastic-Job-Lite 源码解析》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;amp;architect-awesome&#34;&gt;《Elastic-Job-Cloud 源码解析》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rpc&#34;&gt;RPC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/top_code/article/details/54615853&#34;&gt;《从零开始实现RPC框架 - RPC原理及实现》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/testcs_dn/article/details/78050590&#34;&gt;《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dubbo.apache.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/steven520213/p/7606598.html&#34;&gt;dubbo实现原理简单介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** SPI **&lt;br&gt;
TODO&lt;/p&gt;
&lt;h3 id=&#34;thrift&#34;&gt;Thrift&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://thrift.apache.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/kesonyk/article/details/50924489&#34;&gt;《Thrift RPC详解》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;支持多语言，通过中间语言定义接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;服务端可以认证加密，在外网环境下，可以保证数据安全。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://grpc.io/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/LBSer/p/4853234.html&#34;&gt;《你应该知道的RPC原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库中间件&#34;&gt;数据库中间件&lt;/h2&gt;
&lt;h3 id=&#34;sharding-jdbc&#34;&gt;Sharding Jdbc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://shardingjdbc.io/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志系统&#34;&gt;日志系统&lt;/h2&gt;
&lt;h3 id=&#34;日志搜集&#34;&gt;日志搜集&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cjting.me/misc/build-log-system-with-elkb/&#34;&gt;《从零开始搭建一个ELKB日志收集系统》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lzw_2006/article/details/51280058&#34;&gt;《用ELK搭建简单的日志收集分析系统》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/beginmind/p/6058194.html&#34;&gt;《日志收集系统-探究》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置中心&#34;&gt;配置中心&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ctripcorp/apollo&#34;&gt;Apollo - 携程开源的配置中心应用&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot 和 Spring Cloud&lt;/li&gt;
&lt;li&gt;支持推、拉模式更新配置&lt;/li&gt;
&lt;li&gt;支持多种语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011320740/article/details/78742625&#34;&gt;《基于zookeeper实现统一配置管理》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/shamo89/p/8016908.html&#34;&gt;《 Spring Cloud Config 分布式配置中心使用教程》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;servlet 3.0 异步特性可用于配置中心的客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/dogdogwang/p/7151866.html&#34;&gt;《servlet3.0 新特性——异步处理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api-网关&#34;&gt;API 网关&lt;/h2&gt;
&lt;p&gt;主要职责：请求转发、安全认证、协议转换、容灾。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/&#34;&gt;《API网关那些儿》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo&#34;&gt;《谈API网关的背景、架构以及落地方案》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zhanglh046/article/details/78651993&#34;&gt;《使用Zuul构建API Gateway》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;amp;architect-awesome&#34;&gt;《Spring Cloud Gateway 源码解析》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A&#34;&gt;《HTTP API网关选择之一Kong介绍》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;网络&#34;&gt;网络&lt;/h1&gt;
&lt;h2 id=&#34;协议&#34;&gt;协议&lt;/h2&gt;
&lt;h3 id=&#34;osi-七层协议&#34;&gt;OSI 七层协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/Robin-YB/p/6668762.html&#34;&gt;《OSI七层协议模型、TCP/IP四层模型学习笔记》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcpip&#34;&gt;TCP/IP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/onepixel/p/7092302.html&#34;&gt;《深入浅出 TCP/IP 协议》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/whuslei/article/details/6667471/&#34;&gt;《TCP协议中的三次握手和四次挥手》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wangning528/p/6388464.html&#34;&gt;《http协议详解(超详细)》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http20&#34;&gt;HTTP2.0&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zhuyiquan/article/details/69257126&#34;&gt;《HTTP 2.0 原理详细分析》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u012657197/article/details/77877840&#34;&gt;《HTTP2.0的基本单位为二进制帧》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;利用二进制帧负责传输。&lt;/li&gt;
&lt;li&gt;多路复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;https&#34;&gt;HTTPS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhangshitong/p/6478721.html&#34;&gt;《https原理通俗了解》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用非对称加密协商加密算法&lt;/li&gt;
&lt;li&gt;使用对称加密方式传输数据&lt;/li&gt;
&lt;li&gt;使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/enweitech/article/details/53213862&#34;&gt;《八大免费SSL证书-给你的网站免费添加Https安全加密》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络模型&#34;&gt;网络模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.51cto.com/litaotao/1289790&#34;&gt;《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。&lt;/li&gt;
&lt;li&gt;三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/Anker/p/3265058.html&#34;&gt;《select、poll、epoll之间的区别总结》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。&lt;/li&gt;
&lt;li&gt;select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。&lt;/li&gt;
&lt;li&gt;select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。&lt;/li&gt;
&lt;li&gt;poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/&#34;&gt;《select，poll，epoll比较  》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/geason/p/5774096.html&#34;&gt;《深入理解Java NIO》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/skiof007/article/details/52873421&#34;&gt;《BIO与NIO、AIO的区别》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u013074465/article/details/46276967&#34;&gt;《两种高效的服务器设计模型：Reactor和Proactor模型》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;epoll&#34;&gt;Epoll&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html&#34;&gt;《epoll使用详解（精髓）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java-nio&#34;&gt;Java NIO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/geason/p/5774096.html&#34;&gt;《深入理解Java NIO》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xidianliuy/article/details/51612676&#34;&gt;《Java NIO编写Socket服务器的一个例子》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kqueue&#34;&gt;kqueue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/luminocean/p/5631336.html&#34;&gt;《kqueue用法简介》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连接和短连接&#34;&gt;连接和短连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/pangguoping/p/5571422.html&#34;&gt;《TCP/IP系列——长连接与短连接的区别》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;框架&#34;&gt;框架&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/excellentyuxiao/article/details/53390408&#34;&gt;《Netty原理剖析》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Reactor 模式介绍。&lt;/li&gt;
&lt;li&gt;Netty 是 Reactor 模式的一种实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;零拷贝zero-copy&#34;&gt;零拷贝（Zero-copy）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xys1228/p/6088805.html&#34;&gt;《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;序列化二进制协议&#34;&gt;序列化(二进制协议)&lt;/h2&gt;
&lt;h3 id=&#34;hessian&#34;&gt;Hessian&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/happyday56/p/4268249.html&#34;&gt;《Hessian原理分析》&lt;/a&gt;&lt;br&gt;
Binary-RPC;不仅仅是序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protobuf&#34;&gt;Protobuf&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/antgan/article/details/52103966&#34;&gt;《Protobuf协议的Java应用例子》&lt;/a&gt;&lt;br&gt;
Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://worktile.com/tech/share/prototol-buffers&#34;&gt;《Protocol Buffers序列化协议及应用》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于协议的解释；缺点：可读性差;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/eric520zenobia/article/details/53766571&#34;&gt;《简单的使用 protobuf 和 protostuff》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据库&#34;&gt;数据库&lt;/h1&gt;
&lt;h2 id=&#34;基础理论&#34;&gt;基础理论&lt;/h2&gt;
&lt;h3 id=&#34;数据库设计的三大范式&#34;&gt;数据库设计的三大范式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/waj6511988/p/7027127.html&#34;&gt;《数据库的三大范式以及五大约束》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；&lt;/li&gt;
&lt;li&gt;第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；&lt;/li&gt;
&lt;li&gt;第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql&#34;&gt;MySQL&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.admin10000.com/document/5372.html&#34;&gt;《MySQL的InnoDB索引原理详解》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/xifeijian/article/details/20316775&#34;&gt;《MySQL存储引擎－－MyISAM与InnoDB区别》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.2cto.com/database/201211/172380.html&#34;&gt;《myisam和innodb索引实现的不同》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;innodb&#34;&gt;InnoDB&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/kailuncen/blog/1504217&#34;&gt;《一篇文章带你读懂Mysql和InnoDB》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://vdisk.weibo.com/s/muWOT&#34;&gt;《MySQL36条军规》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhouyusheng/p/8038224.html&#34;&gt;《MYSQL性能优化的最佳20+条经验》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/when_less_is_more/article/details/70187459&#34;&gt;《SQL优化之道》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/sivkun/p/7518540.html&#34;&gt;《mysql数据库死锁的产生原因及解决办法》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/monkey_d_feilong/article/details/52291556&#34;&gt;《导致索引失效的可能情况》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zy_281870667/article/details/51604540&#34;&gt;《 MYSQL分页limit速度太慢优化方法》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原则上就是缩小扫描范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;
&lt;h4 id=&#34;聚集索引-非聚集索引&#34;&gt;聚集索引, 非聚集索引&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/no_endless/article/details/77073549&#34;&gt;《MySQL 聚集索引/非聚集索引简述》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/zlcxbb/p/5757245.html&#34;&gt;《MyISAM和InnoDB的索引实现》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MyISAM 是非聚集，InnoDB 是聚集&lt;/p&gt;
&lt;h4 id=&#34;复合索引&#34;&gt;复合索引&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/summer0space/p/7247778.html&#34;&gt;《复合索引的优点和注意事项》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;自适应哈希索引ahi&#34;&gt;自适应哈希索引(AHI)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/Linux_ever/article/details/62043708&#34;&gt;《InnoDB存储引擎——自适应哈希索引》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;explain&#34;&gt;explain&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000008131735&#34;&gt;《MySQL 性能优化神器 Explain 使用分析》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nosql&#34;&gt;NoSQL&lt;/h2&gt;
&lt;h3 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/mongodb/mongodb-tutorial.html&#34;&gt;MongoDB 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mxdxm.iteye.com/blog/2093603&#34;&gt;《Mongodb相对于关系型数据库的优缺点》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；&lt;/li&gt;
&lt;li&gt;缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hbase&#34;&gt;Hbase&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.thebigdata.cn/HBase/35831.html&#34;&gt;《简明 HBase 入门教程（开篇）》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/qiaoyihang/p/6246424.html&#34;&gt;《深入学习HBase架构原理》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/youzhouliu/article/details/67632882&#34;&gt;《传统的行存储和（HBase）列存储的区别》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lifuxiangcaohui/article/details/39891099&#34;&gt;《Hbase与传统数据库的区别》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空数据不存储，节省空间，且适用于并发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u014091123/article/details/73163088&#34;&gt;《HBase Rowkey设计》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rowkey 按照字典顺序排列，便于批量扫描。&lt;/li&gt;
&lt;li&gt;通过散列可以避免热点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;搜索引擎&#34;&gt;搜索引擎&lt;/h1&gt;
&lt;h2 id=&#34;搜索引擎原理&#34;&gt;搜索引擎原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/0193dc44135b&#34;&gt;《倒排索引--搜索引擎入门》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lucene&#34;&gt;Lucene&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/rodge-run/p/6551152.html&#34;&gt;《Lucene入门简介》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;elasticsearch&#34;&gt;Elasticsearch&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/laoyang360/article/details/52244917&#34;&gt;《Elasticsearch学习，请先看这一篇！》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/cyony/article/details/65437708&#34;&gt;《Elasticsearch索引原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;solr&#34;&gt;Solr&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u011936655/article/details/51960005&#34;&gt;《 Apache Solr入门教程》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/convict_eva/article/details/53537837&#34;&gt;《elasticsearch与solr比较》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sphinx&#34;&gt;sphinx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/101672/&#34;&gt;《Sphinx 的介绍和原理探索》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;性能&#34;&gt;性能&lt;/h1&gt;
&lt;h2 id=&#34;性能优化方法论&#34;&gt;性能优化方法论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread&#34;&gt;《15天的性能优化工作，5方面的调优经验》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码层面、业务层面、数据库层面、服务器层面、前端优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/tenglizhe/article/details/44563135&#34;&gt;《系统性能优化的几个方面》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;容量评估&#34;&gt;容量评估&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u012528360/article/details/70054156&#34;&gt;《联网性能与容量评估的方法论和典型案例》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=2651959542&amp;amp;idx=1&amp;amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;amp;scene=21#wechat_redirect&#34;&gt;《互联网架构，如何进行容量设计？》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cdn-网络&#34;&gt;CDN 网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wxiaona/p/5867685.html&#34;&gt;《CDN加速原理》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/20536932&#34;&gt;《国内有哪些比较好的 CDN？》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连接池&#34;&gt;连接池&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/fysuccess/article/details/66972554&#34;&gt;《主流Java数据库连接池比较与开发配置实战》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能调优&#34;&gt;性能调优&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yethyeth/article/details/73266455&#34;&gt;《九大Java性能调试工具，必备至少一款》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;大数据&#34;&gt;大数据&lt;/h1&gt;
&lt;h2 id=&#34;流式计算&#34;&gt;流式计算&lt;/h2&gt;
&lt;h3 id=&#34;storm&#34;&gt;Storm&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://storm.apache.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/uisoul/article/details/77989927&#34;&gt;《最详细的Storm入门教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flink&#34;&gt;Flink&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lisi1129/article/details/54844919&#34;&gt;《Flink之一 Flink基本原理介绍》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kafka-stream&#34;&gt;Kafka Stream&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/58382&#34;&gt;《Kafka Stream调研：一种轻量级流计算模式》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用场景-2&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广告相关实时统计；&lt;/li&gt;
&lt;li&gt;推荐系统用户画像标签实时更新；&lt;/li&gt;
&lt;li&gt;线上服务健康状况实时监测；&lt;/li&gt;
&lt;li&gt;实时榜单；&lt;/li&gt;
&lt;li&gt;实时数据统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hadoop&#34;&gt;Hadoop&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/houbin0912/article/details/72967178&#34;&gt;《用通俗易懂的话说下hadoop是什么,能做什么》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html&#34;&gt;《史上最详细的Hadoop环境搭建》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hdfs&#34;&gt;HDFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000011575458&#34;&gt;《【Hadoop学习】HDFS基本原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mapreduce&#34;&gt;MapReduce&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/oppo62258801/article/details/72884633&#34;&gt;《用通俗易懂的大白话讲解Map/Reduce原理》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/foye12/article/details/78358292&#34;&gt;《 简单的map-reduce的java例子》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;yarn&#34;&gt;Yarn&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/codeOfLife/p/5492740.html&#34;&gt;《初步掌握Yarn的架构及原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spark&#34;&gt;Spark&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/tgzhu/p/5818374.html&#34;&gt;《Spark(一): 基本架构及原理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;安全&#34;&gt;安全&lt;/h1&gt;
&lt;h2 id=&#34;web-安全&#34;&gt;web 安全&lt;/h2&gt;
&lt;h3 id=&#34;xss&#34;&gt;XSS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_21956483/article/details/54377947&#34;&gt;《xss攻击原理与解决方法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html&#34;&gt;《CSRF原理及防范》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sql-注入&#34;&gt;SQL 注入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html&#34;&gt;《SQL注入》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash-dos&#34;&gt;Hash Dos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/articles/web/14199.html&#34;&gt;《邪恶的JAVA HASH DOS攻击》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/92194?t=t1&#34;&gt;《一种高级的DoS攻击-Hash碰撞攻击》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iteye.com/news/23939/&#34;&gt;《关于Hash Collision DoS漏洞：解析与解决方案》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;脚本注入&#34;&gt;脚本注入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html&#34;&gt;《上传文件漏洞原理及防范》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;漏洞扫描工具&#34;&gt;漏洞扫描工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html&#34;&gt;《DVWA》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html&#34;&gt;W3af&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xygg0801/article/details/53610640&#34;&gt;OpenVAS详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;验证码&#34;&gt;验证码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/niaonao/article/details/51112686&#34;&gt;《验证码原理分析及实现》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/jiangbianwanghai/blog/1031031&#34;&gt;《详解滑动验证码的实现原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/xcj26/p/5242758.html&#34;&gt;《淘宝滑动验证码研究》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ddos-防范&#34;&gt;DDoS 防范&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://netsecurity.51cto.com/art/201601/503799.htm&#34;&gt;《学习手册：DDoS的攻击方式及防御手段》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://netsecurity.51cto.com/art/201406/442756.htm&#34;&gt;《免费DDoS攻击测试工具大合集》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户隐私信息保护&#34;&gt;用户隐私信息保护&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用户密码非明文保存，加动态salt。&lt;/li&gt;
&lt;li&gt;身份证号，手机号如果要显示，用 “*” 替代部分字符。&lt;/li&gt;
&lt;li&gt;联系方式在的显示与否由用户自己控制。&lt;/li&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhidao.baidu.com/question/1988017976673661587.html&#34;&gt;《个人隐私包括哪些》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/20137108&#34;&gt;《在互联网上，隐私的范围包括哪些？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html&#34;&gt;《用户密码保存》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;序列化漏洞&#34;&gt;序列化漏洞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/&#34;&gt;《Lib之过？Java反序列化漏洞通用利用分析》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;加密解密&#34;&gt;加密解密&lt;/h2&gt;
&lt;h3 id=&#34;对称加密&#34;&gt;对称加密&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html&#34;&gt;《常见对称加密算法》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;DES、3DES、Blowfish、AES&lt;/li&gt;
&lt;li&gt;DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。&lt;/li&gt;
&lt;li&gt;DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;哈希算法&#34;&gt;哈希算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html&#34;&gt;《常用的哈希算法》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MD5 和 SHA-1 已经不再安全，已被弃用。&lt;/li&gt;
&lt;li&gt;目前 SHA-256 是比较安全的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zhangruhong168/article/details/78033202&#34;&gt;《基于Hash摘要签名的公网URL签名验证设计方案》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非对称加密&#34;&gt;非对称加密&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html&#34;&gt;《常见非对称加密算法》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RSA、DSA、ECDSA(螺旋曲线加密算法)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;256位的ECC秘钥的安全性等同于3072位的RSA秘钥。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://baijiahao.baidu.com/s?id=1578348858092033763&amp;amp;wfr=spider&amp;amp;for=pc&#34;&gt;《区块链的加密技术》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务器安全&#34;&gt;服务器安全&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/articles/system/121540.html&#34;&gt;《Linux强化论：15步打造一个安全的Linux服务器》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据安全&#34;&gt;数据安全&lt;/h2&gt;
&lt;h3 id=&#34;数据备份&#34;&gt;数据备份&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;网络隔离&#34;&gt;网络隔离&lt;/h2&gt;
&lt;h3 id=&#34;内外网分离&#34;&gt;内外网分离&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;登录跳板机&#34;&gt;登录跳板机&lt;/h3&gt;
&lt;p&gt;在内外环境中通过跳板机登录到线上主机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.51cto.com/zero01/2062618&#34;&gt;《搭建简易堡垒机》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;授权-认证&#34;&gt;授权、认证&lt;/h2&gt;
&lt;h3 id=&#34;rbac&#34;&gt;RBAC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/zq8024/p/5003050.html&#34;&gt;《基于组织角色的权限设计》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/shijiaqi1066/p/3793894.html&#34;&gt;《权限系统与RBAC模型概述》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/he90227/article/details/38663553&#34;&gt;《Spring整合Shiro做权限控制模块详细案例分析》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oauth20&#34;&gt;OAuth2.0&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&#34;&gt;《理解OAuth 2.0》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/flashsun/p/7424071.html&#34;&gt;《一张图搞定OAuth2.0》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;双因素认证2fa&#34;&gt;双因素认证（2FA）&lt;/h3&gt;
&lt;p&gt;2FA - Two-factor authentication，用于加强登录验证&lt;/p&gt;
&lt;p&gt;常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单点登录sso&#34;&gt;单点登录(SSO)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/ywlaker/p/6113927.html&#34;&gt;《单点登录原理与简单实现》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apereo/cas&#34;&gt;CAS单点登录框架&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常用开源框架&#34;&gt;常用开源框架&lt;/h1&gt;
&lt;h2 id=&#34;开源协议&#34;&gt;开源协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html&#34;&gt;《开源协议的选择》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://choosealicense.online/&#34;&gt;如何选择一个开源软件协议&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志框架&#34;&gt;日志框架&lt;/h2&gt;
&lt;h3 id=&#34;log4j-log4j2&#34;&gt;Log4j、Log4j2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u012422446/article/details/51199724&#34;&gt;《log4j 详细讲解》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/vbirdbest/article/details/71751835&#34;&gt;《log4j2 实际使用详解》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/OutOfMemory/blog/789267&#34;&gt;《Log4j1,Logback以及Log4j2性能测试对比》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Log4J 异步日志性能优异。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;logback&#34;&gt;Logback&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/rulon147/article/details/52620541&#34;&gt;《最全LogBack 详解、含java案例和配置说明》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;orm&#34;&gt;ORM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sinat_34093604/article/details/53082000&#34;&gt;《ORM框架使用优缺点》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;主要目的是为了提高开发效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MyBatis：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/winclpt/articles/7511672.html&#34;&gt;《mybatis缓存机制详解》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效&lt;/li&gt;
&lt;li&gt;二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/baidu_32877851/article/details/53959268&#34;&gt;《MyBatis学习之代码生成器Generator》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络框架&#34;&gt;网络框架&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;web-框架&#34;&gt;Web 框架&lt;/h2&gt;
&lt;h3 id=&#34;spring-家族&#34;&gt;Spring 家族&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Spring&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3cschool.cn/wkspring/&#34;&gt;Spring 简明教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://projects.spring.io/spring-boot/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/&#34;&gt;《Spring Boot基础教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spring Cloud&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://springboot.fun/&#34;&gt;Spring Boot 中文索引站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://springcloud.cc/&#34;&gt;Spring Cloud 中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/&#34;&gt;《Spring Cloud基础教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工具框架&#34;&gt;工具框架&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/crazylqy/p/4872236.html&#34;&gt;《Apache Commons 工具类介绍及简单使用》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/google-guava/&#34;&gt;《Google guava 中文教程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分布式设计&#34;&gt;分布式设计&lt;/h1&gt;
&lt;h2 id=&#34;扩展性设计&#34;&gt;扩展性设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/hemin1003/article/details/53633926&#34;&gt;《架构师不可不知的十大可扩展架构》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结下来，通用的套路就是分布、缓存及异步处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/38119&#34;&gt;《可扩展性设计之数据切分》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平切分+垂直切分&lt;/li&gt;
&lt;li&gt;利用中间件进行分片如，MySQL Proxy。&lt;/li&gt;
&lt;li&gt;利用分片策略进行切分，如按照ID取模。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/deniro_li/article/details/78458306&#34;&gt;《说说如何实现可扩展性的大型网站架构》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式服务+消息队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/chaofanwei/article/details/29191073&#34;&gt;《大型网站技术架构（七）--网站的可扩展性架构》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;稳定性-高可用&#34;&gt;稳定性 &amp;amp; 高可用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/hustspy1990/article/details/78008324&#34;&gt;《系统设计：关于高可用系统的一些技术方案》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。&lt;/li&gt;
&lt;li&gt;隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。&lt;/li&gt;
&lt;li&gt;解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。&lt;/li&gt;
&lt;li&gt;限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。&lt;/li&gt;
&lt;li&gt;降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。&lt;/li&gt;
&lt;li&gt;熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。&lt;/li&gt;
&lt;li&gt;自动化测试：通过完善的测试，减少发布引起的故障。&lt;/li&gt;
&lt;li&gt;灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/17459.html&#34;&gt;《关于高可用的系统》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;硬件负载均衡&#34;&gt;硬件负载均衡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/wuyun-blog/p/6186198.html&#34;&gt;《转！！负载均衡器技术Nginx和F5的优缺点对比》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是和F5对比。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lcword/p/5773296.html&#34;&gt;《软/硬件负载均衡产品 你知多少？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软件负载均衡&#34;&gt;软件负载均衡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/tianzhiliang/articles/2317808.html&#34;&gt;《几种负载均衡算法》&lt;/a&gt;&lt;br&gt;
轮寻、权重、负载、最少连接、QoS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html&#34;&gt;《DNS负载均衡》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置简单，更新速度慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html&#34;&gt;《Nginx负载均衡》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单轻量、学习成本低；主要适用于web应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/edisonchou/p/4281978.html&#34;&gt;《借助LVS+Keepalived实现负载均衡 》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置比较负载、只支持到4层，性能较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ttlsa.com/linux/haproxy-study-tutorial/&#34;&gt;《HAProxy用法详解 全网最详细中文文档》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持到七层（比如HTTP）、功能比较全面，性能也不错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.itpub.net/25704976/viewspace-1319781/&#34;&gt;《Haproxy+Keepalived+MySQL实现读均衡负载》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是用户读请求的负载均衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lylife/p/5584019.html&#34;&gt;《rabbitmq+haproxy+keepalived实现高可用集群搭建》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;限流&#34;&gt;限流&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/haoxinyue/p/6792309.html&#34;&gt;《谈谈高并发系统的限流》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。&lt;/li&gt;
&lt;li&gt;漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。&lt;/li&gt;
&lt;li&gt;令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。&lt;/li&gt;
&lt;li&gt;Nginx 限流：通过 &lt;code&gt;limit_req&lt;/code&gt; 等模块限制并发连接数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用层容灾&#34;&gt;应用层容灾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000005988895&#34;&gt;《防雪崩利器：熔断器 Hystrix 的原理与使用》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。&lt;/li&gt;
&lt;li&gt;雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。&lt;/li&gt;
&lt;li&gt;Hystrix设计原则：
&lt;ul&gt;
&lt;li&gt;资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。&lt;/li&gt;
&lt;li&gt;熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。&lt;/li&gt;
&lt;li&gt;命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zeb_perfect/article/details/54135506&#34;&gt;《缓存穿透，缓存击穿，缓存雪崩解决方案分析》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/zeb_perfect/article/details/54135506&#34;&gt;《缓存击穿、失效以及热点key问题》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；&lt;/li&gt;
&lt;li&gt;热点数据：热点数据单独存储；使用本地缓存；分成多个子key；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;跨机房容灾&#34;&gt;跨机房容灾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://dc.idcquan.com/ywgl/71559.shtml&#34;&gt;《“异地多活”多机房部署经验谈》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过自研中间件进行数据同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jeffreynicole/article/details/48135093&#34;&gt;《异地多活（异地双活）实践经验》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意延迟问题，多次跨机房调用会将延时放大数倍。&lt;/li&gt;
&lt;li&gt;建房间专线很大概率会出现问题，做好运维和程序层面的容错。&lt;/li&gt;
&lt;li&gt;不能依赖于程序端数据双写，要有自动同步方案。&lt;/li&gt;
&lt;li&gt;数据永不在高延迟和较差网络质量下，考虑同步质量问题。&lt;/li&gt;
&lt;li&gt;核心业务和次要业务分而治之，甚至只考虑核心业务。&lt;/li&gt;
&lt;li&gt;异地多活监控部署、测试也要跟上。&lt;/li&gt;
&lt;li&gt;业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。&lt;/li&gt;
&lt;li&gt;控制跨机房消息体大小，越小越好。&lt;/li&gt;
&lt;li&gt;考虑使用docker容器虚拟化技术，提高动态调度能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yoara/article/details/38013751&#34;&gt;容灾技术及建设经验介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;容灾演练流程&#34;&gt;容灾演练流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2650996320&amp;amp;idx=1&amp;amp;sn=0ed3be190bbee4a9277886ef88cbb2e5&#34;&gt;《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;常见故障画像&lt;/li&gt;
&lt;li&gt;案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;平滑启动&#34;&gt;平滑启动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;平滑重启应用思路&lt;br&gt;
1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u011001084/article/details/73480432&#34;&gt;《JVM安全退出（如何优雅的关闭java服务）》&lt;/a&gt;&lt;br&gt;
推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://ju.outofmemory.cn/entry/337235&#34;&gt;《常见Java应用如何优雅关闭》&lt;/a&gt;&lt;br&gt;
Java、Srping、Dubbo 优雅关闭方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库扩展&#34;&gt;数据库扩展&lt;/h2&gt;
&lt;h3 id=&#34;读写分离模式&#34;&gt;读写分离模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/houdj/p/6563771.html&#34;&gt;《Mysql主从方案的实现》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/edisonchou/p/4133148.html&#34;&gt;《搭建MySQL主从复制经典架构》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/nimasike/article/details/48048341&#34;&gt;《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zhangsubai/p/6801764.html&#34;&gt;《DRBD+Heartbeat+Mysql高可用读写分离架构》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DRDB 进行磁盘复制，避免单点问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html&#34;&gt;《MySQL Cluster 方式》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分片模式&#34;&gt;分片模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/32b3e91aa22c&#34;&gt;《分库分表需要考虑的问题及方案》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。&lt;/li&gt;
&lt;li&gt;问题：事务、Join、迁移、扩容、ID、分页等。&lt;/li&gt;
&lt;li&gt;事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。&lt;/li&gt;
&lt;li&gt;分库策略：数值范围；取模；日期等。&lt;/li&gt;
&lt;li&gt;分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.2cto.com/database/201503/380348.html&#34;&gt;《MySql分表和表分区详解》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。&lt;/li&gt;
&lt;li&gt;分表：物理上创建不同的表、客户端需要管理分表路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务治理&#34;&gt;服务治理&lt;/h2&gt;
&lt;h3 id=&#34;服务注册与发现&#34;&gt;服务注册与发现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jiaolongdy/article/details/51188798&#34;&gt;《永不失联！如何实现微服务架构中的服务发现？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。&lt;/li&gt;
&lt;li&gt;服务器端服务发现模式：客户端通过负载均衡查询服务实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u010963948/article/details/71730165&#34;&gt;《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）&lt;/li&gt;
&lt;li&gt;作者认为目前 Consul 对 Spring cloud 的支持比较好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://mobile.51cto.com/news-502394.htm&#34;&gt;《基于Zookeeper的服务注册与发现》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务路由控制&#34;&gt;服务路由控制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/xundh/article/details/59492750&#34;&gt;《分布式服务框架学习笔记4 服务路由》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;原则：透明化路由&lt;/li&gt;
&lt;li&gt;负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接&lt;/li&gt;
&lt;li&gt;本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。&lt;/li&gt;
&lt;li&gt;配置方式：统一注册表；本地配置；动态下发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式一致&#34;&gt;分布式一致&lt;/h2&gt;
&lt;h3 id=&#34;cap-与-base-理论&#34;&gt;CAP 与 BASE 理论&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/szlbm/p/5588543.html&#34;&gt;《从分布式一致性谈到CAP理论、BASE理论》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)&lt;/li&gt;
&lt;li&gt;CAP：一致性、可用性、分区容错性(网络故障引起)&lt;/li&gt;
&lt;li&gt;BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）&lt;/li&gt;
&lt;li&gt;BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1716&#34;&gt;《分布式锁的几种实现方式》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；&lt;/li&gt;
&lt;li&gt;基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。&lt;/li&gt;
&lt;li&gt;Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tuicool.com/articles/VZJr6fY&#34;&gt;《基于Zookeeper的分布式锁》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清楚的原理描述 + Java 代码示例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/0201zcr/p/5942748.html&#34;&gt;《jedisLock—redis分布式锁实现》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/albertfly/article/details/77412333&#34;&gt;《Memcached 和 Redis 分布式锁方案》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 memcached 的 add（有别于set）操作，当key存在时，返回false。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式一致性算法&#34;&gt;分布式一致性算法&lt;/h3&gt;
&lt;h4 id=&#34;paxos&#34;&gt;PAXOS&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/linbingdong/p/6253479.html&#34;&gt;《分布式系列文章——Paxos算法原理与推导》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u010039929/article/details/70171672&#34;&gt;《Paxos--&amp;gt;Fast Paxos--&amp;gt;Zookeeper分析》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/leesf456/p/6012777.html&#34;&gt;《【分布式】Zookeeper与Paxos》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;zab&#34;&gt;Zab&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/fb527a64deee&#34;&gt;《Zab：Zookeeper 中的分布式一致性协议介绍》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;raft&#34;&gt;Raft&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/mindwind/p/5231986.html&#34;&gt;《Raft 为什么是更易理解的分布式一致性算法》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）&lt;/li&gt;
&lt;li&gt;通过随机等待的方式发出投票，得票多的获胜。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;gossip&#34;&gt;Gossip&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.51cto.com/tianya23/530743&#34;&gt;《Gossip算法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;两阶段提交-多阶段提交&#34;&gt;两阶段提交、多阶段提交&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/95632/&#34;&gt;《关于分布式事务、两阶段提交协议、三阶提交协议》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;幂等&#34;&gt;幂等&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wxgblogs/p/6639272.html&#34;&gt;《分布式系统---幂等性设计》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。&lt;/li&gt;
&lt;li&gt;常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式一致方案&#34;&gt;分布式一致方案&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency&#34;&gt;《分布式系统事务一致性解决方案》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://weibo.com/ttarticle/p/show?id=2309403965965003062676&#34;&gt;《保证分布式系统数据一致性的6种方案》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式-leader-节点选举&#34;&gt;分布式 Leader 节点选举&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/johnson_moon/article/details/78809995&#34;&gt;《利用zookeeper实现分布式leader节点选举》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcctryconfirmcancel-柔性事务&#34;&gt;TCC(Try/Confirm/Cancel) 柔性事务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/ab1a1c6b08a1&#34;&gt;《传统事务与柔性事务》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;基于BASE理论：基本可用、柔性状态、最终一致。&lt;/li&gt;
&lt;li&gt;解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式文件系统&#34;&gt;分布式文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/27666295&#34;&gt;说说分布式文件存储系统-基本架构&lt;/a&gt; ？&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/gatieme/article/details/44982961&#34;&gt;《各种分布式文件系统的比较》&lt;/a&gt; ？
&lt;ul&gt;
&lt;li&gt;HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。&lt;/li&gt;
&lt;li&gt;FastDFS：轻量级、适合小文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;唯一id-生成&#34;&gt;唯一ID 生成&lt;/h2&gt;
&lt;h3 id=&#34;全局唯一id&#34;&gt;全局唯一ID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/baiwa/p/5318432.html&#34;&gt;《高并发分布式系统中生成全局唯一Id汇总》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)&lt;/li&gt;
&lt;li&gt;Flicker 方案：MySQL自增ID + &amp;quot;REPLACE INTO XXX:SELECT LAST_INSERT_ID();&amp;quot;&lt;/li&gt;
&lt;li&gt;UUID：缺点，无序，字符串过长，占用空间，影响检索性能。&lt;/li&gt;
&lt;li&gt;MongoDB 方案：利用 ObjectId。缺点：不能自增。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/hdu09075340/article/details/79103851&#34;&gt;《TDDL 在分布式下的SEQUENCE原理》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。&lt;/li&gt;
&lt;li&gt;每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。&lt;/li&gt;
&lt;li&gt;客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一致性hash算法&#34;&gt;一致性Hash算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html&#34;&gt;《一致性哈希算法》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;设计思想-开发模式&#34;&gt;设计思想 &amp;amp; 开发模式&lt;/h1&gt;
&lt;h2 id=&#34;ddddomain-driven-design-领域驱动设计&#34;&gt;DDD(Domain-driven Design - 领域驱动设计)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/netfocus/p/5548025.html&#34;&gt;《浅谈我对DDD领域驱动设计的理解》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。&lt;/li&gt;
&lt;li&gt;过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。&lt;/li&gt;
&lt;li&gt;设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/butterfly100/p/7827870.html&#34;&gt;《领域驱动设计的基础知识总结》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。&lt;/li&gt;
&lt;li&gt;界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。&lt;/li&gt;
&lt;li&gt;领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；&lt;/li&gt;
&lt;li&gt;领域通用语言：领域专家、开发设计人员都能立即的语言或工具。&lt;/li&gt;
&lt;li&gt;经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。&lt;/li&gt;
&lt;li&gt;使用的模式：
&lt;ul&gt;
&lt;li&gt;关联尽量少，尽量单项，尽量降低整体复杂度。&lt;/li&gt;
&lt;li&gt;实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。&lt;/li&gt;
&lt;li&gt;值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。&lt;/li&gt;
&lt;li&gt;领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。&lt;/li&gt;
&lt;li&gt;聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；&lt;/li&gt;
&lt;li&gt;工厂（Factory）：类似于设计模式中的工厂模式。&lt;/li&gt;
&lt;li&gt;仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/Leo_wl/p/3866629.html&#34;&gt;《领域驱动设计(DDD)实现之路》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/553&#34;&gt;《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命令查询职责分离cqrs&#34;&gt;命令查询职责分离(CQRS)&lt;/h3&gt;
&lt;p&gt;CQRS — Command Query Responsibility Seperation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/cnblogsfans/p/4551990.html&#34;&gt;《领域驱动设计系列 (六)：CQRS》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml&#34;&gt;《DDD CQRS架构和传统架构的优缺点比较》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最终一致的设计理念；依赖于高可用消息中间件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/netfocus/p/4055346.html&#34;&gt;《CQRS架构简介》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个实现 CQRS 的抽象案例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.uml.org.cn/zjjs/201609221.asp&#34;&gt;《深度长文：我对CQRS/EventSourcing架构的思考》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CQRS 模式分析 + 12306 抢票案例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;贫血充血模型&#34;&gt;贫血，充血模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kb.cnblogs.com/page/520743/&#34;&gt;《贫血，充血模型的解释以及一些经验》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。&lt;/li&gt;
&lt;li&gt;贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；&lt;/li&gt;
&lt;li&gt;充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。&lt;/li&gt;
&lt;li&gt;肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。&lt;/li&gt;
&lt;li&gt;作者主张使用贫血模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;actor-模式&#34;&gt;Actor 模式&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;响应式编程&#34;&gt;响应式编程&lt;/h2&gt;
&lt;h3 id=&#34;reactor&#34;&gt;Reactor&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;rxjava&#34;&gt;RxJava&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;vertx&#34;&gt;Vert.x&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;dodaf20&#34;&gt;DODAF2.0&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml&#34;&gt;《DODAF2.0方法论》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.51cto.com/xiaoyong/1553164&#34;&gt;《DODAF2.0之能力视角如何落地》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;serverless&#34;&gt;Serverless&lt;/h2&gt;
&lt;p&gt;无需过多关系服务器的服务架构理念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jdon.com/soa/serverless.html&#34;&gt;《什么是Serverless无服务器架构？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。&lt;/li&gt;
&lt;li&gt;Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。&lt;/li&gt;
&lt;li&gt;Serverless 不代表某个具体的框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless&#34;&gt;《如何理解Serverless？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;service-mesh&#34;&gt;Service Mesh&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://time.geekbang.org/article/2355&#34;&gt;《什么是Service Mesh？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/e23e3e74538e&#34;&gt;《初识 Service Mesh》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://time.geekbang.org/article/2355&#34;&gt;《什么是Service Mesh？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;项目管理&#34;&gt;项目管理&lt;/h1&gt;
&lt;h2 id=&#34;架构评审&#34;&gt;架构评审&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.51cto.com/art/201506/478486.htm&#34;&gt;《架构设计之如何评审架构设计说明书》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wireless_com/article/details/45935591&#34;&gt;《人人都是架构师：非功能性需求》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重构&#34;&gt;重构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/architect-12-rules-complete/&#34;&gt;《架构之重构的12条军规》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码规范&#34;&gt;代码规范&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/p3c&#34;&gt;《阿里巴巴Java开发手册》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码-review&#34;&gt;代码 Review&lt;/h2&gt;
&lt;p&gt;制度还是制度!&lt;br&gt;
另外，每个公司需要根据自己的需求和目标制定自己的 check list&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sohu.com/a/229745352_181657&#34;&gt;《为什么你做不好 Code Review？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码 review 做的好，在于制度建设。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/uxyheaven/article/details/49773619&#34;&gt;《从零开始Code Review》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zuoping/p/5477047.html&#34;&gt;《Code Review Checklist》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/java-code-review-checklist&#34;&gt;《Java Code Review Checklist》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/legend0011/article/details/45585575&#34;&gt;《如何用 gitlab 做 code review》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rup&#34;&gt;RUP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/apanious/article/details/51011946&#34;&gt;《运用RUP 4+1视图方法进行软件架构设计》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;看板管理&#34;&gt;看板管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/tkchen/article/details/51637643&#34;&gt;《说说看板在项目中的应用》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;scrum&#34;&gt;SCRUM&lt;/h2&gt;
&lt;p&gt;SCRUM - 争球&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;五个价值观：专注、勇气、公开、承诺、尊重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/inny100_100/article/details/54633757&#34;&gt;《敏捷项目管理流程-Scrum框架最全总结！》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/superkunkun/article/details/52951142&#34;&gt;《敏捷其实很简单3---敏捷方法之scrum》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;敏捷开发&#34;&gt;敏捷开发&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;极限编程xp&#34;&gt;极限编程（XP）&lt;/h2&gt;
&lt;p&gt;XP - eXtreme Programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.woshipm.com/pmd/406917.html&#34;&gt;《主流敏捷开发方法：极限编程XP》&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是一种指导开发人员的方法论。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4大价值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沟通：鼓励口头沟通，提高效率。&lt;/li&gt;
&lt;li&gt;简单：够用就好。&lt;/li&gt;
&lt;li&gt;反馈：及时反馈、通知相关人。&lt;/li&gt;
&lt;li&gt;勇气：提倡拥抱变化，敢于重构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结对编程&#34;&gt;结对编程&lt;/h2&gt;
&lt;p&gt;边写码，边review。能够增强代码质量、减少bug。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B&#34;&gt;《结对编程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pdca-循环质量管理&#34;&gt;PDCA 循环质量管理&lt;/h2&gt;
&lt;p&gt;P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baike.com/wiki/PDCA&#34;&gt;《PDCA》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fmea管理模式&#34;&gt;FMEA管理模式&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h1 id=&#34;通用业务术语&#34;&gt;通用业务术语&lt;/h1&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h1 id=&#34;技术趋势&#34;&gt;技术趋势&lt;/h1&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h1 id=&#34;政策-法规&#34;&gt;政策、法规&lt;/h1&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;法律&#34;&gt;法律&lt;/h2&gt;
&lt;h3 id=&#34;严格遵守刑法253法条&#34;&gt;严格遵守刑法253法条&lt;/h3&gt;
&lt;p&gt;我国刑法第253条之一规定：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。&lt;/li&gt;
&lt;li&gt;窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。&lt;/li&gt;
&lt;li&gt;单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA&#34;&gt;《非法获取公民个人信息罪》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;架构师素质&#34;&gt;架构师素质&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://hellojava.info/?p=430&#34;&gt;《架构师画像》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务理解和抽象能力&lt;/li&gt;
&lt;li&gt;NB的代码能力&lt;/li&gt;
&lt;li&gt;全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；&lt;/li&gt;
&lt;li&gt;全局：是否考虑到了对上下游的系统的影响。&lt;/li&gt;
&lt;li&gt;权衡：权衡投入产出比；优先级和节奏控制；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know&#34;&gt;《关于架构优化和设计，架构师必须知道的事情》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。&lt;/li&gt;
&lt;li&gt;基础设施、配置、测试、开发、运维综合考虑。&lt;/li&gt;
&lt;li&gt;考虑人、团队、和组织的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/19841397&#34;&gt;《如何才能真正的提高自己，成为一名出色的架构师？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129&#34;&gt;《架构师的必备素质和成长途径》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。&lt;/li&gt;
&lt;li&gt;成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.51cto.com/frankfan/1248401&#34;&gt;《架构设计师—你在哪层楼？》&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层的架构师看到的只是产品本身&lt;/li&gt;
&lt;li&gt;第二层的架构师不仅看到自己的产品，还看到了整体的方案&lt;/li&gt;
&lt;li&gt;第三层的架构师看到的是商业价值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;团队管理&#34;&gt;团队管理&lt;/h1&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;招聘&#34;&gt;招聘&lt;/h2&gt;
&lt;h1 id=&#34;资讯&#34;&gt;资讯&lt;/h1&gt;
&lt;h2 id=&#34;行业资讯&#34;&gt;行业资讯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://36kr.com/&#34;&gt;36kr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.techweb.com.cn/&#34;&gt;Techweb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;公众号列表&#34;&gt;公众号列表&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;博客&#34;&gt;博客&lt;/h2&gt;
&lt;h3 id=&#34;团队博客&#34;&gt;团队博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jm.taobao.org/&#34;&gt;阿里中间件博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com&#34;&gt;美团点评技术团队博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;个人博客&#34;&gt;个人博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/&#34;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/&#34;&gt;酷壳 - COOLSHELL-陈皓&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hellojava.info/&#34;&gt;hellojava-阿里毕玄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cmsblogs.com/&#34;&gt;Cm&#39;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.didispace.com/&#34;&gt;程序猿DD-翟永超-《Spring Cloud微服务实战》作者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;综合门户-社区&#34;&gt;综合门户、社区&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;国内：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://csdn.net&#34;&gt;CSDN&lt;/a&gt;&lt;br&gt;
老牌技术社区、不必解释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.51cto.com/&#34;&gt;51cto.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.iteye.com/&#34;&gt;ITeye&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏 Java 方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com&#34;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.tom.net/&#34;&gt;ChinaUnix&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏 Linux 方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oschina.net/&#34;&gt;开源中国社区&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.open-open.com/&#34;&gt;深度开源&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jobbole.com/&#34;&gt;伯乐在线&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.itpub.net/&#34;&gt;ITPUB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/column&#34;&gt;腾讯云— 云+社区&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yq.aliyun.com/&#34;&gt;阿里云— 云栖社区&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/&#34;&gt;IBM DeveloperWorks&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://toutiao.io/&#34;&gt;开发者头条&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.linkedkeeper.com&#34;&gt;LinkedKeeper&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;国外：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com&#34;&gt;DZone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com&#34;&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;问答-讨论类社区&#34;&gt;问答、讨论类社区&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com&#34;&gt;segmentfault&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;问答+专栏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/&#34;&gt;知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;行业数据分析&#34;&gt;行业数据分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://report.iresearch.cn/&#34;&gt;艾瑞网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.questmobile.com.cn&#34;&gt;QUEST MOBILE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://data.stats.gov.cn/&#34;&gt;国家数据&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.talkingdata.com/&#34;&gt;TalkingData&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;专项网站&#34;&gt;专项网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ltesting.net/&#34;&gt;领测国际&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.testwo.com/&#34;&gt;测试窝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://testerhome.com&#34;&gt;TesterHome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运维:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yunweipai.com/&#34;&gt;运维派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.abcdocker.com/&#34;&gt;Abcdocker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/&#34;&gt;ImportNew&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;专注于 Java 技术分享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://howtodoinjava.com/&#34;&gt;HowToDoInJava&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;英文博客&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.2cto.com/&#34;&gt;红黑联盟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/&#34;&gt;FreeBuf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thebigdata.cn/&#34;&gt;中国大数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他专题网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dockerinfo.net/&#34;&gt;DockerInfo&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;专注于 Docker 应用及咨询、教程的网站。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linuxidc.com/&#34;&gt;Linux公社&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Linux 主题社区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他类&#34;&gt;其他类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TeamStuQ/skill-map&#34;&gt;程序员技能图谱&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推荐参考书&#34;&gt;推荐参考书&lt;/h2&gt;
&lt;h3 id=&#34;在线电子书&#34;&gt;在线电子书&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/forezp/SpringCloudLearning&#34;&gt;《深入理解Spring Cloud与微服务构建》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf&#34;&gt;《阿里技术参考图册-研发篇》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf&#34;&gt;《阿里技术参考图册-算法篇》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://dpurl.cn/n/1lqcX&#34;&gt;《2018美团点评技术年货（合辑）》70M&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/cn/architect/&#34;&gt;InfoQ《架构师》月刊&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.w3cschool.cn/architectroad/&#34;&gt;《架构师之路》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;纸质书&#34;&gt;纸质书&lt;/h3&gt;
&lt;h4 id=&#34;开发方面&#34;&gt;开发方面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;《阿里巴巴Java开发手册》&lt;a href=&#34;https://union-click.jd.com/jdc?d=bVKwZQ&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;架构方面&#34;&gt;架构方面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《软件架构师的12项修炼：技术技能篇》&lt;a href=&#34;https://union-click.jd.com/jdc?d=gXvRd8&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%8412%E9%A1%B9%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E7%AF%87&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《架构之美》&lt;a href=&#34;https://union-click.jd.com/jdc?d=xJit5I&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BE%8E&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《分布式服务架构》&lt;a href=&#34;https://union-click.jd.com/jdc?d=JS5Od9&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《聊聊架构》 &lt;a href=&#34;https://union-click.jd.com/jdc?d=FHooH4&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《云原生应用架构实践》&lt;a href=&#34;https://union-click.jd.com/jdc?d=orkJSj&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《亿级流量网站架构核心技术》&lt;a href=&#34;https://union-click.jd.com/jdc?d=RnOSP5&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《淘宝技术这十年》&lt;a href=&#34;https://union-click.jd.com/jdc?d=LwrDfD&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《企业IT架构转型之道-中台战略思想与架构实战》 &lt;a href=&#34;https://union-click.jd.com/jdc?d=89pAEm&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E4%BC%81%E4%B8%9AIT%E6%9E%B6%E6%9E%84%E8%BD%AC%E5%9E%8B%E4%B9%8B%E9%81%93&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《高可用架构（第1卷）》&lt;a href=&#34;https://item.jd.com/12195481.html&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84&#34;&gt;淘宝&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;技术管理方面&#34;&gt;技术管理方面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;《CTO说》&lt;a href=&#34;https://union-click.jd.com/jdc?d=zhTZyr&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=CTO%E8%AF%B4&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《技术管理之巅》&lt;a href=&#34;https://union-click.jd.com/jdc?d=LgRBUW&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E4%B9%8B%E5%B7%85&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《网易一千零一夜：互联网产品项目管理实战》&lt;a href=&#34;https://union-click.jd.com/jdc?d=jcRz2r&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E7%BD%91%E6%98%93%E4%B8%80%E5%8D%83%E9%9B%B6%E4%B8%80%E5%A4%9C%EF%BC%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基础理论-2&#34;&gt;基础理论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;《数学之美》&lt;a href=&#34;https://union-click.jd.com/jdc?d=ghIES2&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《编程珠玑》&lt;a href=&#34;https://union-click.jd.com/jdc?d=YmhdEu&#34;&gt;京东&lt;/a&gt; &lt;a href=&#34;https://s.taobao.com/search?q=%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91&#34;&gt;淘宝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工具方面&#34;&gt;工具方面&lt;/h4&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h4 id=&#34;大数据方面&#34;&gt;大数据方面&lt;/h4&gt;
&lt;h1 id=&#34;技术资源&#34;&gt;技术资源&lt;/h1&gt;
&lt;h2 id=&#34;开源资源&#34;&gt;开源资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.apache.org/index.html&#34;&gt;Apache 软件基金会&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;手册-文档-教程&#34;&gt;手册、文档、教程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;国内：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://w3cschool.cn&#34;&gt;W3Cschool&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.runoob.com/&#34;&gt;Runoob.com&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://love2.io/&#34;&gt;Love2.io&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很多很多中文在线电子书，是一个全新的开源技术文档分享平台。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://gitbook.cn/&#34;&gt;gitbook.cn&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;付费电子书。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.apachecn.org/&#34;&gt;ApacheCN&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI、大数据方面系列中文文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;国外：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quickcode.co/&#34;&gt;Quick Code&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;免费在线技术教程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gitbook.com&#34;&gt;gitbook.com&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;有部分中文电子书。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cheatography.com/&#34;&gt;Cheatography&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Cheat Sheets 大全，单页文档网站。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/index.htm&#34;&gt;Tutorialspoint&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在线课堂&#34;&gt;在线课堂&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xuetuwuyou.com/&#34;&gt;学徒无忧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://time.geekbang.org/&#34;&gt;极客时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/lives&#34;&gt;segmentfault&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://new.stuq.org/course/explore&#34;&gt;斯达克学院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nowcoder.com&#34;&gt;牛客网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jikexueyuan.com/&#34;&gt;极客学院&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://edu.51cto.com/&#34;&gt;51CTO学院&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;会议-活动&#34;&gt;会议、活动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/qcon/&#34;&gt;QCon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://archsummit.com&#34;&gt;ArchSummit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thegitc.com/&#34;&gt;GITC全球互联网技术大会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;活动发布平台:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.huodongxing.com/&#34;&gt;活动行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用app&#34;&gt;常用APP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://time.geekbang.org&#34;&gt;极客时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.igetget.com&#34;&gt;得到&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;找工作&#34;&gt;找工作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhipin.com&#34;&gt;Boss直聘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.lagou.com&#34;&gt;拉勾网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.liepin.com&#34;&gt;猎聘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cn.100offer.com/&#34;&gt;100Offer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://s.geekbang.org/&#34;&gt;极客搜索&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;技术文章搜索引擎。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码托管&#34;&gt;代码托管&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coding.net&#34;&gt;Coding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/&#34;&gt;码云&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件服务&#34;&gt;文件服务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;七牛&lt;/li&gt;
&lt;li&gt;又拍云&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;综合云服务商&#34;&gt;综合云服务商&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;阿里云&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/redirect.php?redirect=1012&amp;amp;cps_key=c2665015d90871c0cb20fef91b7afc3c&#34;&gt;腾讯云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;百度云&lt;/li&gt;
&lt;li&gt;新浪云&lt;/li&gt;
&lt;li&gt;金山云&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://amazonaws-china.com/cn/&#34;&gt;亚马逊云(AWS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/?hl=zh-cn&#34;&gt;谷歌云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/zh-cn/&#34;&gt;微软云&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vps&#34;&gt;VPS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linode.com&#34;&gt;Linode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">后端架构师技术图谱【转】</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/D3HpyGEvB/"" data-c="
          &lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;redis-server [redis.conf配置文件路径] // 启动Redis
redis-cli // 连接Redis
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一-数据库操作&#34;&gt;一、数据库操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select dbindex          // 选择数据库，使用config get databases可以获取Redis配置的数据库个数，默认为16个(0-15)
dbsize                  // 返回当前数据库中键值的数量
flushdb                 // 删除当前数据库中所有的键值
flushall				// 删除所有数据库中所有的键值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-对键key的操作&#34;&gt;二、对键key的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;exists key              // 判断key是否存在
del key1 key2...        // 删除key1、key2...
type key                // 返回key对应值的类型
keys pattern            // 返回所有匹配的键，pattern为匹配格式
randomkey               // 随机返回一个键
rename key1 key2		// 将key1的键名改为key2，值不改变	
expire key seconds      // 为key设置过期时间(秒)
ttl key                 // 返回key的剩余过期秒数
move key dbindex        // 将key移动到dbindex数据库下
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-对值-string的操作&#34;&gt;三、对值--String的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;set key value           // 设置key对应的值为value
get key         		// 根据key获取对应的值
mset key1 value1 ...	// 一次设置多个键值
mget key1 value1 ...	// 一次获取多个键值
incr key				// key的值加上1
decr key				// key的值减去1
incrby key integer      // key的值加上integer(整数)
decrby key integer      // key的值减去integer(整数)
append key value        // key的值后追加value
substr key start end    // 返回截取到的key的值(从start开始，end结束)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-对值-list双向链表的操作&#34;&gt;四、对值--List(双向链表)的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;lpush key value         // 向key对应的链表头部添加value
rpush key value         // 向key对应的链表尾部添加value
lpop key                // 删除key对应链表的头部元素
rpop key                // 删除key对应链表的尾部元素
llen key                // 返回key对应链表的长度（不存在返回0；若key对应的不是链表，返回错误）
lrange key start end    // 返回key对应链表的start~end内的元素
ltrim key start end     // 截取key对应链表，保留指定区间内的元素
lset key index value    // 设置key对应链表下标是index的值为value
lrem key count value    // 从key对应链表中删除count个值为value的元素 (若count为0，则删除全部值为value的元素)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五-对值-set集合的操作&#34;&gt;五、对值--Set(集合)的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sadd key member ...     // 向key对应集合中添加成员member
smembers key            // 返回key对应集合的所有元素(无序)
srem key member ...     // 移除key对应集合中值为member的元素，成功则返回1
smove key1 key2 member  // 将key1对应集合中值为member的元素移除，并添加至key2对应的集合
scard key               // 返回key对应集合的元素个数
sismember key member    // 判断key对应集合中是否有member
sinter key1 key2 ...    // 返回key1,key2...对应集合的交集
sunion key1 key2 ...    // 返回key1,key2...对应集合的并集
sdiff key1 key2 ...     // 返回key1,key2...对应集合的差集
sinterstore new_key key1 key2   //将key1,key2...对应集合的交集保存至new_key对应的集合
sunionstore new_key key1 key2   //将key1,key2...对应集合的并集保存至new_key对应的集合
sdiffstore new_key key1 key2    //将key1,key2...对应集合的差集保存至new_key对应的集合
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;六-对值-sortset排序集合的操作&#34;&gt;六、对值--SortSet(排序集合)的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;zadd key score id   // 向key对应排序集合中添加成员(键为key，权为score，值为value)，如：zadd stu_age 18 1
zincrby key int id  // 给值为id的元素的权加int
zcard key           // 返回排序集合中元素个数
zscore key id       // 返回排序集合中值为id的元素的权
zrange key start end    // 返回key对应排序集合的指定区间的元素的值id（正序，根据权value进行排序）
zrevrange key start end // 返回key对应排序集合的指定区间的元素的值id（逆序，根据权value进行排序）
zrangebyscore key min max   // 返回排序集合中权score在[min,max]之间的元素的值id
zrank key id            // 返回值为id的元素在集合中的下标(正序排序)
zrevrank key id         // 返回值为id的元素在集合中的下标(逆序排序)
zcount key min max      // 返回在区间[min,max]的元素个数
zrem key id         // 根据值id删除指定元素，返回1表示成功，返回0表示元素不存在       
zremrangebyrank key min max //删除排序集合中排名在[min,max]中的元素
zremrangebyscore key min max    //删除排序集合中权在[min,max]中的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;七-对值-hash的操作&#34;&gt;七、对值--Hash的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;hset key field value
hget key field
hmset key field1 value1
hmget key field1 field2
hincrby key field
hexists key field
hdel key field
hkeys key 
hlen key
hvals key
hgetall key
&lt;/code&gt;&lt;/pre&gt;
">Redis内存数据库基本操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/ePgvAL4fj/"" data-c="
          &lt;p&gt;打开Laravel框架，其目录结构如下表。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件夹名称&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;app&lt;/td&gt;
&lt;td&gt;应用程序的业务逻辑代码存放文件夹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Console&lt;/td&gt;
&lt;td&gt;存放自定义artisan命令文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Events&lt;/td&gt;
&lt;td&gt;用于放置与事件相关的类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Exceptions&lt;/td&gt;
&lt;td&gt;包含应用程序的异常处理类，用于处理应用程序抛出的任何异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Http&lt;/td&gt;
&lt;td&gt;主要包含路由文件、控制器文件、请求文件、中间件文件等，是应用程序与Laravel框架源代码等外部库交互的主要地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Http/Controllers&lt;/td&gt;
&lt;td&gt;存放控制器文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Http/Middleware&lt;/td&gt;
&lt;td&gt;存放中间件文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Jobs&lt;/td&gt;
&lt;td&gt;主要包含消息队列的各种消息类文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Listeners&lt;/td&gt;
&lt;td&gt;主要包含监听事件类文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;app/Providers&lt;/td&gt;
&lt;td&gt;主要包含服务提供者的相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bootstrap&lt;/td&gt;
&lt;td&gt;框架启动与自动加载设置相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;应用程序的配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;数据库操作相关文件（数据库迁移和数据库填充）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node_modules&lt;/td&gt;
&lt;td&gt;存放NPM依赖模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;前端控制器和资源相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources&lt;/td&gt;
&lt;td&gt;应用资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources/assets&lt;/td&gt;
&lt;td&gt;未编译前的应用资源文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources/lang&lt;/td&gt;
&lt;td&gt;多语言文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources/views&lt;/td&gt;
&lt;td&gt;视图文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;routes&lt;/td&gt;
&lt;td&gt;路由目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;routes/api.php&lt;/td&gt;
&lt;td&gt;用于定义API类型的路由&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;routes/channels.php&lt;/td&gt;
&lt;td&gt;时间转播注册信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;routes/console.php&lt;/td&gt;
&lt;td&gt;用于定义Artisan命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;routes/web.php&lt;/td&gt;
&lt;td&gt;用于定义Web类型的路由&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;storage&lt;/td&gt;
&lt;td&gt;编译后的视图、基于会话、文件缓存和其他框架生成的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;storage/app&lt;/td&gt;
&lt;td&gt;目录可用于存储应用程序使用的任何文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;storage/framework&lt;/td&gt;
&lt;td&gt;目录被用于保存框架生成的文件及缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;storage/logs&lt;/td&gt;
&lt;td&gt;应用程序的日志文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tests&lt;/td&gt;
&lt;td&gt;应用测试相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vendor&lt;/td&gt;
&lt;td&gt;Composer依赖模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;composer.json&lt;/td&gt;
&lt;td&gt;应用依赖的扩展包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;composer.lock&lt;/td&gt;
&lt;td&gt;扩展包列表，确保这个应用的副本使用相同版本的扩展包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package.json&lt;/td&gt;
&lt;td&gt;应用所需的NPM包配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;phpunit.xml&lt;/td&gt;
&lt;td&gt;测试工具PHPUnit的配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server.php&lt;/td&gt;
&lt;td&gt;使用PHP内置服务器时的URL重写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;webpack.mix.js&lt;/td&gt;
&lt;td&gt;Laravel的前端工作流配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.env&lt;/td&gt;
&lt;td&gt;环境变量配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.gitignore&lt;/td&gt;
&lt;td&gt;配置被Git所忽略的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">初探Laravel---round 6 补充：Laravel目录结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/stEcf84gD/"" data-c="
          &lt;p&gt;最近想实现发送邮件找回密码的功能，一开始想的是用PHPMailer类进行发送，后来发现Laravel是已经封装了发送邮件的功能的（一时没想到ㄟ( ▔, ▔ )ㄏ）。简单记录一下SMTP发送邮件的实现。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-项目配置&#34;&gt;一、项目配置&lt;/h2&gt;
&lt;p&gt;① .env文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MAIL_DRIVER=smtp        // 除SMTP驱动外，还有Mailgun驱动、Mandrill驱动、SES驱动
MAIL_HOST=smtp.qq.com   // smtp服务器
MAIL_PORT=465           // 加ssl安全加密的对应465端口，未使用ssl则对应25端口
MAIL_FROM_ADDRESS=123456@qq.com 
MAIL_FROM_NAME=
MAIL_USERNAME=123456@qq.com // 用户名
MAIL_PASSWORD=your_password // 密码，QQ使用授权码
MAIL_ENCRYPTION=ssl         // ssl加密层，不加密为tls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② /config/mail.php（当.env未配置某个值时，读取该文件中的默认值）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// env方法用于取.env环境配置的值，第一个参数为键，第二个参数为缺省时默认值

&#39;driver&#39; =&amp;gt; env(&#39;MAIL_DRIVER&#39;, &#39;smtp&#39;), // MAIL驱动
&#39;host&#39; =&amp;gt; env(&#39;MAIL_HOST&#39;, &#39;smtp.mailgun.org&#39;),  
&#39;port&#39; =&amp;gt; env(&#39;MAIL_PORT&#39;, 587),        // Mail端口
&#39;encryption&#39; =&amp;gt; env(&#39;MAIL_ENCRYPTION&#39;, &#39;tls&#39;), // 加密方式
&#39;username&#39; =&amp;gt; env(&#39;MAIL_USERNAME&#39;),  // 用户名
&#39;password&#39; =&amp;gt; env(&#39;MAIL_PASSWORD&#39;),  // 密码，QQ使用授权码
&#39;sendmail&#39; =&amp;gt; &#39;/usr/sbin/sendmail -bs&#39;, // sendmail命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-发送邮件&#34;&gt;二、发送邮件&lt;/h2&gt;
&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;
&lt;p&gt;在需要使用发送邮件功能的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;use Mail;

class TestController extends Controller
{
    public function send_mail()
    {
        $view = &#39;emails.hello_world&#39;;
        $data = [&#39;username&#39; =&amp;gt; &#39;Alan&#39;, &#39;msg&#39; =&amp;gt; &#39;Good morning&#39;];
        $mail_to = &#39;654321@qq.com&#39;;
        $subject = &#39;这是邮件主题emmm&#39;;
        
        Mail::send($view, $data, function ($msg) use ($mail_to, $suject) {
            $msg-&amp;gt;to($mail_to)-&amp;gt;subject($subject);
        });
        
        return Mail::failures();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$view为模板文件的位置（/resources/views/emails/hello_world.blade.php）；&lt;/p&gt;
&lt;p&gt;$data为需要传入到模板文件的数据；&lt;/p&gt;
&lt;p&gt;$mail_to为目标邮箱地址；&lt;/p&gt;
&lt;p&gt;$subject为邮件主题。&lt;/p&gt;
&lt;p&gt;返回值为Mail的错误集，非空则表示发生错误&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最好将上述变量作为方法的参数传入&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模板文件&#34;&gt;模板文件&lt;/h3&gt;
&lt;p&gt;存放在/resources/views/下，使用 &lt;code&gt;directory_name.view_name&lt;/code&gt; 即可定位到目标模板文件 &lt;code&gt;/resources/views/directory_name/view_name.blade.php&lt;/code&gt; 。在模板文件中，使用 &lt;code&gt;{{$var_name}}&lt;/code&gt; 获取传入的数据（即上面代码中的变量&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;为&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;data，var_name为&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;data数组中的键）。例如，使用上述传入的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;尊敬的{{$username}}：&amp;lt;/h1&amp;gt;
        &amp;lt;div&amp;gt;{{$msg}}&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加附件&#34;&gt;添加附件&lt;/h3&gt;
&lt;p&gt;需要添加附件，使用  &lt;code&gt;attach()&lt;/code&gt; 方法，该方法第一个参数为附件的绝对路径，第二个参数通过数组来指定文件显示名和MIME类型，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Mail::send($view, $data, function ($msg) {
    // ......
    $msg-&amp;gt;attach($path, [&#39;as&#39; =&amp;gt; $file_name, &#39;mime&#39; =&amp;gt; $mime_type]);
    // ......
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;消息队列&#34;&gt;消息队列&lt;/h3&gt;
&lt;h4 id=&#34;普通队列&#34;&gt;普通队列&lt;/h4&gt;
&lt;p&gt;考虑到发送邮件会大大增加应用的响应时间，我们可以使用Laravel内置的队列API来实现，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Mail::queue($view, $data, function ($msg) {
    // 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要在使用时配置队列。&lt;/p&gt;
&lt;h4 id=&#34;延迟队列&#34;&gt;延迟队列&lt;/h4&gt;
&lt;p&gt;延迟发送邮件，可使用 &lt;code&gt;later&lt;/code&gt; 方法，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Mail::later(10, $view, $data, function ($msg) {
    // 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;推入指定队列&#34;&gt;推入指定队列&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Mail::queueOn(&#39;queue_name&#39;, $view, $data, function ($msg) {
    //
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Mail::laterOn(&#39;queue_name&#39;, 10, $view, $data, function ($msg) {
    //
});
&lt;/code&gt;&lt;/pre&gt;
">初探Laravel---round 5 邮件发送</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/UmuJ3G5Wv/"" data-c="
          &lt;p&gt;刚接触到这个东西时有点懵逼，这什么呀？干嘛的？网上找了一些博客和文档，对这个东东有了初步的认识，所以写个 Blog 记录一下，同时加深自己的理解。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在Laravel的官方文档中，其用了&lt;code&gt;User-Role&lt;/code&gt;关系作为例子，用户可能是多个角色，一个角色也有多个用户。作为一个合格的学僧，我就用&lt;code&gt;Student-Course&lt;/code&gt;举个例子吧。&lt;/p&gt;
&lt;h2 id=&#34;一-建立表&#34;&gt;一、建立表&lt;/h2&gt;
&lt;h3 id=&#34;students表&#34;&gt;students表&lt;/h3&gt;
&lt;p&gt;单个表的简历过程不是本节重点，不赘述。表的结构和数据为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Alan&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Jane&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Jamie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;William&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;courses表&#34;&gt;courses表&lt;/h3&gt;
&lt;p&gt;course表的结构与数据为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Math&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;English&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Chinese&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;关联表&#34;&gt;关联表&lt;/h3&gt;
&lt;p&gt;使用命令&lt;code&gt;php artisan make:migration course_student_table --create=course_student&lt;/code&gt;建立迁移文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;关联表的命名规范：&lt;span style=&#34;color:red;&#34;&gt;① 表名需包含相关表表名；② 根据单词首字母排序；③ 单词一律小写；④ 单词之间用下划线连接&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;course_student表就是我们的关联表，称为 &lt;code&gt;pivot&lt;/code&gt; 表（翻译：pivot, 枢轴; 中心点，中枢; [物] 支点，支枢;）。该表中需包含两个外键，分别是student_id、course_id，每个外键对应一个表。我们可以在这个表中添加更多字段，如：若添加 &lt;code&gt;score&lt;/code&gt; 字段，需要使用到 &lt;code&gt;withPivot(&#39;col1&#39;, &#39;col2&#39;)&lt;/code&gt; ，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function courses()
{
    return $this-&amp;gt;belongsToMany(&#39;App\Course&#39;)
            -&amp;gt;withPivot(&#39;score&#39;)
            -&amp;gt;withTimestamps();
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关联表的结构为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;student_id&lt;/th&gt;
&lt;th&gt;course_id&lt;/th&gt;
&lt;th&gt;score&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;二-建立多对多模型&#34;&gt;二、建立多对多模型&lt;/h2&gt;
&lt;p&gt;接下来建立多对多关系，可以选择在任意一个主表中进行定义，取决于你的具体需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如，获取一个学生的所有课程，则在 &lt;code&gt;/app/Student.php&lt;/code&gt; 中创建多对多关系模型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Student extends Model
{
    public function courses()
    {
        return $this-&amp;gt;belongsToMany(&#39;App\Course&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再如：获取一门课程的全部选课学生，则在 &lt;code&gt;/app/Course.php&lt;/code&gt; 中创建多对多关系模型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Course extends Model
{
    public function students()
    {
        return $this-&amp;gt;belongsToMany(&#39;App\Student&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;① 若关联表名未按照 Laravel 的默认方式进行命名，则需在belongsToMany()中传入第二个参数。&lt;/span&gt;如：关联表名若为student_and_course，相关代码则应为 &lt;code&gt;return $this-&amp;gt;belongsToMany(&#39;App\Student&#39;, &#39;student_and_course&#39;);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;② 若关联表中外键键名未采用默认规范进行命名，则需使用belongsToMany()的第三、四个参数。&lt;/span&gt;如：若关联表中的外键名为s_id、c_id，相关代码则应为 &lt;code&gt;return $this-&amp;gt;belongsToMany(&#39;App\Student&#39;, &#39;student_and_course&#39;, &#39;s_id&#39;, &#39;c_id&#39;);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;③ 若关联方法名不是curses或students，则需要将对应的方法名作为第五个参数传入到belongToMany。&lt;/span&gt;如：若方法名为 &lt;code&gt;courses_test()&lt;/code&gt; ，则对应代码为 &lt;code&gt;return $this-&amp;gt;belongsToMany(&#39;App\Student&#39;, &#39;student_and_course&#39;, &#39;s_id&#39;, &#39;c_id&#39;, &#39;courses_test&#39;);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三-多对多数据模型操作&#34;&gt;三、多对多数据模型操作&lt;/h2&gt;
&lt;h3 id=&#34;1-添加记录-attach&#34;&gt;1. 添加记录---attach()&lt;/h3&gt;
&lt;p&gt;① id为1的学生添加一门id为5的课程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$courses-&amp;gt;attach($id = 5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② id为2的学生添加id分别1, 2, 3, 4的多门课程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 2)-&amp;gt;courses();
$courses-&amp;gt;attach([$id1 = 1, $id2 = 2, $id3 = 3, $id4 = 4]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 向id为1的学生添加id为5的课程成绩80（即，添加额外的属性列数据）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$courses-&amp;gt;attach($id = 1, [&#39;score&#39; =&amp;gt; 80]); // 需要添加更多属性数据，往第二个参数数组中添加键值即可
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④ 向id分别为1, 5, 12的学生添加id为2的课程成绩都为85：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$courses-&amp;gt;attach([$id1 = 1, $id2 = 5, $id3 = 12], [&#39;score&#39; =&amp;gt; 85]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-删除记录-detach&#34;&gt;2. 删除记录---detach()&lt;/h3&gt;
&lt;p&gt;① 删除id为1的学生的所有课程记录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$courses-&amp;gt;detach();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 删除id为1的学生课程为1, 2, 3, 4的课程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$courses-&amp;gt;detach([1, 2, 3, 4]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-查询记录&#34;&gt;3. 查询记录&lt;/h3&gt;
&lt;p&gt;① 输出id为1的学生的所有课程名（在Student中查询courses表的name字段）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses;     // 没有括号
foreach ($courses =&amp;gt; $course) {
    echo $course-&amp;gt;name, &#39; &#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 输出id为1的学生的所有课程成绩（在Student中查询中间表course_student的score字段）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses;
foreach ($courses =&amp;gt; $course) {
    echo $course-&amp;gt;pivot-&amp;gt;course, &#39; &#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 输出id为1的学生的id为2的课程成绩（在Student中对中间表course_student进行条件查询）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses()-&amp;gt;newPivotStatement(); // 返回Builder对象
$res = $courses
    -&amp;gt;where(&#39;student_id&#39;, 1)
    -&amp;gt;where(&#39;course_id&#39;, 2)
    -&amp;gt;first();
echo $res-&amp;gt;score;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-同步-sync&#34;&gt;4. 同步---sync()&lt;/h3&gt;
&lt;p&gt;删除id为1的学生的除1, 2, 3号外的所有课程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$courses = Student::find($id = 1)-&amp;gt;courses();
$course-&amp;gt;sync([1, 2, 3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;以上方法参数中的变量（如：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;、&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;id、&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;id1等）只起提示作用，可去除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺便附上官方文档的传送门：&lt;a href=&#34;https://docs.golaravel.com/docs/5.6/eloquent-relationships/#many-to-many&#34;&gt;英文&lt;/a&gt;、&lt;a href=&#34;http://laravelacademy.org/post/8867.html#toc_5&#34;&gt;中文&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">初探Laravel---round 4 多对多关系模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/iqMJO91iR/"" data-c="
          &lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;[文章转载自CSDN---多多说happy的博客，有所修改，&lt;a href=&#34;https://blog.csdn.net/da_guo_li/article/details/78680767&#34;&gt;传送门&lt;/a&gt;]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-数据库命名&#34;&gt;一、数据库命名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;建议使用复数名词作为表名，如： &lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据库及表名均使用小写英文字母，单词之间采用下划线连接，并以首字母排序，如： &lt;code&gt;course_student&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多对多关系的中间表用单数作为表名，如： &lt;code&gt;course_student&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要使用关键字作为数据库或表的名字（ &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;select&lt;/code&gt; 等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-文件命名&#34;&gt;二、文件命名&lt;/h2&gt;
&lt;h3 id=&#34;migration&#34;&gt;Migration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;迁移文件的文件名采用 &lt;code&gt;动词 + _TableName + _table&lt;/code&gt; 的形式，如： &lt;code&gt;php artisan make:migration create_users_table&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上述迁移文件文件名的 &lt;code&gt;TableName&lt;/code&gt; 与迁移文件中的表名保持一致，如：创建迁移文件时使用参数指定表名 &lt;code&gt;php artisan make:migration create_users_table --create=users&lt;/code&gt;，或者在文件中指明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Schema::create(&#39;users&#39;, function (Blueprint $table) {

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;model&#34;&gt;Model&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一律使用单数形式，如： &lt;code&gt;User&lt;/code&gt; 、 &lt;code&gt;Question&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;seeder&#34;&gt;Seeder&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ModelName + TableSeeder&lt;/code&gt; ，如： &lt;code&gt;UserTableSeeder&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;resource下的文件&#34;&gt;resource下的文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有目录命名一律小写，单字间以下划线&amp;quot;_&amp;quot;分割&lt;/li&gt;
&lt;/ul&gt;
">初探Laravel---round 3 Laravel中的命名规范【转】</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/Q9_WvWa7e/"" data-c="
          &lt;p&gt;我们使用的语言都是为了人类更好的理解而设计的，机器并不能识别这些语言，其只能执行二进制代码。因此，编写完的程序需要一个“翻译官”将其翻译成二进制序列，这个过程称为编译。而根据编译时机的不同，编程语言可分为编译型语言和解释型语言。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-编译型语言&#34;&gt;一、编译型语言&lt;/h2&gt;
&lt;p&gt;编译型语言在程序运行前提前边编译为计算机可执行的二进制文件，在执行时直接执行机器指令，典型代表有C、C++、Golang。编译型语言最大的优势就是&lt;span style=&#34;color:green;&#34;&gt;&lt;strong&gt;效率高&lt;/strong&gt;&lt;/span&gt;，因为耗时的编译过程在执行之前就已经完成。编译型语言在&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;不同平台需要进行重新编译&lt;/strong&gt;&lt;/span&gt;，因为编译时生成的机器指令是针对特定机器的。&lt;/p&gt;
&lt;p&gt;将C语言程序编译成可执行的二进制程序需要经过&lt;strong&gt;预处理&lt;/strong&gt;（将以#开头的命令进行替换）、&lt;strong&gt;编译&lt;/strong&gt;（C语言转换为汇编语言）、&lt;strong&gt;汇编&lt;/strong&gt;（将汇编代码生成机器指令，并生成扩展名为.o的ELF可重定位目标文件）、**链接（**将重定向目标文件中引用其他文件的符号进行替换，同时根据上一个步骤生成的符号表，把函数、全局变量的引用位置替换为实际的存储位置）四个阶段。&lt;/p&gt;
&lt;h2 id=&#34;二-解释型语言&#34;&gt;二、解释型语言&lt;/h2&gt;
&lt;p&gt;在执行前不需要编译为机器语言，而是由解释器进行解释执行，解释器是机器可识别的二进制程序。解释型语言实际上就是在语言和计算机之间加了一层解释器，也称为虚拟机，然后通过解释型语言控制解释器执行相应的机器指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;解释器并不是将解释型语言编译成机器语言去执行，而是解释器中预先定义好了一些具体的操作，这些操作已被编译为机器指令，在执行时，解释型语言控制解释器执行某一个机器指令。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为解释器的存在，屏蔽了不同平台之间机器语言的差异，解释型语言可以方便的运行在不同平台上，&lt;span style=&#34;color:green;&#34;&gt;&lt;strong&gt;实现跨平台&lt;/strong&gt;&lt;/span&gt;。而不同平台之间的差异由解释器来处理，这就相当于解释器将底层的实现封装成固定规则的API，用户可以直接使用其定义的规则来进行操作。（适配器模式）&lt;/p&gt;
&lt;p&gt;而这种实现方式带来的弊端就是，&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;运行效率低&lt;/strong&gt;&lt;/span&gt;，相比于编译型语言，多出解释器解析的一步。&lt;/p&gt;
&lt;h2 id=&#34;三-总结&#34;&gt;三、总结&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;① 编译型语言：C、C++、Go等，在执行前编译为机器语言，机器可直接执行。优点：执行效率高；缺点：移植到不同平台需要重新编译。&lt;/p&gt;
&lt;p&gt;② 解释型语言：Python、PHP等，在执行时进行解析，依赖执行环境（解释器）。优点：跨平台，在安装了执行环境的不同平台下，可完美移植；缺点：执行效率低。&lt;/p&gt;
&lt;p&gt;③ 另：Java属于半编译半解释语言，其在程序编写完成后，由编译器将Java代码编译为字节码而不是机器码，在执行时由Java虚拟机解释执行字节码。&lt;/p&gt;
&lt;/blockquote&gt;
">PHP内核源码阅读记---round 5 编译型语言与解释型语言</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/r0iuteJKw/"" data-c="
          &lt;p&gt;在C/C++语言中，想要在堆上分配变量，需要手动进行内存分配与释放，这往往是一件很繁琐的事情，现代高级语言普遍提供了变量自动GC的机制。PHP同样也实现了这个机制，PHP使用&#39;$&#39;符声明变量后，不需要手动销毁，内核会自动进行释放。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-引用计数和写时复制&#34;&gt;一、引用计数和写时复制&lt;/h2&gt;
&lt;p&gt;如何实现自动GC呢，简单的实现方式：在函数定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放。如果在函数执行期间，该变量作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不冲突。&lt;/p&gt;
&lt;p&gt;这种方法是可行的，但是这种深拷贝的方法带来了几个问题：效率低、内存浪费严重。有时候我们对变量仅仅做读操作。所以，在PHP中为了解决这个问题采用了&lt;strong&gt;引用计数+写时复制&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指在变量赋值、传递时不是进行直接复制，而是多个变量指向同一个value容器，同时使用引用计数记录该value有多少个变量在使用；而当某一个变量需要进行修改时，它们不能继续使用同一个value，所以复制一份value进行修改，这就是写时复制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;引用计数&#34;&gt;引用计数&lt;/h3&gt;
&lt;p&gt;在PHP7中，变量的引用计数保存在zend_value中，与旧版本不同（旧版本保存在zval中）。不同的数据类型结构中都有一个相同的成员；&lt;em&gt;zend_refcounted_h gc;&lt;/em&gt;。它就是用来保存引用计数的。其结构为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _zend_refcounted_h {
    // 引用计数
    uint32_t refcount;
    union {
        struct {
            ZEND_ENDIAN_LOHI_3(
                // 类型
                zend_uchar type,
                zend_uchar flags,
                // 垃圾回收时用到
                uint16_t gc_info
            )
        } v;
        uint32_t type_info;
    } u;
} zend_refcounted_h;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$a = array();   // $a       -&amp;gt;  zend_array(refcount=1)
$b = $a;        // $a,$b    =&amp;gt;  zend_array(refcount=2)
$c = $b;        // $a,$b,$c =&amp;gt;  zend_array(refcount=3)
unset($b);      // $a,$c    =&amp;gt;  zend_array(refcount=2) $b = IS_UNDEF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;注意：并不是所有的数据类型都会用到引用计数，没有具体value结构的类型不会用到，例如：&lt;strong&gt;整型、浮点型、布尔型、NULL&lt;/strong&gt;，它们的值直接通过zval保存，因此不会共用value，而是深拷贝。除此之外，还有两种特殊情况不会用到引用计数，分别是&lt;strong&gt;内部字符串、不可变数组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内部字符串：在PHP中写的函数名、类名、变量名、静态字符串都是这种类型。&lt;br&gt;
不可变数组：是opCache优化出的一种类型，不作说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 这种情况refcount都为0
$a = &#39;hi&#39;;
$b = $a;

// 这种情况refcount为2
$a = &#39;hi&#39; . time();
$b = $a;

因为前者为静态字符串，后者为动态
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;写时复制&#34;&gt;写时复制&lt;/h3&gt;
&lt;p&gt;变量使用了引用计数必然会出现其中一个变量修改value的情况，这个时候需要对value进行分离，发生修改的变量会复制一份数据出来进行修改，同时断开原来value的指向，指向新的value。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$a = array(1,2);
$b = $a;

//发生分离
$b[] = 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;并不是所有类型的value都进行复制，对象、资源是无法复制的，所以对对象、资源进行修改时，将会反映到所有变量上。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;回收时机&#34;&gt;回收时机&lt;/h3&gt;
&lt;p&gt;在zval断开value的指向时，若发现refcount=0则会直接释放value。（断开指向发生在修改变量与函数返回时）。&lt;/p&gt;
&lt;h3 id=&#34;循环引用&#34;&gt;循环引用&lt;/h3&gt;
&lt;p&gt;这个机制依然存在问题：当发生循环引用时，变量无法回收，将导致内存得不到释放，造成内存泄露。循环应用是指变量内部的成员引用了变量自身，当外部所有引用都断开时，该变量的refcount依旧大于0，而实际上变量已经未被使用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若一个变量value的refcount减少到0后，直接释放，若减少之后大于0，value因为可能是一个垃圾而被垃圾回收器收集起来。&lt;br&gt;
当垃圾收集器中的可能垃圾达到一定数量后，就会启动垃圾鉴定：对value的所有成员减一遍引用计数，若value本身的refcount变为0，则表明该value为垃圾，并进行回收。&lt;/p&gt;
&lt;/blockquote&gt;
">PHP内核源码阅读记---round 4 变量的自动GC（垃圾回收）机制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/HCFM8fl9i/"" data-c="
          &lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;[文章转载自简书---饥渴计科极客杰铿，有所修改，&lt;a href=&#34;https://www.jianshu.com/p/a94391a78ace&#34;&gt;传送门&lt;/a&gt;]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-创建migration&#34;&gt;1、创建Migration&lt;/h2&gt;
&lt;p&gt;创建新表的迁移文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:migration create_users_table --create=users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建修改表的迁移文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:migration add_votes_to_users_table --table=users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令执行完成会在/database/migrations中创建一些迁移文件，在这些文件中可以对表进行设计和修改。&lt;/p&gt;
&lt;h2 id=&#34;2-创建表的列&#34;&gt;2、创建表的列&lt;/h2&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Schema::create(&#39;users&#39;, function (Blueprint $table) {
    $table-&amp;gt;increments(&#39;id&#39;);
    $table-&amp;gt;string(&#39;name&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下为&lt;strong&gt;部分&lt;/strong&gt;Migration方法及其对应的数据库数据类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mediumInteger($column, $autoIncrement = false, $unsigned = false)&lt;/td&gt;
&lt;td&gt;MEDIUMINT类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;integer($column, $autoIncrement = false, $unsigned = false)&lt;/td&gt;
&lt;td&gt;INT类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bigInteger($column, $autoIncrement = false, $unsigned = false)&lt;/td&gt;
&lt;td&gt;BIGINT类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;increments($column)&lt;/td&gt;
&lt;td&gt;自增ID，INT类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bigIncrements($column)&lt;/td&gt;
&lt;td&gt;自增ID，BIGINT类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;binary($column)&lt;/td&gt;
&lt;td&gt;BLOB类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean($column)&lt;/td&gt;
&lt;td&gt;BOOLEAN类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char($column, $length = null)&lt;/td&gt;
&lt;td&gt;CHAR类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;date($column)&lt;/td&gt;
&lt;td&gt;DATE类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dateTime($column, $precision = 0)&lt;/td&gt;
&lt;td&gt;DATETIME类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decimal($column, $total = 8, $places = 2)&lt;/td&gt;
&lt;td&gt;DECIMAL类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double($column, $total = null, $places = null)&lt;/td&gt;
&lt;td&gt;DOUBLE类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enum($column, array $allowed)&lt;/td&gt;
&lt;td&gt;ENUM类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;json($column)&lt;/td&gt;
&lt;td&gt;JSON类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string($column, $length = null)&lt;/td&gt;
&lt;td&gt;VARCHAR类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;字段默认为NOT NULL，若需要可为NULL请使用nullable()方法，如：$table-&amp;gt;string(&#39;name&#39;, 20)-&amp;gt;nullable();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上为部分方法，更多内容请查看这些方法的定义文件---Blueprint.php&lt;/p&gt;
&lt;h2 id=&#34;3-修改表的列&#34;&gt;3、修改表的列&lt;/h2&gt;
&lt;p&gt;将部分方法放在代码中演示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Schema::table(&#39;users&#39;, function (Blueprint $table) {
    $table-&amp;gt;string(&#39;name&#39;, 30)-&amp;gt;change();               // 将长度修改为30
    $table-&amp;gt;string(&#39;name&#39;, 30)-&amp;gt;nullable()-&amp;gt;change();   // 将name列修改为允许NULL
    $table-&amp;gt;remameColumn(&#39;name&#39;, &#39;user_name&#39;);          // name列名修改为user_name，暂不支持enum类型列的重命名
    $table-&amp;gt;dropColumn(&#39;name&#39;);                         // 删除列
    $table-&amp;gt;dropColumn(&#39;name&#39;, &#39;name2&#39;, &#39;name3&#39;);       // 删除多个列
});
&lt;/code&gt;&lt;/pre&gt;
">初探Laravel---round 2 Migration的使用【转】</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/OVKS0cQeJ/"" data-c="
          &lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;[文章转载自CSDN---jiandanokok的专栏，&lt;a href=&#34;https://blog.csdn.net/jiandanokok/article/details/72897682&#34;&gt;传送门&lt;/a&gt;]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;artisan是Laravel中的命令行工具，本节记录一些常用的artisan命令，以便后面的Laravel学习。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;全局篇&#34;&gt;全局篇&lt;/h2&gt;
&lt;p&gt;1、查看artisan命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan 
php artisan list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、查看某个帮助命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan help make:model
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、查看Laravel版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、使用 PHP 内置的开发服务器启动应用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan serve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、生成一个随机的 key，并自动更新到 app/config/app.php 的 key 键值对（刚安装好需要做这一步）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan key:generate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、开启Auth用户功能（开启后需要迁移才生效）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:auth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、开启维护模式和关闭维护模式（显示503）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan down
php artisan up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、进入tinker工具&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan tinker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9、列出所有路由器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan route:list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10、生成路由缓存及移除路由缓存文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan route:cache
php artisan route:clear
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;功能篇&#34;&gt;功能篇&lt;/h2&gt;
&lt;p&gt;1、创建控制器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:controller StudentController
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建Rest风格资源控制器（带index、create、store、edit、update、destroy、show方法）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:controller StudentController --resource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、创建模型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:model Student
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、创建新建表的迁移和修改表的迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:migration create_users_table --create=users
php artisan make:migration add_votes_to_users_table --table=students
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;可以试试有无create、table参数的效果区别&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;5、执行迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、创建模型的时候同时生成新建表的迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:model Student -m
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、回滚上一次迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan migrate:rollback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、回滚所有迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan migrate:reset
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9、创建填充&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:seeder StudentTableSeeder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10、执行单个填充&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan db:seed --class=StudentTableSeeder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;11、执行所有填充&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan db:seed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;12、创建中间件（app/Http/Middleware 下）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;php artisan make:middleware Activity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;13、创建队列（数据表）的表迁移（需要执行迁移才生效）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan queue:table
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;14、创建队列类（app/jobs 下）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:job SendEmail
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;15、创建请求类（app/Http/Requests 下）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;php artisan make:request CreateArticleRequest
&lt;/code&gt;&lt;/pre&gt;
">初探Laravel---round 1 常用artisan命令【转】</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/LkGlgwuxb/"" data-c="
          &lt;p&gt;前面了解到了PHP变量的实现方式和变量类型，接下来介绍一下字符串、数组及引用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-字符串&#34;&gt;一、字符串&lt;/h2&gt;
&lt;p&gt;PHP中并不是使用C语言的char来表示字符串，而是定义了一个结构体zend_string，前面提到变量的值是保存在zval结构体里的zend_value中的。在表示字符串时，zend_value的通过zend_string指针指向具体的zend_string结构体。zend_string结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _zend_string zend_string;
struct _zend_string {
    zend_refcounted_h gc;
    zend_ulong h;
    size_t len;
    char val[1];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;gc: 变量的引用计数信息，用于内存管理;&lt;/li&gt;
&lt;li&gt;h: 字符串通过Times 33算法计算得到的Hash Code;&lt;/li&gt;
&lt;li&gt;len: 字符串长度；&lt;/li&gt;
&lt;li&gt;val: 字符串内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;val[1]并不是表示它只能存储一个字节（长度为1是保存结束符&amp;quot;\0&amp;quot;），因为val是变长数组，在字符串分配时实际是类似这样的操作： malloc(sizeof(zend_string) + 字符串长度)，&lt;br&gt;
也就是会多分配一些内存，而多出的这块内存的起始位置就是val，这样就可以直接将字符串内容存储到val中，通过val进行读取。若val使用char*指针，则需要额外分配一次内存，而变长结构体不仅可以省一次内存分配，而且有助于内存管理。另外，val多出来的一个字节用于存储字符串的最后一个字符&amp;quot;\0&amp;quot;。&lt;/p&gt;
&lt;h2 id=&#34;二-数组&#34;&gt;二、数组&lt;/h2&gt;
&lt;p&gt;在PHP中，数组是一种很强大、很灵活的数据结构，它的底层实现是哈希表（HashTable）。哈希表结构为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _zend_array {
    zend_refcounted_h gc;
    // 这个union可以先忽略
    union {
        ...
    } u;
    // 用于散列函数映射存储元素在arData数组中的下标
    uint32_t nTableMask;
    // 存储数组元素，每个元素的结构统一为Bucket，指向第一个Bucket
    Bucket *arData;
    // 已用Bucket数
    uint32_t nNumUsed;
    // 数组实际存储的元素数
    uint32_t nNumOfElements;
    // 数组的总容量
    uint32_t nTableSize;
    uint32_t nInternalPointer;
    // 下一个可用的数值索引，如arr[] = 1; arr[&#39;a&#39;] = 2; arr[] = 3;，则nNextFreeElement = 2
    zend_long nNextFreeElement;
    dtor_func_t pDestructor;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;哈希表散列表hashtable的基本实现&#34;&gt;哈希表（散列表，HashTable）的基本实现&lt;/h3&gt;
&lt;p&gt;哈希表是根据关键码值直接进行访问的数据结构，它是直接通过键key映射到内存地址上去，从而加快查找速度。哈希表主要由两部分组成：存储元素数组、散列函数。散列函数的作用是根据key映射出元素的存储位置，通常用取模作为散列函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果直接用散列函数的输出值作为该元素在存储元素数组中的下标的方式存在一个问题：元素在数组中的分布是随机的、无序的。但其实在PHP中数组元素的位置是有序的，数组中各元素的顺序与其插入顺序一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PHP中是如何实现的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了实现散列表的有序性，PHP中的散列表在散列函数与元素数组之间加一层&lt;strong&gt;映射表&lt;/strong&gt;，这个映射也是一个数组，大小与存储元素的数组相同，存储了元素在实际存储数组中的下标。&lt;strong&gt;元素按照先后顺序一次插入实际存储数组，然后将其数组下标按照散列函数的位置再新加到映射表中。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;哈希冲突&#34;&gt;哈希冲突&lt;/h3&gt;
&lt;p&gt;两个不同的key值经过散列函数散列后得到的哈希值可能会相同，但一个位置只能存储一个元素，这种冲突就叫做哈希冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：如果可以把哈希值相同的元素保存起来就可以解决了，常见的解决办法就是把冲突的元素串成链表，原来的位置保存链表的头指针，查找时需要遍历这个链表，逐个比较key，从而找到目标元素。&lt;/p&gt;
&lt;h2 id=&#34;三-引用&#34;&gt;三、引用&lt;/h2&gt;
&lt;p&gt;引用类似于C语言中指针的概念。在PHP中，使用 &amp;amp; 符生成一个引用变量。在执行时，首先分配一个zend_reference结构，这个结构就是引用类型的结构体，其内嵌了一个zval，这个zval指向被引用的zval的value，然后将原zval的类型修改为IS_REFERENCE，原zval的value指向新创建的zend_reference结构。也就是说。&amp;amp; 将变量的数据类型转换为引用，而新生成的引用结构指向原来的value。zend_reference结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _zend_reference {
    zend_refcounted_h gc;
    zval val;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 定义$a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;$a = &#39;123456&#39;;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;gt; PHP内部：
&amp;gt; ![PHP引用1](https://media.alan123.xyz/imgs/blogs/phpreference/1.jpg)

&amp;gt; ② 定义$b为$a的引用

&amp;gt; ```php
$b = &amp;amp;$a;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP内部：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/phpreference/2.jpg&#34; alt=&#34;PHP引用2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">PHP内核源码阅读记---round 3.2 字符串、数组及引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/q2UXsPH2O/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;一-问题&#34;&gt;一、问题&lt;/h2&gt;
&lt;p&gt;今天写完博客发现一个很奇怪的问题：进入标签相关页时整个页面的颜色都变成了粉红色（画风清奇，一股魔法少女厄加特的味道），居然把我内心世界展示了出来，得赶紧修复。&lt;/p&gt;
&lt;h2 id=&#34;二-解题步骤直接看解决方法请移步至-三&#34;&gt;二、解题步骤（直接看解决方法请移步至---&amp;gt;三）&lt;/h2&gt;
&lt;h3 id=&#34;1-找寻问题根源&#34;&gt;1、找寻问题根源&lt;/h3&gt;
&lt;p&gt;浏览器查看元素样式，发现整个页面被一个叫tranquil-heart.min.css的css文件渲染了一遍，其渲染的class为&#39;tag&#39;，突然想到我进入的页面是标签相关页面，于是查看body的class值，发现class值也是&#39;tag&#39;，果然是class重名了。&lt;/p&gt;
&lt;h3 id=&#34;2-找寻解决办法&#34;&gt;2、找寻解决办法&lt;/h3&gt;
&lt;p&gt;既然是重名，那么只要把两者其中一个修改一下就可以解决了，因为考虑到修改插件内容会比修改WordPress内容简单，所以选择修改Gruber Markdown插件的类名。&lt;/p&gt;
&lt;h3 id=&#34;3-wordpress的markdown插件原理&#34;&gt;3、WordPress的Markdown插件原理&lt;/h3&gt;
&lt;p&gt;既然要修改Gruber Markdown插件，就得了解一下其原理：Markdown插件其实是在编写完博客之后，进行发布时，将Markdown语法转化为HTML语法并对各个标签对的class赋以相对应的值，最终将其保存在数据库中。在查看文章时，Markdown插件取用选择的主题css文件对文章进行渲染。&lt;/p&gt;
&lt;h2 id=&#34;三-解决方案&#34;&gt;三、解决方案&lt;/h2&gt;
&lt;p&gt;1、在Linux下使用find命令定位到css文件，路径大致为&lt;em&gt;wordpress/wp-content/plugins/wp-gruber-markdown/theme/tranquil-heart.min.css&lt;/em&gt;（根据主题选择自己的css文件），打开文件，搜索&#39;tag&#39;，结果类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;tag{color:#ed5565}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将&#39;tag&#39;改为不易重复的名称，保存退出。&lt;/p&gt;
&lt;p&gt;2、在&lt;em&gt;wordpress/wp-content/plugins/wp-gruber-markdown/&lt;em&gt;下找到&lt;/em&gt;prettify.js&lt;/em&gt;文件，这是将Markdown转化为HTML的js文件，打开，搜索&#39;tag&#39;，结果类似：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;...[[&amp;quot;tag&amp;quot;,...      // 前后省略，夹杂许多正则表达式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;...PR_TAG:&amp;quot;tag&amp;quot;,... // 前后省略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将这两处的&#39;tag&#39;都改成与第1步修改时相同的名称，保存退出。&lt;/p&gt;
&lt;p&gt;3、最后一步，将相关博客重新发布即可（更新博客中class值），若仍无效果，则在清除浏览器缓存后刷新页面。&lt;/p&gt;
">WordPress的Gruber Markdown插件问题排查</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/lER_pd6i7/"" data-c="
          &lt;p&gt;PHP中的变量如何实现的？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;em&gt;Mission Start!&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-php变量的实现-zval结构&#34;&gt;一、PHP变量的实现---zval结构&lt;/h2&gt;
&lt;p&gt;我们都知道在PHP中一个变量可以用来存储任意的数据类型，但实现PHP的底层C语言却是强类型语言，那么在PHP中是如何实现这样一个可以改变数据类型的变量的呢？&lt;/p&gt;
&lt;p&gt;在PHP内核中是通过一个叫zval的结构体来存储变量的，其定义在Zend/zend.h头文件中，其代码结构为：&lt;/p&gt;
&lt;h3 id=&#34;php5&#34;&gt;PHP5&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _zval_struct {
	zvalue_value value;	   /* 变量的值 */
	zend_uint refcount__gc; /* 引用计数 */
	zend_uchar type;	      /* 变量的数据类型 */
	zend_uchar is_ref__gc;  /* 是否引用 */
};
typedef struct _zval_struct zval;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先看代码中的zend_uint和zend_uchar类型，它们定义在Zend/zend_types.h中，分别是unsigned int、unsigned char：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef unsigned int zend_uint;     // zend_uint =&amp;gt; unsigned int
typedef unsigned char zend_uchar;   // zend_uchar =&amp;gt; unsigned char
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而变量的值value的数据类型为zvalue_value，它是一个联合体(union，联合体详情请看第四节==&amp;gt;&lt;a href=&#34;https://blog.alan123.xyz/php/592.html&#34;&gt;传送门&lt;/a&gt;)，在Zend/zend.h中定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef union _zvalue_value {
	long lval;	   /* long value */
	double dval;	/* double value */
	struct {
		char *val;
		int len;
	} str;
	HashTable *ht;	/* hash table value */
	zend_object_value obj;
} zvalue_value;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;其中lval用于存放整型&lt;/li&gt;
&lt;li&gt;dval用于存放浮点数据&lt;/li&gt;
&lt;li&gt;str是一个结构体，用于存放字符串，包括字符串的值和字符串的长度&lt;/li&gt;
&lt;li&gt;ht存放哈希表的指针（PHP中数组就是用哈希表实现的）&lt;/li&gt;
&lt;li&gt;obj是存放对象类型的&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;php7&#34;&gt;PHP7&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _zval_struct {
    zend_value value;   // 变量值
    union {
        struct {
            ZEND_ENDIAN_LOTH_4(
                zend_uchar type,
                zend_uchar type_flags,
                zend_uchar const_flags,
                zend_uchar reserverd)
        } v;
        uint32_t type_info;
    } u1;
    union {
        uint32_t var_flags;
        uint32_t next;
        uint32_t cache_slot;
        uint32_t lineno;
        uint32_t num_args;
        uint32_t fe_pos;
        uint32_t fe_iter_idx;
    } u2;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;联合体u1：由一个结构体v和一个32位无符号整型type_info组成。ZEND_ENDIAN_LOTH_4宏用于解决字节序问题，忽略。v中定义了type用于表示value类型，type_flags是类型掩码，用于变量的内存管理。type_info实际上是将v结构的4各成员组合到一起，每个字节对应一个成员，共4个字节。&lt;br&gt;
联合体u2：纯粹用于辅助功能，zval结构的value和u1共占用了12types，而系统会进行字节对齐，共占用16types，所以定义了辅助结构u2将4types进行利用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef union _zend_value {
    zend_long lval;             // 整型
    double dval;                // 浮点型
    zend_refcounted *counted;   // 获取不同类型的gc头部
    zend_string *str;           // 字符串
    zend_array *arr;            // 数组
    zend_object *obj;           // 对象
    zend_resource *res;         // 资源类型
    zend_reference *ref;        // 引用类型
    // 以下几个都是给内核使用的value
    zend_ast_ref *ast;          
    zval *zv;
    void *ptr;
    zend_class_entry *ce;
    zend_function *func;
    struct {
        uint32_t w1;
        uint32_t w2;
    } ww;
} zend_value;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-变量的类型&#34;&gt;二、变量的类型&lt;/h2&gt;
&lt;p&gt;PHP中有8大数据类型，分别为PHP中有8大数据类型，分别为&lt;strong&gt;null、布尔、整型、浮点型、字符串、数组、对象、资源(resource)&lt;/strong&gt;。在PHP内核中是使用特定的常量对zval实例进行标识，以实现区分变量的不同类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;常量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_NULL&lt;/td&gt;
&lt;td&gt;第一次使用的变量若未被初始化，则自动被赋予IS_NULL。这个类型的值只有一个，就是NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_BOOL&lt;/td&gt;
&lt;td&gt;布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。&lt;strong&gt;（在PHP7中BOOL类型直接使用type类型IS_TRUE、IS_FALSE来区分true、false，而在PHP旧版本中BOOL类型也是通过整型来进行区分的）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_LONG&lt;/td&gt;
&lt;td&gt;PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出，而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。再者，因为使用了signed long来作为载体，所以也就解释了为什么PHP语言中的整型数据都是带符号的了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_DOUBLE&lt;/td&gt;
&lt;td&gt;PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10&lt;sup&gt;(-308)~~1.798x10&lt;/sup&gt;308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011....。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333.....，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_STRING&lt;/td&gt;
&lt;td&gt;PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_ARRAY&lt;/td&gt;
&lt;td&gt;数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_OBJECT&lt;/td&gt;
&lt;td&gt;和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_RESOURCE&lt;/td&gt;
&lt;td&gt;有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PHP内核提供三个宏来获取一个变量的数据类型：Z_TYPE()、Z_TYPE_P()、Z_TYPE_PP()，它们的参数分别为：zval、*zval、**zval。这三个宏定义在Zend/zend_operators.h中。&lt;/p&gt;
&lt;h2 id=&#34;三-变量的值&#34;&gt;三、变量的值&lt;/h2&gt;
&lt;p&gt;PHP内核提供了三个基础宏来获取变量的值（与上述类型获取的宏参数一样）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_BOOL&lt;/td&gt;
&lt;td&gt;Z_BVAL、Z_BVAL_P、Z_BVAL_PP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_DOUBLE&lt;/td&gt;
&lt;td&gt;Z_DVAL、Z_DVAL_P、Z_DVAL_PP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_STRING&lt;/td&gt;
&lt;td&gt;1. 获取值：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP 2. 获取字符串（返回字符串地址）：Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_ARRAY&lt;/td&gt;
&lt;td&gt;Z_ARRVAL、Z_ARRVAL_P、Z_ARRVAL_PP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_OBJECT&lt;/td&gt;
&lt;td&gt;对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IS_RESOURCE&lt;/td&gt;
&lt;td&gt;资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;四-变量符号表与作用域&#34;&gt;四、变量符号表与作用域&lt;/h2&gt;
&lt;h3 id=&#34;变量符号表&#34;&gt;变量符号表&lt;/h3&gt;
&lt;p&gt;PHP的变量符号表与zval值的映射，是通过HashTable实现的。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$var = &#39;test&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;名&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;会&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;储&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;在&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;代&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;表&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;var的变量名会存储在变量符号表中，代表&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;名&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;会&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;存&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;储&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;在&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;代&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;var的类型和值的zval结构存储在哈希表中。内核通过变量符号表与zval地址的哈希映射来实现PHP变量的存取。&lt;/p&gt;
&lt;h3 id=&#34;作用域&#34;&gt;作用域&lt;/h3&gt;
&lt;p&gt;按照作用域可将PHP变量分为全局变量和局部变量，每种作用域PHP都会维护一个符号表的HashTable。当在PHP中创建一个函数或者类时，zend engine就会创建一个新的符号表，表名函数或类中的变量是局部变量，这样就实现了局部变量的保护。当用户创建一个PHP变量时，zend engine会分配一个zval，并设置相应type和初始值，并将改变量加入到当前作用域的符号表。&lt;/p&gt;
">PHP内核源码阅读记---round 3.1 PHP变量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/3TM5XxhlH/"" data-c="
          &lt;p&gt;了解下PHP各个SAPI模式及生命周期。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-php的生命周期&#34;&gt;一、PHP的生命周期&lt;/h2&gt;
&lt;p&gt;PHP的整个生命周期可以划分为五个阶段，分别为：&lt;strong&gt;模块初始化阶段、请求初始化阶段、执行脚本阶段、请求关闭阶段、模块关闭阶段&lt;/strong&gt;。在不同的SAPI下，各阶段的执行情况可能存在差异，比如：在命令行模式下，每次执行一个脚本文件都会完整的经历这五个阶段，而在fastcgi模式下，启动时经历一次模块初始化，处理每个请求时会经历请求初始化、执行脚本、请求关闭三个阶段，在关闭时会经历一次模块关闭。&lt;/p&gt;
&lt;h2 id=&#34;二-sapi&#34;&gt;二、SAPI&lt;/h2&gt;
&lt;p&gt;SAPI, Server Application Programming Interface（服务器应用程序接口），SAPI就是PHP与外部环境的代理器，针对不同的外部环境使用不同的接口。它将外部环境抽象后，为内部的PHP提供一套固定的、统一的接口，使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定独立性。&lt;/p&gt;
&lt;p&gt;简单介绍一下PHP几种经典的SAPI：CLI、FPM、Embed。&lt;/p&gt;
&lt;h3 id=&#34;1-cli&#34;&gt;1、CLI&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CLI，Command Line Interface，命令行接口&lt;/strong&gt;，可以在命令行模式下执行PHP脚本，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ php test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CLI每次执行完请求后就关闭，所以每次执行脚本都会经历了模块初始化、请求初始化、执行脚本、请求关闭、模块关闭。&lt;/p&gt;
&lt;h3 id=&#34;2-fpm&#34;&gt;2、FPM&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FPM，FastCGI Process Manager，FastCGI进程管理器&lt;/strong&gt;，是PHP FastCGI运行模式下的一个进程管理器。&lt;br&gt;
先了解一下FastCGI，它是CGI（Common Gateway Interface，公共网关接口）的升级版（&lt;a href=&#34;https://www.baidu.com/s?wd=CGI%E4%B8%8EFastCGI%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;CGI与FastCGI的区别&lt;/a&gt;），与CGI、HTTP一样属于应用层的通信协议。因为PHP本身并没有HTTP网络库，而是通过实现FastCGI协议来处理HTTP请求，其工作方式为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP协议 --&amp;gt; Web服务器 --&amp;gt; FastCGI协议 --&amp;gt; PHP&lt;br&gt;
PHP执行完毕依次返回数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FPM是一个多进程模型，由一个master进程和多个worker进程组成。master进程负责管理worker进程，worker进程才是真正的请求处理者。&lt;/p&gt;
&lt;h4 id=&#34;master进程&#34;&gt;master进程&lt;/h4&gt;
&lt;p&gt;master拥有三种不同的进程管理方式：静态模式、动态模式、按需模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;静态模式&lt;/strong&gt;：在启动时master进程fork出一定量的worker进程，固定不变。&lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;（worker进程数量由配置项pm.max_children决定）&lt;/em&gt;&lt;/span&gt;&lt;br&gt;
&lt;strong&gt;动态模式&lt;/strong&gt;：常用的模式，在启动时根据pm.start_servers数量fork出相同数量的worker进程。在运行期间，若发现空闲的worker进程数小于配置pm.min_spare_servers的数量（表示请求过多，worker进程处理不过来），master则会继续fork worker进程；相反，若发现空闲的worker进程数大于pm.max_spare_servers，master则会杀掉一些worker进程，以防止占用过多资源。&lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;（注意：在整个过程中，worker进程数不得超过pm.max_children）&lt;/em&gt;&lt;/span&gt;&lt;br&gt;
&lt;strong&gt;按需模式&lt;/strong&gt;：在启动时，不分配worker进程，当请求到来时，同时master进程fork worker进程，处理完请求后，worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。&lt;span style=&#34;color:red;&#34;&gt;&lt;em&gt;（同样的，worker进程数不超过pm.max_children）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;worker进程&#34;&gt;worker进程&lt;/h4&gt;
&lt;p&gt;worker进程周期为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等待请求 --&amp;gt; 解析请求 --&amp;gt; 请求初始化 --&amp;gt; 执行PHP脚本 --&amp;gt; 关闭请求 --&amp;gt; 等待请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-embed&#34;&gt;3、Embed&lt;/h3&gt;
&lt;p&gt;编译后是普通的库文件（静态库或共享库），可以在C/C++应用中调用PHP提供的API，甚至提供给其他语言使用。&lt;/p&gt;
&lt;h2 id=&#34;三-php的启动及终止&#34;&gt;三、PHP的启动及终止&lt;/h2&gt;
&lt;p&gt;PHP的启动、终止可以分别分为两个概念的启动、终止，一个是作为Apache的一个模块启动与终止（或者PHP-FPM的启动与终止），在这次的启动中PHP会初始化一些必要的数据，并将这些数据常驻内存；终止则相反。另外一个则是当接收到一个请求时，PHP会有一次启动和终止。&lt;/p&gt;
&lt;p&gt;PHP内核中预置了四个与启动、终止有关的宏函数：PHP_MINIT_FUNCTION、PHP_MSHUTDOWN_FUNCTION、PHP_RINIT_FUNCTION、PHP_RSHUTDOWN_FUNCTION。&lt;/p&gt;
&lt;h3 id=&#34;1-php_minit_function&#34;&gt;1、PHP_MINIT_FUNCTION&lt;/h3&gt;
&lt;p&gt;当PHP最初的初始化时，会把自己所有已加载扩展的PHP_MINIT_FUNCTION方法都执行一遍。在PHP_MINIT_FUNCTION中定义的内容都会常驻内存，可以被所有请求使用。《PHP扩展开发与内核应用》中的栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//walu是我扩展的名称
int time_of_minit;//在MINIT()中初始化，在每次页面请求中输出，看看是否变化
PHP_MINIT_FUNCTION(walu)
{
    time_of_minit=time(NULL);//我们在MINIT启动中对他初始化
    return SUCCESS;//返回SUCCESS代表正常，返回FALIURE就不会加载这个扩展了。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-php_rinit_function&#34;&gt;2、PHP_RINIT_FUNCTION&lt;/h3&gt;
&lt;p&gt;当PHP接收到一个请求时，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展，遍历执行它们各自的PHP_RINIT_FUNCTION方法。栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int time_of_rinit;//在RINIT里初始化，看看每次页面请求的时候是否变化。
PHP_RINIT_FUNCTION(walu)
{
	time_of_rinit=time(NULL);
	return SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-php_rshutdown_function&#34;&gt;3、PHP_RSHUTDOWN_FUNCTION&lt;/h3&gt;
&lt;p&gt;当接收的请求结束时，PHP会启动回收程序，执行所有已加载扩展的PHP_RSHUTDOWN_FUNCTION方法，释放这次请求使用过的所有东西。栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PHP_RSHUTDOWN_FUNCTION(walu)
{
	FILE *fp=fopen(&amp;quot;time_rshutdown.txt&amp;quot;,&amp;quot;a+&amp;quot;);
	fprintf(fp,&amp;quot;%ld\n&amp;quot;,time(NULL));//让我们看看是不是每次请求结束都会在这个文件里追加数据
	fclose(fp);
	return SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-php_mshutdown_function&#34;&gt;4、PHP_MSHUTDOWN_FUNCTION&lt;/h3&gt;
&lt;p&gt;当Apache（或者PHP-FPM）需要停止时，PHP便会执行所有扩展的PHP_MSHUTDOWN_FUNCTION方法，一旦PHP将所有这些方法执行完，便会进入自毁程序（一定要将擅自申请的内存释放掉）。栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PHP_MSHUTDOWN_FUNCTION(walu)
{
	FILE *fp=fopen(&amp;quot;time_mshutdown.txt&amp;quot;,&amp;quot;a+&amp;quot;);
	fprintf(fp,&amp;quot;%ld\n&amp;quot;,time(NULL));
	return SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面提到的四个栗子中的宏都是在wuli.c中实现的。&lt;br&gt;
将以上栗子组合在一起进行测试，其结果为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time_of_minit的值每次请求都不变；&lt;/li&gt;
&lt;li&gt;time_of_rinit的值每次请求都改变；&lt;/li&gt;
&lt;li&gt;每次页面请求结束都会往time_rshutdown.txt中写入数据；&lt;/li&gt;
&lt;li&gt;只有在apache结束后time_mshutdown.txt才写入有数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，四个宏函数执行的时机和所描述一致。&lt;/p&gt;
">PHP内核源码阅读记---round 2 SAPI与PHP的启动及终止</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/3seRI-Kpj/"" data-c="
          &lt;p&gt;一直想了解一下PHP底层源码的实现，同时还可以增强自己的C语言能力，于是颇有兴致的在PHP官网下载了源码，打开整个项目却不知从何下手，然后就找了阅读资料---&lt;a href=&#34;https://www.php-internals.com&#34;&gt;《TIPI：深入了解PHP内核》&lt;/a&gt;、&lt;a href=&#34;https://github.com/walu/phpbook/blob/master/preface.md&#34;&gt;《PHP扩展开发及内核应用》&lt;/a&gt;、《PHP7内核剖析》，感谢各位编写的大佬！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;因此，该系列博客都是在阅读《TIPI：深入了解PHP内核》、《PHP扩展开发及内核应用》、《PHP7内核剖析》过程中自己的一些总结、摘录。&lt;/p&gt;
&lt;h2 id=&#34;一-php源码目录结构&#34;&gt;一、PHP源码目录结构&lt;/h2&gt;
&lt;p&gt;阅读源码自然少不了理解源码各个目录结构和功能，目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;.             // 主要包含一些说明文件以及设计方案，有一个比较重要的文件CODING_STANDARDS，如果要想写PHP扩展的话，这个文件一定要阅读一下，它存放了开发的编码规范
..
├── build       // 存放源码编译的相关文件
├── ext         // 官方扩展目录，包括绝大多数PHP函数的定义和实现
├── main        // 这里存放的就是PHP最为核心的文件了，主要实现PHP的基本设施，这里和Zend引擎不一样，Zend引擎主要实现语言最核心的语言运行环境
├── pear        // “PHP 扩展与应用仓库”，包含PEAR的核心文件
├── sapi        // 包含了各种服务器抽象层的代码，例如apache的mod_php，cgi，fastcgi以及fpm等等接口
├── TSRM        // Thread Safe Resource Manager，线程安全资源管理器，PHP的线程安全是构建在TSRM库之上的
├── Zend        // Zend引擎，比如脚本的词法语法解析，opcode的执行以及扩展机制的实现等等
└── tests       // 测试脚本集合
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-c语言常用代码&#34;&gt;二、C语言常用代码&lt;/h2&gt;
&lt;h3 id=&#34;1&#34;&gt;1. &amp;quot;##&amp;quot;&lt;/h3&gt;
&lt;p&gt;在C语言的宏中，&amp;quot;##&amp;quot;被称为 &lt;strong&gt;连接符&lt;/strong&gt;（concatenator），它是一种预处理运算符，用来把两个语言符号(Token)组合成单个语言符号。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define PHP_FUNCTION ZEND_FUNCTION
#define ZEND_FUNCTION(name) ZEND_NAMED_FUNCTION(ZEND_FN(name))
#define ZEND_FN(name) zif_##name
#define ZEND_NAMED_FUNCTION(name) void name(INTERNAL_FUNCTION_PARAMETERS)
#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \
zval *this_ptr, int return_value_used TSRMLS_DC

PHP_FUNCTION(count);

//  预处理器处理以后， PHP_FUCNTION(count);就展开为如下代码
void zif_count(int ht, zval *return_value, zval **return_value_ptr,
        zval *this_ptr, int return_value_used TSRMLS_DC)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;宏ZEND_FN(name)中有一个&amp;quot;##&amp;quot;，它的作用一如之前所说，是一个连接符，将zif和宏的变量name的值连接起来。&lt;/p&gt;
&lt;h3 id=&#34;2-和&#34;&gt;2、&amp;quot;#&amp;quot;和&amp;quot;##&amp;quot;&lt;/h3&gt;
&lt;p&gt;&amp;quot;#&amp;quot;是一种预处理运算符，它的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号，用比较官方的话说就是将语言符号(Token)转化为字符串。 例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define STR(x) #x

int main(int argc char** argv)
{
    printf(&amp;quot;%s\n&amp;quot;, STR(It&#39;s a long string)); // 输出 It&#39;s a long string
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;##&amp;quot;则是将两个变量连接成一个字符串，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define STR_CONCATE(a, b) a##b
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-宏定义中的do-while循环&#34;&gt;3、宏定义中的do-while循环&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define ALLOC_ZVAL(z)                                   \
do {                                                \
    (z) = (zval*)emalloc(sizeof(zval_gc_info));     \
    GC_ZVAL_INIT(z);                                \
} while (0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么在宏定义时需要使用do-while语句呢? 这种方式使用于宏定义中存在多语句的情况。举个反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define TEST(a, b)  a++;b++;

if (expr)
    TEST(a, b);
else
    do_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码经过预处理后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (expr)
    a++;b++;
else
    do_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见预处理后的if-else结构被破坏了，达不到预想的效果，而原因就在于宏只是简单的代码替换。那为什么不用{}代替do{}while(0)呢？我们可以尝试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define Test(a, b)                          \
{                                       \
    a++;                                \
    b++;                                \
}

if (expr)
    TEST(a, b);
else
    do_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预处理后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (expr)
    {
        a++;
        b++;
    };
else
    do_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，在}号后面跟了一个分号，这是因为调用宏时，后面的分号可有可无，但是我们会习惯性的加上，这时预处理之后的代码将不能通过编译，所以我们通常使用do{}while(0)结构来应对多表达式的宏定义。&lt;/p&gt;
&lt;h2 id=&#34;三-php运行时的一些全局参数&#34;&gt;三、PHP运行时的一些全局参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _php_core_globals {
        zend_bool magic_quotes_gpc; //  是否对输入的GET/POST/Cookie数据使用自动字符串转义。
        zend_bool magic_quotes_runtime; //是否对运行时从外部资源产生的数据使用自动字符串转义
        zend_bool magic_quotes_sybase;  //   是否采用Sybase形式的自动字符串转义

        zend_bool safe_mode;    //  是否启用安全模式

        zend_bool allow_call_time_pass_reference;   //是否强迫在函数调用时按引用传递参数
        zend_bool implicit_flush;   //是否要求PHP输出层在每个输出块之后自动刷新数据

        long output_buffering;  //输出缓冲区大小(字节)

        char *safe_mode_include_dir;    //在安全模式下，该组目录和其子目录下的文件被包含时，将跳过UID/GID检查。
        zend_bool safe_mode_gid;    //在安全模式下，默认在访问文件时会做UID比较检查
        zend_bool sql_safe_mode;
        zend_bool enable_dl;    //是否允许使用dl()函数。dl()函数仅在将PHP作为apache模块安装时才有效。

        char *output_handler;   // 将所有脚本的输出重定向到一个输出处理函数。

        char *unserialize_callback_func;    // 如果解序列化处理器需要实例化一个未定义的类，这里指定的回调函数将以该未定义类的名字作为参数被unserialize()调用，
        long serialize_precision;   //将浮点型和双精度型数据序列化存储时的精度(有效位数)。

        char *safe_mode_exec_dir;   //在安全模式下，只有该目录下的可执行程序才允许被执行系统程序的函数执行。

        long memory_limit;  //一个脚本所能够申请到的最大内存字节数(可以使用K和M作为单位)。
        long max_input_time;    // 每个脚本解析输入数据(POST, GET, upload)的最大允许时间(秒)。

        zend_bool track_errors; //是否在变量$php_errormsg中保存最近一个错误或警告消息。
        zend_bool display_errors;   //是否将错误信息作为输出的一部分显示。
        zend_bool display_startup_errors;   //是否显示PHP启动时的错误。
        zend_bool log_errors;   // 是否在日志文件里记录错误，具体在哪里记录取决于error_log指令
        long      log_errors_max_len;   //设置错误日志中附加的与错误信息相关联的错误源的最大长度。
        zend_bool ignore_repeated_errors;   //   记录错误日志时是否忽略重复的错误信息。
        zend_bool ignore_repeated_source;   //是否在忽略重复的错误信息时忽略重复的错误源。
        zend_bool report_memleaks;  //是否报告内存泄漏。
        char *error_log;    //将错误日志记录到哪个文件中。

        char *doc_root; //PHP的”根目录”。
        char *user_dir; //告诉php在使用 /~username 打开脚本时到哪个目录下去找
        char *include_path; //指定一组目录用于require(), include(), fopen_with_path()函数寻找文件。
        char *open_basedir; // 将PHP允许操作的所有文件(包括文件自身)都限制在此组目录列表下。
        char *extension_dir;    //存放扩展库(模块)的目录，也就是PHP用来寻找动态扩展模块的目录。

        char *upload_tmp_dir;   // 文件上传时存放文件的临时目录
        long upload_max_filesize;   // 允许上传的文件的最大尺寸。

        char *error_append_string;  // 用于错误信息后输出的字符串
        char *error_prepend_string; //用于错误信息前输出的字符串

        char *auto_prepend_file;    //指定在主文件之前自动解析的文件名。
        char *auto_append_file; //指定在主文件之后自动解析的文件名。

        arg_separators arg_separator;   //PHP所产生的URL中用来分隔参数的分隔符。

        char *variables_order;  // PHP注册 Environment, GET, POST, Cookie, Server 变量的顺序。

        HashTable rfc1867_protected_variables;  //  RFC1867保护的变量名，在main/rfc1867.c文件中有用到此变量

        short connection_status;    //  连接状态，有三个状态，正常，中断，超时
        short ignore_user_abort;    //  是否即使在用户中止请求后也坚持完成整个请求。

        unsigned char header_is_being_sent; //  是否头信息正在发送

        zend_llist tick_functions;  //  仅在main目录下的php_ticks.c文件中有用到，此处定义的函数在register_tick_function等函数中有用到。

        zval *http_globals[6];  // 存放GET、POST、SERVER等信息

        zend_bool expose_php;   //  是否展示php的信息

        zend_bool register_globals; //  是否将 E, G, P, C, S 变量注册为全局变量。
        zend_bool register_long_arrays; //   是否启用旧式的长式数组(HTTP_*_VARS)。
        zend_bool register_argc_argv;   //  是否声明$argv和$argc全局变量(包含用GET方法的信息)。
        zend_bool auto_globals_jit; //  是否仅在使用到$_SERVER和$_ENV变量时才创建(而不是在脚本一启动时就自动创建)。

        zend_bool y2k_compliance;   //是否强制打开2000年适应(可能在非Y2K适应的浏览器中导致问题)。

        char *docref_root;  // 如果打开了html_errors指令，PHP将会在出错信息上显示超连接，
        char *docref_ext;   //指定文件的扩展名(必须含有’.&#39;)。

        zend_bool html_errors;  //是否在出错信息中使用HTML标记。
        zend_bool xmlrpc_errors;   

        long xmlrpc_error_number;

        zend_bool activated_auto_globals[8];

        zend_bool modules_activated;    //  是否已经激活模块
        zend_bool file_uploads; //是否允许HTTP文件上传。
        zend_bool during_request_startup;   //是否在请求初始化过程中
        zend_bool allow_url_fopen;  //是否允许打开远程文件
        zend_bool always_populate_raw_post_data;    //是否总是生成$HTTP_RAW_POST_DATA变量(原始POST数据)。
        zend_bool report_zend_debug;    //  是否打开zend debug，仅在main/main.c文件中有使用。

        int last_error_type;    //  最后的错误类型
        char *last_error_message;   //  最后的错误信息
        char *last_error_file;  //  最后的错误文件
        int  last_error_lineno; //  最后的错误行

        char *disable_functions;    //该指令接受一个用逗号分隔的函数名列表，以禁用特定的函数。
        char *disable_classes;  //该指令接受一个用逗号分隔的类名列表，以禁用特定的类。
        zend_bool allow_url_include;    //是否允许include/require远程文件。
        zend_bool exit_on_timeout;  //  超时则退出
#ifdef PHP_WIN32
        zend_bool com_initialized;
#endif
        long max_input_nesting_level;   //最大的嵌套层数
        zend_bool in_user_include;  //是否在用户包含空间

        char *user_ini_filename;    //  用户的ini文件名
        long user_ini_cache_ttl;    //  ini缓存过期限制

        char *request_order;    //  优先级比variables_order高，在request变量生成时用到，个人觉得是历史遗留问题

        zend_bool mail_x_header;    //  仅在ext/standard/mail.c文件中使用，
        char *mail_log;

        zend_bool in_error_log;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面很多字段都是直接与php.ini配置文件中的配置项对应。在PHP启动并读取php.ini文件时就会对这些字段进行赋值。&lt;/p&gt;
&lt;h2 id=&#34;四-c语言中的union联合体&#34;&gt;四、C语言中的union（联合体）&lt;/h2&gt;
&lt;p&gt;联合体与结构体很相似，但两者有本质上的区别，简单了解一下两个结构的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结构体：占用空间是其内部成员的占用空间总大小；所有成员同时存在。&lt;br&gt;
联合体：内部成员共享一段内存空间，其空间大小取决于成员中占用空间最大者；联合体的值是取自其内部任意一个成员的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* 结构体 */
struct {
  int id;
  char ch;
} s_test;

/* 联合体 */
union {
  int id;
  char ch;
} u_test;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;s_test中的id与ch变量同时存在，而u_test中只可以存在一种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;想了解更多关于联合体的信息，请直走===&amp;gt;&lt;a href=&#34;https://www.baidu.com/s?wd=%E8%81%94%E5%90%88%E4%BD%93&#34;&gt;联合体&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">PHP内核源码阅读记---round 1 准备工作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/5O_fWGHSk/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;一-pjax是什么&#34;&gt;一、pjax是什么&lt;/h2&gt;
&lt;p&gt;pjax是什么? 它是pushState和ajax的合称，相当于是ajax的plus版。&lt;/p&gt;
&lt;h2 id=&#34;二-pjax是干什么的&#34;&gt;二、pjax是干什么的&lt;/h2&gt;
&lt;p&gt;说到pjax的作用，就不得不和ajax作比较的。&lt;/p&gt;
&lt;h3 id=&#34;1-ajax的缺点&#34;&gt;1. ajax的缺点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;ajax缺点：对于每一次的ajax请求，浏览器都不会将其保存在历史记录中，因此当用户返回或前进时，将直接跳出该页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个🌰：&lt;br&gt;
打开浏览器，在地址栏中输入URL，回车：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/pjax/1.jpg&#34; alt=&#34;1.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后点击按钮进行ajax请求：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/pjax/2.jpg&#34; alt=&#34;2.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以发现请求前后的URL是保持不变的，如果这时点击浏览器的返回键，页面就会回到了最初的状态。&lt;/p&gt;
&lt;p&gt;试想一下，如果我们构建一个web应用使用到ajax请求，那就可能意味着我们强行将用户浏览器的返回和前进按给钮扣掉了。&lt;/p&gt;
&lt;h3 id=&#34;2-pjax的解决原理&#34;&gt;2. pjax的解决原理&lt;/h3&gt;
&lt;p&gt;pjax就是为了解决ajax上述问题、提高用户的体验而出现的，其使用的关键技术就是HTML5的pushState。&lt;/p&gt;
&lt;h4 id=&#34;pushstate又是什么呢&#34;&gt;pushState又是什么呢？&lt;/h4&gt;
&lt;p&gt;pushState是HTML5中对history对象新增的方法，所以我们可以得知它是用来操作历史记录的方法，主要作用就是在不刷新网页的情况下改变URL。&lt;/p&gt;
&lt;p&gt;使用语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;pushState(state, title, url);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;又一个🌰：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;https://media.alan123.xyz/jquery/3.3.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&amp;quot;magic&amp;quot;&amp;gt;变个魔术&amp;lt;/button&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $(&#39;#magic&#39;).click(function(event) {
            history.pushState(null, null, Math.random() * 100);
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点击“变个魔术”按钮，你会发现页面并没有刷新，但URL却已经改变了，这时你可以点击返回，URL会变成上一个URL，效果图如下：&lt;br&gt;
&lt;img src=&#34;https://media.alan123.xyz/imgs/blogs/pjax/3.jpg&#34; alt=&#34;3.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;pjax的使用&#34;&gt;pjax的使用&lt;/h4&gt;
&lt;p&gt;OK，了解了pushState，我们大致清楚了pjax的实现原理，接下来开始使用pjax，因为已经有人造好了轮子，所以我们可以直接使用，给个&lt;a href=&#34;https://github.com/defunkt/jquery-pjax&#34;&gt;传送门&lt;/a&gt;。&lt;br&gt;
使用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$(document).pjax(element1, element2);
// element1为触发事件的元素，element2为装载返回内容的容器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个栗子：&lt;br&gt;
① test.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;http://media.alan123.xyz/jquery/3.3.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;http://media.alan123.xyz/jquery/pjax/jquery.pjax.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3 id=&amp;quot;content&amp;quot;&amp;gt;这是标题！&amp;lt;/h3&amp;gt;
    &amp;lt;a href=&amp;quot;test.php&amp;quot;&amp;gt;ajax请求&amp;lt;/a&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $(document).pjax(&#39;a&#39;, &#39;#content&#39;);
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② test.php&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
echo &#39;Hello World&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果就不上图，自己测试吧&lt;/p&gt;
">简单介绍pjax</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/SLev9EFo7/"" data-c="
          &lt;p&gt;以前常常会用到随机数，但是不知道其中的原理，今天在看《PHP经典实例》的时候，发现几个关于随机数的函数，于是想深入了解一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;① rand(min, max)
② mt_rand(min, max)
③ srand(seed)
④ mt_srand(seed)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一-1和2&#34;&gt;一、①和②&lt;/h2&gt;
&lt;p&gt;这两个使用的比较多，所以是比较容易理解&lt;/p&gt;
&lt;h3 id=&#34;1-相同点&#34;&gt;1、相同点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;都是在[min, max]中产生一个随机数，并返回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-不同点&#34;&gt;2、不同点&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;两者实现方法不同，mt_rand 是基于 Mersenne Twister 算法实现的，相对于 rand 函数而言，mt_rand 更随机、性能更好，因此 &lt;strong&gt;通常使用 mt_rand 替换 rand&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二-3和4&#34;&gt;二、③和④&lt;/h2&gt;
&lt;p&gt;PHP官网是这样介绍两者的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;srand — 播下随机数发生器种子 (&lt;a href=&#34;http://www.php.net/manual/zh/function.srand.php&#34;&gt;From Here&lt;/a&gt;)&lt;br&gt;
mt_srand — 播下一个更好的随机数发生器种子 (&lt;a href=&#34;http://php.net/manual/zh/function.mt-srand.php&#34;&gt;From Here&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;emmm...这什么玩意？&lt;br&gt;
种子是啥？&lt;br&gt;
不如动手写代码测试一下这两个蜜汁函数吧&lt;/p&gt;
&lt;h3 id=&#34;1-测试&#34;&gt;1、测试&lt;/h3&gt;
&lt;h4 id=&#34;1测试代码1&#34;&gt;（1）测试代码1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;mt_srand(222);
echo mt_rand();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2结果1&#34;&gt;（2）结果1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;gt; php a.php 
1129637443
&amp;gt; php a.php
1129637443
&amp;gt; php a.php
1129637443
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哇噢😯，amazing，三次执行的结果都是一样的，写个循环再测一下&lt;br&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;3测试代码2&#34;&gt;（3）测试代码2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;mt_srand(222);
for ($i = 10; $i &amp;gt; 0; $i--) {
    $random = mt_rand();
    echo $random, &#39;  &#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4结果2&#34;&gt;（4）结果2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; php a.php
1129637443  456190486  1471707449  1162403591  1794596641  
1925135807  1403950198  1583402994  79504043  1458688054
&amp;gt; php a.php
1129637443  456190486  1471707449  1162403591  1794596641  
1925135807  1403950198  1583402994  79504043  1458688054
&amp;gt; php a.php
1129637443  456190486  1471707449  1162403591  1794596641  
1925135807  1403950198  1583402994  79504043  1458688054
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然一次循环内部的数都不一样，但是每次生成的值都是一一对应相同的，玄学...&lt;/p&gt;
&lt;h3 id=&#34;2-原理&#34;&gt;2、原理&lt;/h3&gt;
&lt;p&gt;然后搜索一下随机数发生器的实现原理，终于找到了答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实通常情况下我们使用的随机数发生器产生的随机数都不是真正随机的，转念一想，好像有道理，毕竟计算机是按照固定的程序代码在执行的，通过固定不变的东西又怎么能产生随机的数呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br /&gt;
那我们使用的随机数发生器是怎么产生随机数的呢？
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;（下文引用自知乎--王納米--的回答===&lt;a href=&#34;https://www.zhihu.com/question/20423025&#34;&gt;传送门&lt;/a&gt;）&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;大部分程序和语言中的随机数，确实都只是伪随机。是由可确定的函数（常用线性同余），通过一个种子（常用时钟），产生的。这意味着：如果知道了种子，或者已经产生的随机数，都可能获得接下来随机数序列的信息（可预测性）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br /&gt;
So, 种子就是随机数发生器生成随机数的依据，相同生成器采用相同种子生成的随机数都是一样的，即可预测性。因此，上面两个测试也就可以得到完美的解释了。我也了解了官网的这句话（ㄟ( ▔, ▔ )ㄏ）：
&gt; 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。
&lt;p&gt;咱不用播种，只等收割（手动吃瓜...）&lt;/p&gt;
&lt;br /&gt;
### 3、区别
&lt;p&gt;我测试的结果是两个并没什么区别（测试方法：播种，然后循环获取10次随机数），不管是srand+rand、mt_srand+mt_rand、srand+mt_rand，还是mt_srand+rand，它们最后的结果都是一样的&lt;/p&gt;
">随机数生成器原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/dOFXuIlwo/"" data-c="
          &lt;h2 id=&#34;markdown-的设计哲学&#34;&gt;Markdown 的设计哲学&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 的目標是實現「易讀易寫」。&lt;br&gt;
不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。&lt;br&gt;
Markdown 的語法有個主要的目的：用來作為一種網路內容的&lt;em&gt;寫作&lt;/em&gt;用語言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;本文约定&#34;&gt;本文约定&lt;/h2&gt;
&lt;p&gt;如果有写 &lt;code&gt;效果如下：&lt;/code&gt;， 在 MWeb 编辑状态下只有用 &lt;code&gt;CMD + 4&lt;/code&gt; 或 &lt;code&gt;CMD + R&lt;/code&gt; 预览才可以看效果。&lt;/p&gt;
&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 第一级标题 `&amp;lt;h1&amp;gt;` 
## 第二级标题 `&amp;lt;h2&amp;gt;` 
###### 第六级标题 `&amp;lt;h6&amp;gt;` 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h1 id=&#34;第一级标题-h1&#34;&gt;第一级标题 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;h2 id=&#34;第二级标题-h2&#34;&gt;第二级标题 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;h6 id=&#34;第六级标题-h6&#34;&gt;第六级标题 &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/h6&gt;
&lt;h2 id=&#34;强调&#34;&gt;强调&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*这些文字会生成`&amp;lt;em&amp;gt;`*
_这些文字会生成`&amp;lt;u&amp;gt;`_

**这些文字会生成`&amp;lt;strong&amp;gt;`**
__这些文字会生成`&amp;lt;strong&amp;gt;`__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 MWeb 中的快捷键为： &lt;code&gt;CMD + U&lt;/code&gt;、&lt;code&gt;CMD + I&lt;/code&gt;、&lt;code&gt;CMD + B&lt;/code&gt;&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这些文字会生成&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;这些文字会生成&lt;code&gt;&amp;lt;u&amp;gt;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些文字会生成&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;这些文字会生成&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;换行&#34;&gt;换行&lt;/h2&gt;
&lt;p&gt;四个及以上空格加回车。&lt;br&gt;
如果不想打这么多空格，只要回车就为换行，请勾选：&lt;code&gt;Preferences&lt;/code&gt; - &lt;code&gt;Themes&lt;/code&gt; - &lt;code&gt;Translate newlines to &amp;lt;br&amp;gt; tags&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 项目一 无序列表 `* + 空格键`
* 项目二
	* 项目二的子项目一 无序列表 `TAB + * + 空格键`
	* 项目二的子项目二
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 MWeb 中的快捷键为： &lt;code&gt;Option + U&lt;/code&gt;&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目一 无序列表 &lt;code&gt;* + 空格键&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;项目二
&lt;ul&gt;
&lt;li&gt;项目二的子项目一 无序列表 &lt;code&gt;TAB + * + 空格键&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;项目二的子项目二&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 项目一 有序列表 `数字 + . + 空格键`
2. 项目二 
3. 项目三
	1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`
	2. 项目三的子项目二
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目一 有序列表 &lt;code&gt;数字 + . + 空格键&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;项目二&lt;/li&gt;
&lt;li&gt;项目三
&lt;ol&gt;
&lt;li&gt;项目三的子项目一 有序列表 &lt;code&gt;TAB + 数字 + . + 空格键&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;项目三的子项目二&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列表中嵌入代码块语法&#34;&gt;列表中嵌入代码块语法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 项目一 有序列表 `数字 + . + 空格键`
    
    列表中嵌入代码块必须前后空一行，如这个写法
       
    ```js
    function fancyAlert(arg) {
      if(arg) {
        $.facebox({div:&#39;#foo&#39;})
      }
    }
    ```
    
    其他文本。
    
2. 项目二
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;任务列表task-lists&#34;&gt;任务列表（Task lists）&lt;/h3&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- [ ] 任务一 未做任务 `- + 空格 + [ ]`
- [x] 任务二 已做任务 `- + 空格 + [x]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9278392&#34;&gt; 任务一 未做任务 &lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9278392&#34;&gt; 任务一 未做任务 `- + 空格 + [ ]`&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5746529&#34;&gt; 任务二 已做任务 &lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5746529&#34;&gt; 任务二 已做任务 `- + 空格 + [x]`&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)
格式: ![Alt Text](url)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Control + Shift + I&lt;/code&gt; 可插入Markdown语法。&lt;br&gt;
如果是 MWeb 的文档库中的文档，还可以用拖放图片、&lt;code&gt;CMD + V&lt;/code&gt; 粘贴、&lt;code&gt;CMD + Option + I&lt;/code&gt; 导入这三种方式来增加图片。&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://zh.mweb.im/asset/img/set-up-git.gif&#34; alt=&#34;GitHub set up&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 &lt;code&gt;-w + 图片宽度&lt;/code&gt; 即可，比如说要设置上面的图片的宽度为 140，语法如为 &lt;code&gt;![GitHub-w140](set-up-git.gif)&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://zh.mweb.im/asset/img/set-up-git.gif&#34; alt=&#34;GitHub set up-w140&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;email &amp;lt;example@example.com&amp;gt;
[GitHub](http://github.com)
自动生成连接  &amp;lt;http://www.github.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Control + Shift + L&lt;/code&gt; 可插入Markdown语法。&lt;br&gt;
如果是 MWeb 的文档库中的文档，拖放或&lt;code&gt;CMD + Option + I&lt;/code&gt; 导入非图片时，会生成连接。&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;p&gt;Email 连接： &lt;a href=&#34;mailto:example@example.com&#34;&gt;example@example.com&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://github.com&#34;&gt;连接标题Github网站&lt;/a&gt;&lt;br&gt;
自动生成连接像： &lt;a href=&#34;http://www.github.com/&#34;&gt;http://www.github.com/&lt;/a&gt; 这样&lt;/p&gt;
&lt;h2 id=&#34;区块引用&#34;&gt;区块引用&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;某某说:
&amp;gt; 第一行引用
&amp;gt; 第二行费用文字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CMD + Shift + B&lt;/code&gt; 可插入Markdown语法。&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;p&gt;某某说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一行引用&lt;br&gt;
第二行费用文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;行内代码&#34;&gt;行内代码&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;像这样即可：`&amp;lt;addr&amp;gt;` `code`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CMD + K&lt;/code&gt; 可插入Markdown语法。&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;p&gt;像这样即可：&lt;code&gt;&amp;lt;addr&amp;gt;&lt;/code&gt; &lt;code&gt;code&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;多行或者一段代码&#34;&gt;多行或者一段代码&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```js
function fancyAlert(arg) {
  if(arg) {
    $.facebox({div:&#39;#foo&#39;})
  }

}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CMD + Shift + K&lt;/code&gt; 可插入Markdown语法。&lt;br&gt;
效果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function fancyAlert(arg) {
	if(arg) {
		$.facebox({div:&#39;#foo&#39;})
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;顺序图或流程图&#34;&gt;顺序图或流程图&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```sequence
张三-&amp;gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&amp;gt;张三: 忙得吐血，哪有时间写。
```

```flow
st=&amp;gt;start: 开始
e=&amp;gt;end: 结束
op=&amp;gt;operation: 我的操作
cond=&amp;gt;condition: 确认？

st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下（ &lt;code&gt;Preferences&lt;/code&gt; - &lt;code&gt;Themes&lt;/code&gt; - &lt;code&gt;Enable sequence &amp;amp; flow chart&lt;/code&gt; 才会看到效果 ）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sequence&#34;&gt;张三-&amp;gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&amp;gt;张三: 忙得吐血，哪有时间写。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34;&gt;st=&amp;gt;start: 开始
e=&amp;gt;end: 结束
op=&amp;gt;operation: 我的操作
cond=&amp;gt;condition: 确认？

st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多请参考：&lt;a href=&#34;http://bramp.github.io/js-sequence-diagrams/&#34;&gt;http://bramp.github.io/js-sequence-diagrams/&lt;/a&gt;, &lt;a href=&#34;http://adrai.github.io/flowchart.js/&#34;&gt;http://adrai.github.io/flowchart.js/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;第一格表头 | 第二格表头
--------- | -------------
内容单元格 第一列第一格 | 内容单元格第二列第一格
内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;第一格表头&lt;/th&gt;
&lt;th&gt;第二格表头&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内容单元格 第一列第一格&lt;/td&gt;
&lt;td&gt;内容单元格第二列第一格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容单元格 第一列第二格 多加文字&lt;/td&gt;
&lt;td&gt;内容单元格第二列第二格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;删除线&#34;&gt;删除线&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;加删除线像这样用： ~~删除这些~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;加删除线像这样用： &lt;s&gt;删除这些&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;分隔线&#34;&gt;分隔线&lt;/h2&gt;
&lt;p&gt;以下三种方式都可以生成分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***

*****

- - -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mathjax&#34;&gt;MathJax&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;块级公式：
$$	x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]

行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下（&lt;code&gt;Preferences&lt;/code&gt; - &lt;code&gt;Themes&lt;/code&gt; - &lt;code&gt;Enable MathJax&lt;/code&gt; 才会看到效果）：&lt;/p&gt;
&lt;p&gt;块级公式：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;±&lt;/mo&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.276389em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.590389em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;±&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord sqrt&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.913389em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;padding-left:0.833em;&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.873389em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail&#34; style=&#34;min-width:0.853em;height:1.08em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.08em&#39; viewBox=&#39;0 0 400000 1080&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.12661100000000003em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =&lt;br&gt;
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}&lt;br&gt;
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \]&lt;/p&gt;
&lt;p&gt;行内公式： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Γ&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;!&lt;/mo&gt;&lt;mspace width=&#34;1em&#34;/&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∀&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi mathvariant=&#34;double-struck&#34;&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;Γ&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:1em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∀&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∈&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68889em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathbb&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;脚注footnote&#34;&gt;脚注（Footnote）&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是一个脚注：[^sample_footnote]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;这是一个脚注：&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id=&#34;注释和阅读更多&#34;&gt;注释和阅读更多&lt;/h2&gt;
&lt;!-- comment --&gt;
&lt;!-- more --&gt;
&lt;p&gt;Actions-&amp;gt;Insert Read More Comment &lt;em&gt;或者&lt;/em&gt; &lt;code&gt;Command + .&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;注&lt;/strong&gt; 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。&lt;/p&gt;
&lt;h2 id=&#34;toc&#34;&gt;TOC&lt;/h2&gt;
&lt;p&gt;Markdown 语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[TOC]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr class=&#34;footnotes-sep&#34;&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;ol class=&#34;footnotes-list&#34;&gt;
&lt;li id=&#34;fn1&#34; class=&#34;footnote-item&#34;&gt;&lt;p&gt;这里是脚注信息 &lt;a href=&#34;#fnref1&#34; class=&#34;footnote-backref&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
">Markdown 语法和 MWeb 写作使用说明</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/KxYcoJzJQ/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;在PHP7中加入了参数数据类型声明以及返回值数据类型声明，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function test1(string $name) : string
{
    return &amp;quot;Hello&amp;quot; . $name;
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但很多时候我们都会遇到返回值类型或者参数类型为null，即Nullable Types（可空类型），例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function test2(string $name) : string
{
    if ($name == null) &amp;quot;name is null&amp;quot;;
    else if ($name == &amp;quot;Alan&amp;quot;) return null;
    else return &amp;quot;Hello&amp;quot; . $name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是上面这种写法是不正确的，因为在某些情况下会报错，例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 当$name = null时， 报错：Fatal error: Uncaught TypeError: Argument 1 passed to test2() must be of the type string, null given（参数必须为字符串类型，不应该 null）&lt;/p&gt;
&lt;p&gt;② 当$name = &#39;Alan&#39;时，报错：Uncaught TypeError: Return value of test2() must be of the type string, null returned（返回值必须为字符串，而不应该是null）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当遇到可空数据类型时，我们可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function test2(?string $name) : ?string
{
    if ($name == null) &amp;quot;name is null&amp;quot;;
    else if ($name == &amp;quot;Alan&amp;quot;) return null;
    else return &amp;quot;Hello&amp;quot; . $name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&#34;color:red;font-size:20px;&#34;&gt;注意：PHP 7.1版本中才支持Nullable Type&lt;/p&gt;">PHP7.1的返回值或参数的可空类型声明</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/XKA8Irk4t/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;图片api&#34;&gt;图片API&lt;/h2&gt;
&lt;p&gt;最近使用mac上的一款邮件客户端（很不错，叫Canary Mail），它会定时刷新右侧的背景图，感觉挺好看的，所以当然选择据为己有，于是打开Charles抓个包，找到一个很nice的图片API，在此收藏一下备用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web API：&lt;a href=&#34;https://unsplash.com/developers&#34;&gt;https://unsplash.com/developers&lt;/a&gt;&lt;br&gt;
HTML引用：&lt;a href=&#34;https://source.unsplash.com&#34;&gt;https://source.unsplash.com&lt;/a&gt;&lt;br&gt;
（访问以上的网站就能获取相应的使用方法）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方API首页的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to the Official Unsplash API. Create with the largest open collection of high-quality photos. For free.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nice!👍&lt;/p&gt;
">偶然发现的图片API，收藏一哈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/e5uawI6ar/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;MySQL在5.7.8版本中增加了对json数据的支持，而不再是需要使用字符串形式进行存储。下面简单介绍下MySQL对json的操作：&lt;/p&gt;
&lt;h2&gt;1、数据类型--json&lt;/h2&gt;
&lt;p&gt;MySQL使用的字段数据类型就是&lt;span style=&#34;color: blue;&#34;&gt;json&lt;/span&gt;，例如（字段test_json）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table `test_json`(
    id int not null auto_increment primary key, 
    test_json json not null
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2、MySQL的json相关函数&lt;/h2&gt;
&lt;h3&gt;① json_array()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;将数组转化为json格式数据。
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*为下一行打辅助*/
json_array(value1[, value2[, value3[,...]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into `test_json` values (
    null,
    json_array(&#39;Alan&#39;,&#39;Jane&#39;,&#39;Jack&#39;,&#39;Rose&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+----------------------------------+
| id | test_json                        |
+----+----------------------------------+
|  1 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;] |
+----+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;② json_object()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;将对象转化为json格式数据。
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*为下一行打辅助*/
json_object(key1, value1[, key2, value2[, key3, value3[, ...]]]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into `test_json` values (
    null,
    json_object(&#39;name&#39;, &#39;Alan&#39;, &#39;age&#39;, &#39;18&#39;, &#39;desc&#39;, &#39;handsome&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+-------------------------------------------------+
| id | test_json                                       |
+----+-------------------------------------------------+
|  2 | {&amp;quot;age&amp;quot;: 18, &amp;quot;desc&amp;quot;: &amp;quot;handsome&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;} |
+----+-------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;③ json_quote()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;将字符串转化为json数据格式（为字符串增加双引号以及为引号增加转义字符）
&lt;strong&gt;语法：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*为下一行打辅助*/
json_quote(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into `test_json` values(
    null,
    json_quote(&amp;quot;Hello World!&amp;quot;)
),(
    null,
    json_quote(&#39;He say, &amp;quot;Hello World!&amp;quot;&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+----------------------------+
| id | test_json                  |
+----+----------------------------+
|  6 | &amp;quot;Hello World!&amp;quot;             |
|  7 | &amp;quot;He Say, \&amp;quot;Hello World!\&amp;quot;&amp;quot; |
+----+----------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;④ json_unquote()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;与json_quote()作用相反
&lt;strong&gt;语法：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*为下一行打辅助*/
json_unquote(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id, json_unquote(test_json) as test_json 
from `test_json` 
where id=6 or id=7;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+------------------------+
| id | test_json              |
+----+------------------------+
|  6 | Hello World!           |
|  7 | He Say, &amp;quot;Hello World!&amp;quot; |
+----+------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;⑤ json_merge()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;将多个json文本合并成一个json文本
&lt;strong&gt;语法：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*助攻行*/
json_merge(json1, json2[,json3[, json4[, ...]]]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into `test_json` values(
    null,
    json_merge(&#39;[&amp;quot;Alan&amp;quot;,&amp;quot;Jane&amp;quot;]&#39;, &#39;[&amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;]&#39;, &#39;[&amp;quot;other&amp;quot;]&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+-------------------------------------------+
| id | test_json                                 |
+----+-------------------------------------------+
| 10 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;] |
+----+-------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;⑥ json_valid()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;判断json格式是否正确
&lt;strong&gt;语法：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*助攻行*/
json_valid(json);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*助攻行*/
select *,json_valid(test_json) as IsValid from test_json;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;+----+-------------------------------------------------+---------+
| id | test_json                                       | IsValid |
+----+-------------------------------------------------+---------+
|  1 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;]                |       1 |
|  2 | {&amp;quot;age&amp;quot;: 18, &amp;quot;desc&amp;quot;: &amp;quot;handsome&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;} |       1 |
|  4 | &amp;quot;Hello World!&amp;quot;                                  |       1 |
|  5 | &amp;quot;He Say, &#39;Hello World!&#39;&amp;quot;                        |       1 |
|  6 | &amp;quot;Hello World!&amp;quot;                                  |       1 |
|  7 | &amp;quot;He Say, \&amp;quot;Hello World!\&amp;quot;&amp;quot;                      |       1 |
|  8 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       |       1 |
|  9 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       |       1 |
| 10 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       |       1 |
+----+-------------------------------------------------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;⑦ json_type()&lt;/h3&gt;
&lt;strong&gt;作用：&lt;/strong&gt;判断json文本的数据类型
&lt;strong&gt;语法：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*助攻行*/
json_type(jsonData);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;/*助攻行*/
select *,json_type(test_json) as json_type from test_json;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------------------------------------------------+-----------+
| id | test_json                                       | json_type |
+----+-------------------------------------------------+-----------+
|  1 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;]                | ARRAY     |
|  2 | {&amp;quot;age&amp;quot;: 18, &amp;quot;desc&amp;quot;: &amp;quot;handsome&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Alan&amp;quot;} | OBJECT    |
|  4 | &amp;quot;Hello World!&amp;quot;                                  | STRING    |
|  5 | &amp;quot;He Say, &#39;Hello World!&#39;&amp;quot;                        | STRING    |
|  6 | &amp;quot;Hello World!&amp;quot;                                  | STRING    |
|  7 | &amp;quot;He Say, \&amp;quot;Hello World!\&amp;quot;&amp;quot;                      | STRING    |
|  8 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       | ARRAY     |
|  9 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       | ARRAY     |
| 10 | [&amp;quot;Alan&amp;quot;, &amp;quot;Jane&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Rose&amp;quot;, &amp;quot;other&amp;quot;]       | ARRAY     |
+----+-------------------------------------------------+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:#ed0617;&#34;&gt;暂时只写这7个函数，MySQL还有许多关于json的函数，例如：json_append(), json_array_append(), json_array_insert(), json_insert(),  json_remove(), json_replace(), json_set() 等&lt;/span&gt;&lt;/p&gt;
">MySQL的JSON数据类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/qdJ0uunpY/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;以前都是使用腾讯云服务器来学习linux的，但是由于最近课程需要，而我的服务器linux版本又达不到要求，所以打算在电脑上安装我的第三个系统（已经装了win10和黑苹果）——CentOS（属于Red Hat系列）。&lt;/p&gt;
&lt;h2&gt;第一步 下载CentOS的镜像包&lt;/h2&gt;
&lt;p&gt;在CentOS官网下载镜像包（&lt;a style=&#34;color: red;&#34; href=&#34;https://www.centos.org/download/&#34;&gt;https://www.centos.org/download/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;官网有三个不同的版本：&lt;b&gt;DVD ISO、Everything ISO、Minimal ISO&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;b&gt;① DVD ISO&lt;/b&gt;：系统标准安装包，一般使用这个&lt;br&gt;
&lt;p&gt;&lt;b&gt;② Everything ISO&lt;/b&gt;：集成了全部软件的镜像&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;③ Minimal ISO&lt;/b&gt;：最小的安装包，只有很基本的操作系统，功能最少&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2&gt;第二步 将镜像写入到U盘&lt;/h2&gt;
&lt;p&gt;准备好一个U盘、刚下好的CentOS镜像以及UltraISO制作工具&lt;/p&gt;
&lt;p&gt;使用UltraISO将CentOS镜像写入到U盘（UltraISO使用方法自行百度）&lt;/p&gt;
&lt;h2&gt;第三步 设置BIOS启动项&lt;/h2&gt;
&lt;p&gt;① 重启电脑，开机出现Logo时按特定的键进入BIOS（不同品牌电脑方式不同，我的是按ESC）&lt;br&gt;&lt;/p&gt;
&lt;p&gt;② 选择U盘启动&lt;/p&gt;
&lt;h2&gt;第四步 进行配置安装&lt;/h2&gt;
&lt;p&gt;电脑启动后，选择Install CentOS，然后便会进入centos的图形化安装界面，你可以根据自己的需求选择相对应的功能模块进行安装。&lt;/p&gt;
&lt;h3 style=&#34;color: red;&#34;&gt;遇到的问题：&lt;/h3&gt;
&lt;blockquote style=&#34;color: red;&#34;&gt;选择Install CentOS后，出现几项OK代码后，就停下不动了，经过几分钟就出现很多代码，最后进入了一个奇怪的命令行模式，上面就是一堆报错。&lt;/blockquote&gt;
&lt;h3 style=&#34;color:green;&#34;&gt;解决方案：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）在install centos界面，光标移至Install CentOS行，按下Tab键或E键，进入系统引导命令行，其中有一行显示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vmlinuz initrd=initrd.img inst.stage2=hd:LABLE...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将其修改为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vmlinuz initrd=initrd.img dd linux quiet
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;按下Ctrl+X开始执行，然后系统会列出你的设备挂载信息，找到你的U盘（LABEL一般为CentOS开头），并记住第一列的值（例如：sdb4）&lt;br&gt;
（2）重启电脑，同样在Install CentOS按下Tab键或E键，将&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vmlinuz initrd=initrd.img inst.stage2=hd:LABLE...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4(修改为你记住的U盘第一列的信息) quiet
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ctrl+X开始执行，然后就会进入CentOS的安装界面了&lt;/blockquote&gt;&lt;/p&gt;
">安装linux(CentOS)的步骤及遇到的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/ZuePTUWam/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;最近想使用linux定期备份数据库并发送邮件提醒&lt;/p&gt;
&lt;p&gt;于是编写脚本，手动运行，一切都很完美，于是使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加定时任务，但是到了时间却未收到邮件，然后&lt;span style=&#34;font-size: 22px; color: red;&#34;&gt;查看脚本编辑的文件，发现是空的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是在crontab文件中加入重定向：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;* * * * * command &amp;gt;&amp;gt; /(路径)/log/backupDB.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置定时，等待，然后发现输出错误为&lt;span style=&#34;font-size: 22px; color: red;&#34;&gt;未找到mysqldump命令&lt;/span&gt;&lt;br&gt;
推测应该是脚本中的路径问题，于是打开脚本文件，在&lt;span style=&#34;font-size: 22px; color: green;&#34;&gt;命令前加上命令的路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如：/(路径)/mysqldump -uusername -ppassword --all-databases &amp;gt; /(路径)/a.sql&lt;/p&gt;
">crontab定时备份数据库和发送邮件错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/ju6hMqyDs/"" data-c="
          &lt;!-- more --&gt;
&lt;h3&gt;旨在完成：Linux服务器在触发某条件时可以自动发送邮件至管理员，已达到提醒的目的。&lt;/h3&gt;
&lt;p&gt;于是花了些时间在macOS上使用PHPMailer类完成发送邮件的功能（主要是写CSS样式，强迫症TvT），然后开开心心的将文件打包上传到服务器。&lt;/p&gt;
&lt;p&gt;emmm，先测试一下（嘿，运行完成）&lt;/p&gt;
&lt;p&gt;打开邮箱，咋没有呢（漫长的等待....）&lt;/p&gt;
&lt;p&gt;emmm，还是没有，唉，又到了找问题的时候了，可是也没报错呀QAQ&lt;/p&gt;
&lt;h3&gt;搜索了一下，发现PHPMailer自己保存了错误信息(&lt;span style=&#34;color: red;&#34;&gt;ErrorInfo&lt;/span&gt;)，于是将错误信息输出&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!$mail-&amp;gt;Send()) {
    echo $mail-&amp;gt;ErrorInfo;
    return FALSE;
} else {
    return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存退出，运行...&lt;br&gt;
果然输出了错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;SMTP connect() failed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压根就没连上SMTP服务器，这可咋整？&lt;/p&gt;
&lt;h3&gt;然后又是一顿搜索，发现PHPMailer是可以调试的&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// PHPMailer调试

// 0 = off (for production use)

// 1 = client messages

// 2 = client and server messages

$mail-&amp;gt;SMTPDebug = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其加入到代码中，运行，输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;2018-04-06 11:03:05 Connection: opening to smtp.qq.com:25, timeout=300, options=array ()

2018-04-06 11:03:19 SMTP ERROR: Failed to connect to server: Connection timed out (110)

2018-04-06 11:03:19 SMTP connect() failed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;带着错误继续搜索，发现有人通过&lt;span style=&#34;color: red;&#34;&gt;禁用IPv6&lt;/span&gt;解决这个问题，于是我也尝试着禁用了IPv6，可是效果却并不好，错误依然存在，显然这种方法并不适合我的Linux&lt;/h3&gt;
&lt;h3&gt;随后又分别检查了&lt;span style=&#34;color: red;&#34;&gt;OpenSSL扩展是否开启&lt;/span&gt;以及&lt;span style=&#34;color: red;&#34;&gt;相关函数是否被禁用&lt;/span&gt;，但是一切正常&lt;/h3&gt;
&lt;p&gt;最后在百度搜索 SMTP ERROR: Failed to connect to server: Connection timed out (110)，在Stack Overflow上看到PHPMailer的相关配置信息（&lt;a href=&#34;https://stackoverflow.com/questions/34953034/phpmailer-smtp-connect-failed-connection-timed-out-110&#34;&gt;传送门&lt;/a&gt;），于是开始调试自己代码的配置&lt;/p&gt;
&lt;h3&gt;当我添加上以下配置信息后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$mail-&amp;gt;Port = 587;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运行发现，没有错误信息，然后检查接收的邮箱也成功收到了邮件&lt;/h3&gt;
&lt;h3&gt;需要注意的是：&lt;span style=&#34;color: red;&#34;&gt;ssl对应端口465，tls对应端口587&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span style=&#34;color: red;&#34;&gt;在mac系统下，我是没有配置Port这个选项，但是也可以成功发送邮件，具体原因就不得而知了&lt;/span&gt;&lt;/p&gt;
">PHPMailer部署到Linux服务器上发送邮件出错(⊙o⊙)?</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/T9uBL2ufM/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;我们经常会用到这个命令，例如定期备份数据库，定时执行PHP脚本发送邮件等。&lt;/p&gt;
&lt;h3&gt;crontab的命令：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;crontab 选项 参数
# 选项：
# ① -l: 列出用户的定时任务
# ② -e: 编辑用户的定时任务
# ③ -r: 删除用户的定时任务
# ④ -u&amp;amp;lt;用户名&amp;amp;gt;: 指定要设计定时任务的用户
# 参数：包含定时任务的crontab文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;crontab的格式：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
* * * * * command    #分 时 日 月 周几 命令行

# 例如：0 23 * * 5 command
# 意思为：每周五的23:00执行command命令

# * 表示不考虑该条件
# - 表示范围内，例如0 11 1-15 * * command表示每月的1至15号的11:00执行command命令
# , 隔开集合选择，例如0 11 1,15 * * command表示每月的1号和15号的11:00执行command命令
# / 表示频率，例如0 */2 * * * command表示每隔两小时执行command命令
&lt;/code&gt;&lt;/pre&gt;
">让Linux定时执行任务---crontab命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="post/_UqHMO7C8/"" data-c="
          &lt;!-- more --&gt;
&lt;h3&gt;第一步 获取证书文件&lt;/h3&gt;
&lt;p&gt;申请SSL证书后，下载证书文件：&lt;/p&gt;
&lt;p&gt;① example.crt （公钥）&lt;/p&gt;
&lt;p&gt;② example.key  （私钥）&lt;/p&gt;
&lt;h3&gt;第二步 上传至服务器&lt;/h3&gt;
&lt;p&gt;将两个证书文件上传到服务器的Nginx配置文件夹下，例如/usr/local/nginx/conf/&lt;/p&gt;
&lt;h3&gt;第三步 修改Nginx配置信息&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# HTTPS   
server {  
  
    listen 443;  
    server_name www.xxx.com; # 项目域名  
  
    ssl on;  
    ssl_certificate server.crt; #(证书公钥)  
    ssl_certificate_key server.key; #(证书私钥)  
  
    ssl_session_timeout 5m;  
    ssl_protocols  SSLv2 SSLv3 TLSv1;  
    ssl_ciphers  HIGH:!aNULL:!MD5;  
    ssl_prefer_server_ciphers on;         
  
    location / {  
        proxy_pass      http://111.111.111.111 #服务器地址
    }  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;第四步 重启Nginx&lt;/h3&gt;
&lt;p&gt;重启Nginx后，即可通过https://xxx.xxx.xxx访问网站&lt;/p&gt;
&lt;hr /&gt;">Nginx配置SSL证书</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/media/js/mouse/fireworks.js"></script>


<script src="/media/js/cool.js"></script>



</html>