<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>/</id>
    <title>anhoder的进阶日志</title>
    <updated>2021-06-14T15:04:51.646Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="/"/>
    <link rel="self" href="/atom.xml"/>
    <subtitle>一川烟草，满城风絮。</subtitle>
    <logo>/images/avatar.png</logo>
    <icon>/favicon.ico</icon>
    <rights>All rights reserved 2021, anhoder的进阶日志</rights>
    <entry>
        <title type="html"><![CDATA[PostgreSQL的json、jsonb、数组]]></title>
        <id>/post/kYHKCQzOh/</id>
        <link href="/post/kYHKCQzOh/">
        </link>
        <updated>2021-06-14T13:09:40.000Z</updated>
        <summary type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
<!-- more -->
<blockquote>
<p>PostgreSQL中单引号用于表示字符串值，双引号用于表示系统标识符，没有反引号`。</p>
</blockquote>
<h2 id="json-jsonb">JSON、JSONB</h2>
<h3 id="json和jsonb的异同"><code>json</code>和<code>jsonb</code>的异同</h3>
<p>在PostgreSQL中，<code>json</code>和<code>jsonb</code>都是用来存储<code>json</code>数据的。</p>
<p>使用<code>json</code>类型时，PostgreSQL会将输入的<code>json</code>文本存储起来，包括其中的空格以及键的顺序，在查询使用时才去解析。而<code>jsonb</code>类型会将输入的<code>json</code>文本解析为对应的二进制数据进行存储。<code>jsonb</code>类型相较<code>json</code>类型而言更高效，性能更好，且支持建立索引。</p>
<h3 id="json及jsonb的相关sql操作"><code>json</code>及<code>jsonb</code>的相关SQL操作</h3>
<h4 id="表的创建">表的创建</h4>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test (
    id int not null primary key,
    attr_json json not null,
    attr_jsonb jsonb not null
);
</code></pre>
<h4 id="数据插入">数据插入</h4>
<pre><code class="language-sql">INSERT INTO test (id, attr_json, attr_jsonb)
VALUES (1, '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}', '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}'),
       (2, '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}'),
       (3, '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}'),
       (4, '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}', '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}');
</code></pre>
<p>插入后的结果：</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1623679477303.png" alt="插入结果" loading="lazy"></figure>
<p>可见<code>jsonb</code>会对数据进行解析后，再进行存储，<code>json</code>则存储原输入。</p>
<h4 id="数据查询">数据查询</h4>
<pre><code class="language-sql">-- -&gt; 获取对象的属性，结果作为json对象；-&gt;&gt;获取对象的属性，结果作为文本
select attr_json-&gt;'son'-&gt;'age' as son_age, attr_json-&gt;&gt;'son' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="2"><img src="/post-images/1623680145772.png" alt="结果1" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- #&gt; 根据路径获取结果作为json对象；#&gt;&gt; 根据路径获取结果作为文本(json, jsonb结果一致)
select attr_json#&gt;'{son}'-&gt;'age' as son_age, attr_json#&gt;'{son,age}' as son_age2, attr_json#&gt;&gt;'{son}' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="3"><img src="/post-images/1623680312500.png" alt="结果2" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- @&gt;左边是否包含右边；&lt;@右边是否包含左边 (jsonb可用)
select * from test where attr_jsonb@&gt;'{&quot;age&quot;:18}';
</code></pre>
<figure data-type="image" tabindex="4"><img src="/post-images/1623680487862.png" alt="结果3" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ? 是否存在属性
select * from test where attr_jsonb ? 'name';
</code></pre>
<hr>
<pre><code class="language-sql">-- ?| 存在数组中任意一个属性则为true (jsonb可用)
select * from test where attr_jsonb ?| array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="5"><img src="/post-images/1623680779281.png" alt="结果4" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ?&amp; 同时存在数组中的所有属性则为true (jsonb可用)
select * from test where attr_jsonb ?&amp; array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="6"><img src="/post-images/1623680893730.png" alt="结果5" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ::为类型转换
select * from test where (attr_json-&gt;&gt;'age')::int&gt;20;
</code></pre>
<figure data-type="image" tabindex="7"><img src="/post-images/1623681132425.png" alt="结果6" loading="lazy"></figure>
<h4 id="数据更新">数据更新</h4>
<pre><code class="language-sql">-- jsonb_set(jsonb old_jsonb, text[] path, jsonb new_jsonb, bool create_if_missing) 更新jsonb 
update test set attr_jsonb=jsonb_set(attr_jsonb, '{son}', '{&quot;name&quot;:&quot;con&quot;,&quot;age&quot;:2}')
where (attr_jsonb#&gt;&gt;'{son,name}') = 'coco';
</code></pre>
<hr>
<pre><code class="language-sql">-- 根据路径删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb#-'{son,name}';
</code></pre>
<hr>
<pre><code class="language-sql">-- 删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb-'son' where attr_jsonb ? 'son';
</code></pre>
<h2 id="数组">数组</h2>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test_arr (
    id int not null primary key,
    arr int[] not null
);

-- 插入数据
insert into test_arr (id, arr) values (1, array[2,3,4]),(2, array[3,4,5]);

-- 数组合并
select array[1,2,3,4] || array[2,3,4,5]; -- 结果：{1,2,3,4,2,3,4,5}
select 2 || array[2,3,4,5]; -- 结果：{2,2,3,4,5}

-- 数组比较，每个元素依次比较大小
select array[1,2,3,4] &gt; array[1,2,3]; -- 结果: true
select array[1,2,3,4] &gt; array[1,2,4]; -- 结果: false

-- 数组包含关系
select array[1,2,3] @&gt; array[2,3]; -- 结果: true
select array[1,2,3] @&gt; array[2,3,4]; -- 结果: false

-- 数组是否有共同元素
select array[1,2,3] &amp;&amp; array[3,4,5]; -- 结果: true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[musicfox 2.0——golang重写版]]></title>
        <id>/post/NOO340v6g/</id>
        <link href="/post/NOO340v6g/">
        </link>
        <updated>2021-05-14T12:51:23.000Z</updated>
        <summary type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
<!-- more -->
<h2 id="存在的问题与方案">存在的问题与方案</h2>
<p>musicfox最开始是用Dart写的，工作原理大致是主进程fork一个mpg123的子进程，主进程处理UI渲染、用户交互及网络请求等，然后通过进程间管道通信，来控制mpg123子进程的音乐播放、暂停以及播放器的音量大小等。</p>
<p>这种模式下，会存在以下这些问题：</p>
<ul>
<li>依赖mpg123，需要用户手动安装mpg123</li>
<li>mpg123只能播放mp3音乐，网易云无损音质是flac格式，无法播放</li>
<li>进程间需要通过管道进行通信，Windows下不容易处理</li>
<li>Dart大多数三方包都是基于Flutter的，原生包不多</li>
<li>...</li>
</ul>
<p>为了解决这些问题，于是开始采用golang进行重写，优势主要是：</p>
<ul>
<li>golang支持更多平台的二进制编译</li>
<li>拥有丰富的第三方包，例如音频播放的<a href="https://github.com/faiface/beep">beep</a>、TUI渲染的<br>
<a href="https://github.com/charmbracelet/bubbletea">bubbletea</a>、本地数据库的<a href="https://github.com/boltdb/bolt">bolt</a>等等</li>
<li>不需要借助其他进程，所以不存在进程通信</li>
<li>支持mp3、flac、wav等格式音频文件的解码播放</li>
<li>goroutine + chan</li>
</ul>
<p>另外对我自己来说可以深入熟悉golang...</p>
<h2 id="使用go时遇到的问题">使用go时遇到的问题</h2>
<h3 id="协程泄漏">协程泄漏</h3>
<p>在使用golang过程中遇到比较严重的问题就是协程泄漏。例如下面的代码：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {
	c1 := make(chan struct{})
	for i := 0; i &lt; 10; i++ {
		go test(c1)
		fmt.Println(runtime.NumGoroutine())
	}
}

func test(c chan&lt;- struct{}) {
	c &lt;- struct{}{}
}
</code></pre>
<p>执行后会输出：</p>
<pre><code>2
3
4
5
6
7
8
9
10
11
</code></pre>
<p>可见，协程数一直在增加，这是因为没有消费者消费chan中的数据，所有子协程都阻塞在写chan的操作。</p>
<p>类似这种情况就会导致协程数不断增长，出现协程泄漏，内存占用不断上升。</p>
<h3 id="如何尽量避免协程泄漏">如何尽量避免协程泄漏</h3>
<ol>
<li>确保chan都会有相应的消费者、生产者，且生产速度和消费速度差不多</li>
<li>如果需要往chan中压数据或读数据，但又不确定是否有消费者或生产者，可以使用<code>select</code>结构避免阻塞</li>
<li>使用goroutine + chan处理，避免创建大量协程，例如：</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	// 获取data逻辑
	for _, v := range data {
		go test(v)
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(s string) {
	// 假装业务逻辑
	time.Sleep(time.Millisecond)
}
</code></pre>
<p>输出为: 101，也就是新开了100个协程，如果数据更多时，会产生更多协程。这种情况可以考虑创建固定数量的若干个协程，然后通过chan将数据投递给子协程进行处理，避免大量协程占用内存，如：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	c := make(chan string)

	for i := 0; i &lt; 5; i++ {
		go test(c)
	}

	for _, v := range data {
		c &lt;- v
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(c &lt;-chan string) {
	for _ = range c {
        // 业务逻辑
		time.Sleep(time.Millisecond)
	}
}
</code></pre>
<h3 id="协程泄漏排查">协程泄漏排查</h3>
<ol>
<li>runtime.NumGoroutine()查看协程数</li>
<li>使用gops排查，可以查看当前协程数、调用栈等</li>
</ol>
<h2 id="预览">预览</h2>
<figure data-type="image" tabindex="1"><img src="/post-images/1620999111458.png" alt="preview1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1620999246727.png" alt="preview2" loading="lazy"></figure>
<h2 id="安装">安装</h2>
<h3 id="mac">Mac</h3>
<p>提供两种方式安装：</p>
<h4 id="使用brew安装">使用brew安装</h4>
<pre><code class="language-sh">brew tap anhoder/go-musicfox &amp;&amp; brew install go-musicfox
</code></pre>
<p>如果你之前安装过musicfox，需要使用下列命令重新链接:</p>
<pre><code class="language-sh">brew unlink musicfox &amp;&amp; brew link --overwrite go-musicfox
</code></pre>
<h4 id="直接下载">直接下载</h4>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.mac">Mac可执行文件</a>，在iTerm或Terminal中打开</p>
<h3 id="linux">Linux</h3>
<p>身边没有Linux设备，而播放音乐依赖CGO，无法进行交叉编译，所以暂时没有可用的二进制文件</p>
<h3 id="windows">Windows</h3>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.exe">Windows可执行文件</a>，在命令行中运行即可。</p>
<p><strong>推荐使用Windows Terminal，UI及体验会好很多</strong></p>
<h2 id="快捷键">快捷键</h2>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td></td>
</tr>
<tr>
<td>r/R</td>
<td>重新渲染UI</td>
<td>Windows调整窗口大小后，没有事件触发，可以使用该方法手动重新渲染</td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="todo">TODO</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8391065"><label class="task-list-item-label" for="task-item-8391065"> 我的歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2300337"><label class="task-list-item-label" for="task-item-2300337"> 每日推荐歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8991192"><label class="task-list-item-label" for="task-item-8991192"> 每日推荐歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1868604"><label class="task-list-item-label" for="task-item-1868604"> 私人FM</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4894085"><label class="task-list-item-label" for="task-item-4894085"> 歌词显示</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5799736"><label class="task-list-item-label" for="task-item-5799736"> 欢迎界面</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1829224"><label class="task-list-item-label" for="task-item-1829224"> 搜索</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4360166"><label class="task-list-item-label" for="task-item-4360166"> 按歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9398398"><label class="task-list-item-label" for="task-item-9398398"> 按歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5299896"><label class="task-list-item-label" for="task-item-5299896"> 按歌词</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8671828"><label class="task-list-item-label" for="task-item-8671828"> 按歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9774217"><label class="task-list-item-label" for="task-item-9774217"> 按专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7587472"><label class="task-list-item-label" for="task-item-7587472"> 按用户</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5069508"><label class="task-list-item-label" for="task-item-5069508"> 排行榜</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9894256"><label class="task-list-item-label" for="task-item-9894256"> 精选歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8368697"><label class="task-list-item-label" for="task-item-8368697"> 最新专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6330233"><label class="task-list-item-label" for="task-item-6330233"> 热门歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7955695"><label class="task-list-item-label" for="task-item-7955695"> 云盘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5418418"><label class="task-list-item-label" for="task-item-5418418"> 播放方式切换</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7776581"><label class="task-list-item-label" for="task-item-7776581"> 喜欢/取消喜欢</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-171721"><label class="task-list-item-label" for="task-item-171721"> 心动模式/智能模式</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8227347"><label class="task-list-item-label" for="task-item-8227347"> 音乐电台</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6413221"><label class="task-list-item-label" for="task-item-6413221"> 配置文件</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-786155"><label class="task-list-item-label" for="task-item-786155"> 通知功能</label></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个utools插件——hasids加解密]]></title>
        <id>/post/YMhNrwxuT/</id>
        <link href="/post/YMhNrwxuT/">
        </link>
        <updated>2021-03-22T12:07:53.000Z</updated>
        <summary type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
<!-- more -->
<p>utools是什么就不多说了，这里主要说一下<code>hashids</code>插件的使用。</p>
<blockquote>
<p>GitHub地址: <a href="https://github.com/anhoder/utools-hashids">https://github.com/anhoder/utools-hashids</a></p>
</blockquote>
<h2 id="添加hashids配置">添加hashids配置</h2>
<p>hashids加解密需要配置salt及最小长度，可以使用以下关键字进去添加配置的步骤:</p>
<ul>
<li>hadd</li>
<li>hash-add</li>
<li>hash添加配置</li>
</ul>
<figure data-type="image" tabindex="1"><img src="/post-images/1617624599510.png" alt="添加配置" loading="lazy"></figure>
<p>进入之后，依次输入<code>名称</code>-<code>salt</code>-<code>最小长度</code>即可保存配置。</p>
<blockquote>
<p>如果有多个环境配置，多次添加即可，<strong>名称不可重复</strong>。</p>
</blockquote>
<h2 id="hashids加密">hashids加密</h2>
<p>hashids加密有两种方式进入，一种是使用关键字：</p>
<ul>
<li>haen</li>
<li>hash-encode</li>
<li>hash编码</li>
</ul>
<p>进入之后，输入你想要加密的ID，列表中会显示你已有配置的加密结果，回车即可复制，如：</p>
<figure data-type="image" tabindex="2"><img src="/post-images/1617626324547.png" alt="hashids加密" loading="lazy"></figure>
<p>另外一种方法是直接在<code>utools</code>的主输入框内输入需要加密的ID，选择<code>hash编码</code>进入，回车即可复制。</p>
<blockquote>
<ol>
<li>如果你开启了utools的右键超级面板，就更方便了，只需要长按右键你的ID，选择<code>hash编码</code>即可。</li>
<li>如果你需要删除配置，在进入之后使用<code>control</code>+<code>enter</code>或<code>command</code>+<code>enter</code>即可删除选中的配置项。</li>
</ol>
</blockquote>
<h2 id="hashids解密">hashids解密</h2>
<p>解密和加密差不多，就不赘述了，关键字：</p>
<ul>
<li>hade</li>
<li>hash-decode</li>
<li>hash解码</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP中一些好用的技巧]]></title>
        <id>/post/O933qcq8E/</id>
        <link href="/post/O933qcq8E/">
        </link>
        <updated>2021-02-28T12:06:47.000Z</updated>
        <summary type="html"><![CDATA[<p>这里主要介绍一些我知道的PHP的使用技巧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里主要介绍一些我知道的PHP的使用技巧。</p>
<!-- more -->
<h2 id="1-php内置的web-server">1、PHP内置的Web Server</h2>
<p>首先，有个问题：</p>
<blockquote>
<p>如果你需要快速启动一个HTTP服务来调试PHP代码，你会怎么做？</p>
</blockquote>
<p><em>启动php-fpm或php-cgi进程监听9000端口，然后使用Nginx将Http请求通过FastCGI接口转发给php-fpm或php-cgi进程？</em></p>
<p>这不失为一种方法，但是并不算方便。</p>
<p>其实，PHP 5.4.0后就提供了一个内置的Web服务器，你可以执行这个命令来启动它:</p>
<pre><code class="language-sh">php -S 127.0.0.1:8080 a.php
</code></pre>
<p>然后就通过 http://127.0.0.1:8080 来进行访问了。</p>
<h2 id="2-执行php代码时生成debug信息">2、执行PHP代码时生成debug信息</h2>
<blockquote>
<p>在执行PHP代码时，你会用什么方法进行调试？</p>
</blockquote>
<p><em>var_dump、print_r直接输出？</em></p>
<p>除了直接输出，你还可以使用debug模式配合IDE来进行调试。在执行PHP代码时，加上<code>-e</code>参数，同时IDE开启debug监听（需要安装xdebug或yasd等调试类扩展，推荐yasd，它可以调试swoole协程）:</p>
<pre><code class="language-sh">php -e a.php

php -e artisan test:test
</code></pre>
<p>这样你就可以使用IDE的debug功能来调试你的PHP命令了。除此之外，还可以配合PHP的内置Web服务器一起使用：</p>
<pre><code class="language-sh">php -e -S 127.0.0.1:8080 a.php
</code></pre>
<h2 id="3-数组迭代">3、数组迭代</h2>
<blockquote>
<p>需要获取这个数组所有层级的子元素，你会怎么做？</p>
<pre><code class="language-php">$arr = [
  'key1' =&gt; 'value1',
  'key2' =&gt; [
      'key3' =&gt; 'value2',
      'key4' =&gt; [
          'value3',
          'value4',
      ]
  ],
  'key5' =&gt; 'value5'
];
</code></pre>
</blockquote>
<p><em>使用递归？</em></p>
<p>没错，可以使用递归。你也可以选择另外一种方式：</p>
<pre><code class="language-php">$arr = [
    'key1' =&gt; 'value1',
    'key2' =&gt; [
        'key3' =&gt; 'value2',
        'key4' =&gt; [
            'value3',
            'value4',
        ]
    ],
    'key5' =&gt; 'value5'
];

$it = new RecursiveArrayIterator($arr);
$recursiveIt = new RecursiveIteratorIterator($it);
foreach ($recursiveIt as $v) {
    var_dump($v);
}
</code></pre>
<h2 id="4-目录迭代">4、目录迭代</h2>
<blockquote>
<p>需要获取一个目录下所有层级的所有文件，你会怎么做？</p>
</blockquote>
<p><em>这样使用dir迭代？</em></p>
<pre><code class="language-php">function test($dir) {
    $dirHandle = dir($dir);
    while ($item = $dirHandle-&gt;read()) {
        if ($item == '.' || $item == '..') continue;
        $path = &quot;{$dir}/{$item}&quot;;
        if (is_dir($path)) {
            test($path);
        } else {
            var_dump($item);
        }
    }
}
</code></pre>
<p>你还可以用更简单的方法，同样也是PHP内置的迭代器:</p>
<pre><code class="language-php">$it = new RecursiveDirectoryIterator('./');
$reIt = new RecursiveIteratorIterator($it);

foreach ($reIt as $value) {
    var_dump($value);
}
</code></pre>
<h2 id="5-访问对象的私有属性">5、访问对象的私有属性</h2>
<blockquote>
<p>在使用一个库的对象时，想要访问该对象的私有属性，你会怎么做？</p>
</blockquote>
<p><em>?</em></p>
<p>可以使用<code>Closure</code>类的静态方法<code>bind</code>或非静态方法<code>bindTo</code>将函数绑定到该类的作用域下：</p>
<pre><code class="language-php">class A {
    private $name = 'The name of A';
}

$a = new A();

// 方法一
$closure = Closure::bind(function () use ($a) {
    var_dump($a-&gt;name);
}, null, A::class);

// 方法二，通过this访问
//$closure = Closure::bind(function () {
//    var_dump($this-&gt;name);
//}, $a, A::class);

$closure();
</code></pre>
<h2 id="6-fastcgi_request_finish">6、fastcgi_request_finish</h2>
<p>fastcgi_request_finish函数是PHP提供的在CGI模式下可用的方法。</p>
<p>调用此方法会将响应数据立即发送给用户，但不中断后续代码执行。例如：</p>
<pre><code class="language-php">echo 123;
echo 456;

fastcgi_finish_request(); // 此时将响应发送给用户

echo 789;

file_put_contents('a.txt', '789');
</code></pre>
<p>以上代码在CGI模式下执行，你会得到123456的响应数据，并且会生成a.txt文件，内容为789。</p>
<p>这个方法的主要用途就是跳过与响应无关的数据处理，提前返回数据给客户端，提高用户体验。</p>
<blockquote>
<p>仅在CGI模式下可用，其他模式下会报方法不存在的错误</p>
<p>Laravel中Response的send方法也是用到了这个函数</p>
</blockquote>
<h2 id="7-续">7、续...</h2>
<p><em>后续补充...</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中文手写体Excalidraw]]></title>
        <id>/post/8QqIK9WTM/</id>
        <link href="/post/8QqIK9WTM/">
        </link>
        <updated>2021-01-23T12:06:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="excalidraw">Excalidraw</h2>
<p>Excalidraw是一个开源的、用于绘制手绘风格草图的项目，GitHub地址为<a href="https://github.com/excalidraw/excalidraw">https://github.com/excalidraw/excalidraw</a>，用它制作的草图效果如下：</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1617677708342.png" alt="草图" loading="lazy"></figure>
<p>看起来还不错，但是由于这个项目诞生于国外，所以并不支持中文字体：</p>
<figure data-type="image" tabindex="2"><img src="/post-images/1617677730364.png" alt="草图2" loading="lazy"></figure>
<p>几个汉字可以说是格格不入了😂。</p>
<h2 id="替换字体">替换字体</h2>
<p>于是，我找了一些免费的手写字体尝试替换进去，最后找到一个效果还不错的——沐瑶随心手写体。</p>
<figure data-type="image" tabindex="3"><img src="/post-images/1617677746929.png" alt="草图3" loading="lazy"></figure>
<p>沐瑶随心手写体是完全免费，即使是商用。</p>
<blockquote>
<p>沐瑶是作者女儿的名字 WoW<br>
字体下载地址: <a href="https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html">https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html</a></p>
</blockquote>
<h2 id="使用">使用</h2>
<p>如果你想要使用的话，可以访问: <a href="https://danlanhai.gitee.io/excalidraw/">https://danlanhai.gitee.io/excalidraw/</a>或<a href="https://anhoder.github.io/excalidraw/">https://anhoder.github.io/excalidraw/</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自己写个包——PHP8 Attribute收集器]]></title>
        <id>/post/dm-3SDHLz/</id>
        <link href="/post/dm-3SDHLz/">
        </link>
        <updated>2021-01-17T12:05:04.000Z</updated>
        <summary type="html"><![CDATA[<p>PHP8发布已经有一段时间了，新增了不少特性，其中我觉得比较好用的：一个是函数可以指定参数名传参，另外一个就是<strong>注解Attribute</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PHP8发布已经有一段时间了，新增了不少特性，其中我觉得比较好用的：一个是函数可以指定参数名传参，另外一个就是<strong>注解Attribute</strong>。</p>
<!-- more -->
<h2 id="注解">注解</h2>
<p>在PHP8之前，PHP语法上是不支持注解的，只能通过反射来获取类、方法或属性的注释，然后通过解析注释来获取需要的元数据。最具代表性的就是注解包<a href="https://github.com/doctrine/annotations">doctrine/annotations</a>，很多框架都有在用。</p>
<p>使用方法：</p>
<pre><code class="language-php">use Doctrine\Common\Annotations\Annotation\Attribute;
use Doctrine\Common\Annotations\Annotation\Attributes;
use Doctrine\Common\Annotations\Annotation\Target;

/**
 * @Annotation
 * @Target(&quot;CLASS&quot;)
 * @Attributes({
 *     @Attribute(&quot;name&quot;, type=&quot;string&quot;, required=true),
 *     @Attribute(&quot;age&quot;, type=&quot;int&quot;)
 * })
 */
class Student
{
    /**
     * @var string
     */
    private $name;
    
    /**
     * @var int
     */
    private $age
}

/**
 * @Student(name=&quot;anhoder&quot;, age=18)
 */
class Anhoder
{
    
}
</code></pre>
<p>而在PHP8中，注解Attribute是这样的：</p>
<pre><code class="language-php">#[Attribute(Attribute::TARGET_CLASS)]
class Student
{
    public function __construct(private string $name, private int $age)
    {
    }
}

#[Student('anhoder', 18)]
class Anhoder
{

}
</code></pre>
<h2 id="收集注解attribute">收集注解Attribute</h2>
<p>PHP8的Attribute数据也需要通过反射来手动获取：</p>
<pre><code class="language-php">$reflection = new ReflectionClass(Anhoder::class);
var_dump($reflection-&gt;getAttributes());
// array(1) {
//   [0]=&gt;
//   object(ReflectionAttribute)#3 (0) {
//   }
// }
</code></pre>
<p>我们可以实现一个Attribute收集器，用于自动收集项目中或其他composer包中的注解信息。</p>
<h3 id="1-获取所有包的根目录及namespace">1. 获取所有包的根目录及namespace</h3>
<p>通过composer提供的ClassLoader自动加载类，我们获取到所有包的命名空间及对应的根目录：</p>
<pre><code class="language-php">// 获取Composer的自动加载类
function getComposerLoader()
{
    $loaders = spl_autoload_functions();

    foreach ($loaders as $loader) {
        if (is_array($loader) &amp;&amp; isset($loader[0]) &amp;&amp; $loader[0] instanceof ClassLoader) {
            return $loader[0];
        }
    }
    
    throw new NotFoundException('Composer class loader');
}

$composerLoader = getComposerLoader();

// 获取命令空间及目录
$composerLoader-&gt;getPrefixesPsr4();
</code></pre>
<h3 id="2-加载每个包下的annotationconfig类">2. 加载每个包下的AnnotationConfig类</h3>
<p>我们约定：在每个需要收集注解的包下，都放一个AnnotationConfig类，并实现AnnotationConfigInterface接口。用于获取该包下需要扫描的目录及命名空间。例如：</p>
<pre><code class="language-php">class AnnotationConfig implements AnnotationConfigInterface
{

    /**
     * @inheritDoc
     */
    public static function getAnnotationConfigs(): array
    {

        return [
            'scanDirs' =&gt; [
                __NAMESPACE__ =&gt; __DIR__,
            ],
        ];
    }
}
</code></pre>
<p>在以上约定条件下，我们需要遍历第一步获取到的根目录，判断其目录下是否有AnnotationConfig类，若有则调用getAnnotationConfigs方法获取其配置。</p>
<h3 id="3-解析-收集注解">3. 解析、收集注解</h3>
<p>最后一步，就是遍历每个目录下的文件及其对应的类，然后通过反射获取到类、方法、属性及常量的注解信息，并将这些信息存入容器数组中。</p>
<pre><code class="language-php">$namespace = rtrim($namespace, '\\');
$iterator = new RecursiveDirectoryIterator($dir);

foreach ($iterator as $splFileInfo) {
    $basename = $splFileInfo-&gt;getBasename();
    
    if (!$splFileInfo-&gt;isFile() || $splFileInfo-&gt;getExtension() != 'php') {
        // not php file
        continue;
    }

    // PHP File
    $className = $splFileInfo-&gt;getBasename('.' . $splFileInfo-&gt;getExtension());
    $class = &quot;{$namespace}\\{$className}&quot;;
    if (class_exists($class)) {
        $reflection = new ReflectionClass($class);
        $attributes = $reflection-&gt;getAttributes();
    }
}
</code></pre>
<h2 id="封装为composer包">封装为composer包</h2>
<p>以上代码都是简单的示例，实际还需要考虑更多，所以我将其做成了一个composer包——<a href="https://github.com/anhoder/annotations-collector">anhoder/annotations-collector</a>。简单的使用：</p>
<ol>
<li>
<p>安装</p>
<pre><code class="language-sh">composer require anhoder/annotations-collector
</code></pre>
</li>
<li>
<p>创建 <code>AnnotationConfig.php</code> 文件到你项目的根目录</p>
<pre><code class="language-php">class AnnotationConfig implements AnnotationConfigInterface
{

    public static function getAnnotationConfigs(): array
    {
        return [
            // The dirs need to be scanned
            'scanDirs' =&gt; [
                __NAMESPACE__ =&gt; __DIR__,
            ],
        ];
    }
}
</code></pre>
</li>
<li>
<p>添加Annotation及AnnotationHandler.</p>
<pre><code class="language-php">// Annotation
#[Attribute(Attribute::TARGET_CLASS)]
class ClassAnnotation
{
    public const TEST = 'test';

    private string $test;

    public function __construct(string $test)
    {
        $this-&gt;test = $test;
    }
}

// AnnotationHandler
#[AnnotationHandler(ClassAnnotation::class)]
class ClassAnnotationHandler extends AbstractAnnotationHandler
{
    public function handle()
    {
        // Your logic.
        var_dump($this);
    }
}
</code></pre>
</li>
<li>
<p>开始扫描</p>
<pre><code class="language-php">AnnotationHelper::scan();
</code></pre>
</li>
</ol>
<h2 id="附">附</h2>
<p>由于注解需要配合反射来使用，其相比正常代码性能较差，而且在php-fpm模式下，每次请求都需要重新获取注解信息，所以<strong>不推荐在php-fpm下使用注解</strong>，其<strong>更适合一些常驻内存型的项目</strong>，例如：Swoole、WorkerMan等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swoft内存泄漏排查]]></title>
        <id>/post/e-qWPg1ij/</id>
        <link href="/post/e-qWPg1ij/">
        </link>
        <updated>2021-01-16T12:04:00.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在公司使用swoft写了一个定时爬取数据的项目，上线后跟踪线上日志发现swoft的worker进程会<strong>出现周期性的内存溢出</strong>：</p>
<pre><code class="language-txt">Fatal error: Uncaught ErrorException: Allowed memory size of 268435456 bytes exhausted (tried to allocate 262144 bytes)
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>最近在公司使用swoft写了一个定时爬取数据的项目，上线后跟踪线上日志发现swoft的worker进程会<strong>出现周期性的内存溢出</strong>：</p>
<pre><code class="language-txt">Fatal error: Uncaught ErrorException: Allowed memory size of 268435456 bytes exhausted (tried to allocate 262144 bytes)
</code></pre>
<!-- more -->
<h2 id="一-分析">一、分析</h2>
<p>观察到线上worker进程的内存占用是随时间增长而逐渐上升的，所以排除单次执行导致内存溢出的情况，基本可以确定是项目中的某处代码<strong>存在内存泄漏</strong>。</p>
<p>因此，解决问题的关键就在于<strong>如何定位到项目中产生内存泄漏的位置</strong>。</p>
<h2 id="二-定位内存泄漏">二、定位内存泄漏</h2>
<h3 id="1-swoole-tracker">1、Swoole Tracker</h3>
<p><a href="https://business.swoole.com/tracker/index">Swoole Tracker</a>是Swoole官方提供的分析工具，可以用来检测项目中的内存泄漏问题（<a href="https://mp.weixin.qq.com/s/oAyToE4aNyU3-_PQ5ii3aw">使用方法</a>）。</p>
<h4 id="安装">安装</h4>
<p>Swoole Tracker的安装比较简单，因为它本身就是一个php的扩展，而且是已经编译好的，我们只需要将编译好的动态链接库文件(.so)放到php的扩展目录下，然后在php.ini中加上配置即可。</p>
<h4 id="使用">使用</h4>
<p>安装完Swoole Tracker扩展后，在相应的代码中加入Swoole Tracker提供的Hook函数，例如：</p>
<pre><code class="language-php">public function onPipeMessage(Server $server, int $srcWorkerId, $message): void
{
    trackerHookMalloc();
    // ...
}
</code></pre>
<p>接着启动服务，运行一段时间后，在docker容器内执行<code>php -r &quot;trackerAnalyzeLeak();&quot;</code>即可获取到服务运行时的内存申请信息、内存释放信息以及可能存在内存泄漏的位置。</p>
<h4 id="检测结果">检测结果</h4>
<p><a href="/post-images/memory_leak.txt">memory_leak.txt</a></p>
<blockquote>
<p>文件中含命令行颜色代码，可以在命令行使用<code>cat memory_leak.txt</code>查看</p>
</blockquote>
<p>以下是检测结果中可能存在内存泄漏的代码位置：</p>
<pre><code class="language-txt"> The Possible Leak As Malloc Size Keep Growth:
 /var/www/swoft_marketing_engine/vendor/swoft/server/src/Server.php:544 =&gt;  Growth Times : [29];  Growth Size : [181440]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:959 =&gt;  Growth Times : [8];  Growth Size : [2784]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:997 =&gt;  Growth Times : [12];  Growth Size : [17920]
 /var/www/swoft_marketing_engine/vendor/swoft/bean/src/Container.php:413 =&gt;  Growth Times : [24];  Growth Size : [10752]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Database.php:252 =&gt;  Growth Times : [24];  Growth Size : [1536]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Connection/Connection.php:370 =&gt;  Growth Times : [24];  Growth Size : [4608]
</code></pre>
<p>根据结果，<strong>发现是Swoft框架本身某个位置存在内存泄漏</strong>。</p>
<p>但是，检测结果中只有产生内存申请时的代码位置，还不能确定具体是什么地方未释放内存。</p>
<p>因此，只能换一种思路。</p>
<h3 id="2-valgrind">2、Valgrind</h3>
<p>尝试另外一款内存泄漏分析神器——valgrind。</p>
<p>使用后发现分析报告中只会出现相关的C/C++代码，无法定位到具体的PHP代码位置，放弃。</p>
<h3 id="3-memory_get_usage">3、memory_get_usage()</h3>
<p>使用几种内存泄漏分析工具都无果后，尝试使用最原始的方式——PHP的内置函数<code>memory_get_usage()</code>。</p>
<p>大致思路就是在需要调用的函数上下，加上<code>memory_get_usage()</code>函数，例如：</p>
<pre><code class="language-php">var_dump(memory_get_usage());
test();
var_dump(memory_get_usage());
</code></pre>
<p>因为，正常情况下，在函数调用完成后，Zend引擎会将对应的函数栈销毁，相应的内存会被释放。</p>
<blockquote>
<p>在使用时，有一些需要注意的点：</p>
<ol>
<li><code>memory_get_usage()</code>支持一个布尔类型的参数<code>real_usage</code>，表示是否获取真实内存大小，其中包括未被使用的内存空间。因为PHP引擎在申请内存时，会一次申请一大块内存，用于后续使用，以减少系统调用的次数。所以，在这里<strong>不要将它设置为true</strong>。</li>
<li>如果函数中存在循环引用（如：Swoft中ORM的join方法），在函数执行完成后，变量并不会被及时释放，输出内存占用会增加，但是这是正常的。因为当待释放变量达到一定数量或内存达到一定阈值时，PHP的GC才会统一释放掉这些的内存。</li>
</ol>
</blockquote>
<h4 id="检查结果">检查结果</h4>
<p>这种方法虽然费时费力，但效果还算不错。经过一段时间排查，成功定位到了两处内存泄漏：</p>
<ul>
<li>在协程中使用Redis时，Swoft未在协程结束后释放相应的Redis连接信息；</li>
<li>Swoft在处理pipeMessage事件结束后未触发协程结束事件，导致协程数据（MySQL、Redis连接信息等）未被释放。</li>
</ul>
<h2 id="三-解决方案">三、解决方案</h2>
<p>既然已经定位到内存泄漏的原因了，解决办法就不难了：</p>
<ul>
<li>协程结束后，手动unset Redis的连接信息；</li>
<li>在pipeMessgae事件结束后，手动触发协程结束事件，销毁对应协程产生的数据。</li>
</ul>
<h2 id="四-后续">四、后续</h2>
<p>经过以上处理后，<strong>截至目前，线上swoft项目的内存占用稳定在50M左右，未出现内存溢出错误</strong>。</p>
<p>此外，针对这两个问题，我在GitHub上向Swoft团队提交了两个相应的issue及修复PR，目前代码已被合并到master。</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1617677953995.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1617677966544.jpg" alt="" loading="lazy"></figure>
<h2 id="五-总结">五、总结</h2>
<p>其实，内存溢出、内存泄漏的情况并不容易发生（单次运行直接爆内存的除外emmm...），只要你：</p>
<ul>
<li>不轻易使用全局变量、静态变量；</li>
<li>如果不可避免的需要使用到全局变量、静态变量，一定要在用完后unset掉相应的数据。</li>
</ul>
<blockquote>
<p>另外，在排查过程中，用到的一个挺好用的查看内存占用的工具——smem，可以查看程序的USS、PSS、RSS👍。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发中常用的函数]]></title>
        <id>/post/B6gBPbA-S/</id>
        <link href="/post/B6gBPbA-S/">
        </link>
        <updated>2020-12-13T12:03:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="php函数相关">PHP函数相关</h2>
<pre><code class="language-c">
zend_parse_parameters()     // 解析函数参数
// 例如，s表示字符串, 解析一个字符串类型的参数到name, 及其长度到name_len: 
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;name, &amp;name_len) == FAILURE) {
    RETURN_NULL();
}

/* 解析参数时的类型代码 */
b: 布尔类型（对应c类型: zend_bool）
l: 整型（long）
d: 浮点型（double）
s: 字符串（char*, int）
r: 资源型（zval*）
a: 数组（zval*）
o: 对象（zval*）
z: zval（zval*）
</code></pre>
<blockquote>
<p>附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：<br>
<img src="/post-images/1617678458821.jpg" alt="" loading="lazy"></p>
</blockquote>
<h2 id="数组操作">数组操作</h2>
<pre><code class="language-c">array_init(arr)                         // 初始化数组
add_next_index_null(zval*)              // 向数字索引的数组增加null
add_next_index_long(zval*, long)        // ...添加long类型
add_next_index_bool(zval*, 0|1)         // ...添加bool类型
add_next_index_double(zval*, double)  
add_next_index_string(zval*, char*, zend_bool)
add_next_index_zval(zval*, zval*)
// ...
</code></pre>
<p>更多操作数组的函数: <a href="https://www.php.net/manual/en/internals2.variables.arrays.php">https://www.php.net/manual/en/internals2.variables.arrays.php</a></p>
<blockquote>
<p>未完待续...</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发中常用的宏函数]]></title>
        <id>/post/y_zVEbs0X/</id>
        <link href="/post/y_zVEbs0X/">
        </link>
        <updated>2020-12-13T12:02:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="zval类型相关">zval类型相关</h2>
<pre><code class="language-c">
Z_TYPE(zval)        // 获取zval的类型
Z_TYPE_P(*zval)     // 获取*zval的类型
Z_TYPE_PP(**zval)   // 获取**zval的类型

/* zval类型相关常量 */
IS_NULL         // null 
IS_BOOL         // 布尔
IS_LONG         // 整型
IS_DOUBLE       // 浮点型
IS_STRING       // 字符串
IS_ARRAY        // 数组
IS_OBJECT       // 对象
IS_RESOURCE     // 资源

</code></pre>
<h2 id="zval值相关">zval值相关</h2>
<pre><code class="language-c">//操作整数的
#define Z_LVAL(zval)			(zval).value.lval
#define Z_LVAL_P(zval_p)		Z_LVAL(*zval_p)
#define Z_LVAL_PP(zval_pp)		Z_LVAL(**zval_pp)

//操作IS_BOOL布尔型的
#define Z_BVAL(zval)			((zend_bool)(zval).value.lval)
#define Z_BVAL_P(zval_p)		Z_BVAL(*zval_p)
#define Z_BVAL_PP(zval_pp)		Z_BVAL(**zval_pp)

//操作浮点数的
#define Z_DVAL(zval)			(zval).value.dval
#define Z_DVAL_P(zval_p)		Z_DVAL(*zval_p)
#define Z_DVAL_PP(zval_pp)		Z_DVAL(**zval_pp)

//操作字符串的值和长度的
#define Z_STRVAL(zval)			(zval).value.str.val
#define Z_STRVAL_P(zval_p)		Z_STRVAL(*zval_p)
#define Z_STRVAL_PP(zval_pp)		Z_STRVAL(**zval_pp)

#define Z_STRLEN(zval)			(zval).value.str.len
#define Z_STRLEN_P(zval_p)		Z_STRLEN(*zval_p)
#define Z_STRLEN_PP(zval_pp)		Z_STRLEN(**zval_pp)

#define Z_ARRVAL(zval)			(zval).value.ht
#define Z_ARRVAL_P(zval_p)		Z_ARRVAL(*zval_p)
#define Z_ARRVAL_PP(zval_pp)		Z_ARRVAL(**zval_pp)

//操作对象的
#define Z_OBJVAL(zval)			(zval).value.obj
#define Z_OBJVAL_P(zval_p)		Z_OBJVAL(*zval_p)
#define Z_OBJVAL_PP(zval_pp)		Z_OBJVAL(**zval_pp)

#define Z_OBJ_HANDLE(zval)		Z_OBJVAL(zval).handle
#define Z_OBJ_HANDLE_P(zval_p)		Z_OBJ_HANDLE(*zval_p)
#define Z_OBJ_HANDLE_PP(zval_p)		Z_OBJ_HANDLE(**zval_p)

#define Z_OBJ_HT(zval)			Z_OBJVAL(zval).handlers
#define Z_OBJ_HT_P(zval_p)		Z_OBJ_HT(*zval_p)
#define Z_OBJ_HT_PP(zval_p)		Z_OBJ_HT(**zval_p)

#define Z_OBJCE(zval)			zend_get_class_entry(&amp;(zval) TSRMLS_CC)
#define Z_OBJCE_P(zval_p)		Z_OBJCE(*zval_p)
#define Z_OBJCE_PP(zval_pp)		Z_OBJCE(**zval_pp)

#define Z_OBJPROP(zval)			Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)
#define Z_OBJPROP_P(zval_p)		Z_OBJPROP(*zval_p)
#define Z_OBJPROP_PP(zval_pp)		Z_OBJPROP(**zval_pp)

#define Z_OBJ_HANDLER(zval, hf) 	Z_OBJ_HT((zval))-&gt;hf
#define Z_OBJ_HANDLER_P(zval_p, h)	Z_OBJ_HANDLER(*zval_p, h)
#define Z_OBJ_HANDLER_PP(zval_p, h)		Z_OBJ_HANDLER(**zval_p, h)

#define Z_OBJDEBUG(zval,is_tmp)		(Z_OBJ_HANDLER((zval),get_debug_info)?	\
						Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \
						(is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) 
#define Z_OBJDEBUG_P(zval_p,is_tmp)	Z_OBJDEBUG(*zval_p,is_tmp) 
#define Z_OBJDEBUG_PP(zval_pp,is_tmp)	Z_OBJDEBUG(**zval_pp,is_tmp)

//操作资源的
#define Z_RESVAL(zval)			(zval).value.lval
#define Z_RESVAL_P(zval_p)		Z_RESVAL(*zval_p)
#define Z_RESVAL_PP(zval_pp)		Z_RESVAL(**zval_pp)
</code></pre>
<h2 id="创建zval">创建zval</h2>
<pre><code class="language-c">ALLOC_ZVAL              // PHP 7中移除
ALLOC_INIT_ZVAL         // PHP 7中移除
MAKE_STD_ZVAL           // PHP 7中移除
// 例如：
zval *val; MAKE_STD_ZVAL(val);

ZVAL_LONG(*zval, long)      // 将整型值赋给*zval
ZVAL_NULL(*zval)            // null
ZVAL_BOOL(*zval, int)       // bool
ZVAL_TRUE(*zval)            // true
ZVAL_FALSE(*zval)           // false
ZVAL_LONG(*zval, long)      // long
ZVAL_DOUBLE(*zval, double)  // double
ZVAL_STRINGL(*zval,str,len,dup); // string with length
ZVAL_STRING(*zval, str, dup)     // string, dup指明了该字符串是否需要被复制。 值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv， 为 0 时则是直接把str的地址赋值给zval。
ZVAL_RESOURCE(*zval, res);       // resource
</code></pre>
<h2 id="函数相关">函数相关</h2>
<pre><code class="language-c">ZEND_NUM_ARGS()             // 获取函数参数的数量

RETVAL_STRING(s)            // 函数返回字符串
RETURN_STRING(s)            // 函数返回字符串, #define RETURN_STRING(s) { RETVAL_STRING(s); return; }
RETURN_NULL()               // 函数返回null
RETURN_TRUE()               // 函数返回true
</code></pre>
<blockquote>
<p>附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：<br>
<img src="media/16078683686223/16078723189095.jpg" alt="" loading="lazy"></p>
</blockquote>
<h2 id="数组操作">数组操作</h2>
<pre><code class="language-c">ZEND_HASH_FOREACH_VAL(ht, val)
ZEND_HASH_FOREACH_KEY(ht, h, key) 
ZEND_HASH_FOREACH_PTR(ht, ptr)
ZEND_HASH_FOREACH_NUM_KEY(ht, h) 
ZEND_HASH_FOREACH_STR_KEY(ht, key)
ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)
ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)

// 例如：
ZEND_HASH_FOREACH_KEY_VAL(arr_hash, num_key, key, val) {
    //if (key) { //HASH_KEY_IS_STRING
    //}
    PHPWRITE(Z_STRVAL_P(val), Z_STRLEN_P(val));
    php_printf(&quot;\n&quot;);
}ZEND_HASH_FOREACH_END();
</code></pre>
<h2 id="符号表">符号表</h2>
<p>PHP的变量存储在符号表中，不同作用域有不同的符号表。</p>
<pre><code class="language-c">struct _zend_executor_globals {
    ...
    HashTable symbol_table;         // 全局符号表
    HashTable *active_symbol_table; // 当前作用域符号表
    ...
};
</code></pre>
<pre><code class="language-c">EG(active_symbol_table)
EG(symbol_table)
ZEND_SET_SYMBOL(symbol, var_name, val)  // 设置变量到符号表
// 例如：
ZEND_SET_SYMBOL( EG(active_symbol_table) ,  &quot;foo&quot; , fooval);
</code></pre>
<blockquote>
<p>未完待续...</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[又一个命令行版网易云音乐——musicfox]]></title>
        <id>/post/npa_TQCOL/</id>
        <link href="/post/npa_TQCOL/">
        </link>
        <updated>2020-07-12T12:01:18.000Z</updated>
        <summary type="html"><![CDATA[<p>musicfox是一款使用Dart编写的网易云音乐命令行程序。</p>
<p><img src="https://badgen.net/github/release/anhoder/musicfox" alt="last release" loading="lazy"><img src="https://badgen.net/github/license/anhoder/musicfox" alt="GitHub" loading="lazy"><img src="https://badgen.net/github/tag/anhoder/musicfox" alt="Last Tag" loading="lazy"><img src="https://badgen.net/github/stars/anhoder/musicfox" alt="Star" loading="lazy"><img src="https://badgen.net/github/last-commit/anhoder/musicfox" alt="GitHub last commit" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>musicfox是一款使用Dart编写的网易云音乐命令行程序。</p>
<p><img src="https://badgen.net/github/release/anhoder/musicfox" alt="last release" loading="lazy"><img src="https://badgen.net/github/license/anhoder/musicfox" alt="GitHub" loading="lazy"><img src="https://badgen.net/github/tag/anhoder/musicfox" alt="Last Tag" loading="lazy"><img src="https://badgen.net/github/stars/anhoder/musicfox" alt="Star" loading="lazy"><img src="https://badgen.net/github/last-commit/anhoder/musicfox" alt="GitHub last commit" loading="lazy"></p>
<!-- more -->
<h2 id="一-为什么做这个项目">一、为什么做这个项目</h2>
<p>在开始这个项目的之前，其实是已经有一个基于命令行的网易云音乐项目——<a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a>。</p>
<p>我也使用它听了很长一段时间的歌了，其中还贡献过一些代码，修复几个小问题。那为什么还要重新造一个轮子呢？</p>
<blockquote>
<ol>
<li>musicbox缺少一些我特别想要的功能</li>
<li>musicbox使用python进行编写，我对python并不是很熟悉，所以修改或者新增功能时比较麻烦</li>
</ol>
</blockquote>
<h2 id="二-为什么使用dart">二、为什么使用Dart</h2>
<ul>
<li>Dart的语法极像Java，我本身也学过Java，因此学习成本较低；</li>
<li>Dart可以将代码编译成能在三大平台（Windows、Linux、Mac）上直接运行的可执行程序。</li>
</ul>
<h2 id="三-效果预览">三、效果预览</h2>
<figure data-type="image" tabindex="1"><img src="/post-images/1617678066308.png" alt="欢迎界面" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1617678078304.png" alt="主界面1" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="/post-images/1617678089104.png" alt="主界面2" loading="lazy"></figure>
<h2 id="四-安装">四、安装</h2>
<p>依赖mpg123，<strong>必须先安装mpg123</strong></p>
<h3 id="mac">Mac</h3>
<p>提供两种方式安装：</p>
<ol>
<li>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.mac文件，在iTerm或Terminal中运行</li>
<li>使用brew安装：</li>
</ol>
<pre><code class="language-sh">brew tap anhoder/musicfox &amp;&amp; brew install musicfox
</code></pre>
<h3 id="linuxubuntu">Linux(Ubuntu)</h3>
<p>进入到<a href="https://github.com/anhoder/musicfox/releases/latest" title="Release">Release</a>下载musicfox.ubuntu文件，在终端中运行。</p>
<blockquote>
<p>本人没有Linux系统，该执行文件是在WSL2(Ubuntu 2004)下打包的，不确定其他Linux系统是否也能正常使用</p>
</blockquote>
<h3 id="windows">Windows</h3>
<p>下载<a href="./bin/musicfox.exe" title="Windows可执行文件">Windows可执行文件</a>，在命令行(推荐Windows Terminal)中运行即可。</p>
<p><strong>Windows下存在几个已知问题，暂时没有解决方法：</strong></p>
<ol>
<li>暂停时会延迟几秒，播放时不会延迟</li>
<li>登录或搜索输入时，会吞掉第一个字符</li>
<li>上、下、左、右及ESC键无法监听，只能使用字母代替这些操作</li>
<li>命令行窗口大小发生变化后，UI会变乱（因为Windows不支持resize事件）</li>
</ol>
<p><em>因为存在以上问题，所以推荐在WSL下使用，WSL的声音转发可以参考我的另一个<a href="https://github.com/anhoder/wsl-audio-musicbox" title="项目">项目</a></em>。</p>
<h2 id="五-通知功能">五、通知功能</h2>
<h3 id="mac-2">Mac</h3>
<p>Mac下默认使用<code>AppleScript</code>发送通知。如下：</p>
<figure data-type="image" tabindex="4"><img src="/post-images/1617678108326.png" alt="AppleScript" loading="lazy"></figure>
<p>如果想要更好的通知体验，可以安装<code>terminal-notifier</code>:</p>
<pre><code class="language-sh">brew install terminal-notifier
</code></pre>
<p>效果如下：</p>
<figure data-type="image" tabindex="5"><img src="/post-images/1617678123055.png" alt="terminal-notifier" loading="lazy"></figure>
<h3 id="linux">Linux</h3>
<p>Linux可以安装<code>libnotify-bin</code>来使用通知功能（未经测试）</p>
<h3 id="windows-2">Windows</h3>
<p>Windows下可以安装<code>notifu</code>实现通知，体验不太好（没找到其他更好的通知工具）</p>
<blockquote>
<p>当然，如果你有更好的命令行通知程序，你也可以自己实现INotifier接口达到你想要的效果：</p>
<pre><code class="language-dart">abstract class INotifier {
  // 检查该通知程序是否可用
  bool isAvailable();

  // 发送消息
  void send(String message, {String title, String subtitle, String soundName, String groupID, String activateID, String appIcon, String contentImage, String openURL, String executeCmd});
}
</code></pre>
</blockquote>
<h2 id="六-使用">六、使用</h2>
<pre><code class="language-sh">$ musicfox
</code></pre>
<p><strong>按键：</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td>Windows只能使用<code>h</code></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td>Windows只能使用<code>l</code></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td>Windows只能使用<code>k</code></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td>Windows只能使用<code>j</code></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td>Windows只能使用<code>q</code></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td>Windows只能使用<code>n</code></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td>Windows只能使用<code>b</code></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td>Windows只能使用<code>w</code></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td>Windows下使用<code>o</code></td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td>Windows下使用<code>;</code></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td>Windows下使用<code>'</code></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td>Windows下使用<code>\</code></td>
</tr>
</tbody>
</table>
<h2 id="七-todo">七、TODO</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1537864"><label class="task-list-item-label" for="task-item-1537864"> 我的歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7505592"><label class="task-list-item-label" for="task-item-7505592"> 每日推荐歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8991295"><label class="task-list-item-label" for="task-item-8991295"> 每日推荐歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4142288"><label class="task-list-item-label" for="task-item-4142288"> 私人FM</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2796177"><label class="task-list-item-label" for="task-item-2796177"> 歌词显示</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1300158"><label class="task-list-item-label" for="task-item-1300158"> 欢迎界面</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6567607"><label class="task-list-item-label" for="task-item-6567607"> 搜索</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7212717"><label class="task-list-item-label" for="task-item-7212717"> 按歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9267184"><label class="task-list-item-label" for="task-item-9267184"> 按歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8832176"><label class="task-list-item-label" for="task-item-8832176"> 按歌词</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5146545"><label class="task-list-item-label" for="task-item-5146545"> 按歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6422934"><label class="task-list-item-label" for="task-item-6422934"> 按专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-213351"><label class="task-list-item-label" for="task-item-213351"> 按用户</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3117403"><label class="task-list-item-label" for="task-item-3117403"> 排行榜</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9907933"><label class="task-list-item-label" for="task-item-9907933"> 精选歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3365520"><label class="task-list-item-label" for="task-item-3365520"> 最新专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8970588"><label class="task-list-item-label" for="task-item-8970588"> 热门歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2202903"><label class="task-list-item-label" for="task-item-2202903"> 云盘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2252654"><label class="task-list-item-label" for="task-item-2252654"> 播放方式切换</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9312187"><label class="task-list-item-label" for="task-item-9312187"> 喜欢/取消喜欢</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9943735"><label class="task-list-item-label" for="task-item-9943735"> 心动模式/智能模式</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4523947"><label class="task-list-item-label" for="task-item-4523947"> 音乐电台</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9246725"><label class="task-list-item-label" for="task-item-9246725"> 将部分设置转化为文件可配置</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9055213"><label class="task-list-item-label" for="task-item-9055213"> 欢迎界面的欢迎语</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4362981"><label class="task-list-item-label" for="task-item-4362981"> 欢迎界面时长</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4773672"><label class="task-list-item-label" for="task-item-4773672"> 主题色</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5381265"><label class="task-list-item-label" for="task-item-5381265"> 歌词显示行数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3400234"><label class="task-list-item-label" for="task-item-3400234"> ...</label></li>
</ul>
</li>
</ul>
<h2 id="八-伴生项目">八、伴生项目</h2>
<p>在该项目的开发过程中，我将一些通用的功能模块单独抽离出来，做成了几个伴生项目：</p>
<ol>
<li><a href="https://github.com/anhoder/mp3_player" title="mp3_player">mp3_player</a>: dart命令行调用mpg123播放音乐</li>
<li><a href="https://github.com/anhoder/netease_music_request" title="netease_music_request">netease_music_request</a>: Dart实现的网易云音乐接口库，使用Dio发起请求，CookieJar管理Cookie信息</li>
<li><a href="https://github.com/anhoder/colorful_cmd" title="colorful_cmd">colorful_cmd</a>: 使用dart实现的一些命令行UI组件，如：WindowUI命令行窗口应用UI、RainbowProgress彩虹进度条、NotifierProxy三大平台通知代理、ColorText颜色文本...<br>
<img src="/post-images/1617678161539.png" alt="command" loading="lazy"><br>
<img src="/post-images/1617678173841.png" alt="rainbow_progress" loading="lazy"><br>
<img src="/post-images/1617678188194.png" alt="window_ui" loading="lazy"><br>
<img src="/post-images/1617678202350.png" alt="window_ui2" loading="lazy"></li>
</ol>
<h2 id="九-感谢">九、感谢</h2>
<p>感谢以下项目及其贡献者们（不限于）：</p>
<ul>
<li><a href="https://github.com/darknessomi/musicbox" title="musicbox">musicbox</a></li>
<li><a href="https://github.com/Binaryify/NeteaseCloudMusicApi" title="NeteaseCloudMusicApi">NeteaseCloudMusicApi</a></li>
<li><a href="https://github.com/DirectMyFile/console.dart" title="console.dart">console.dart</a></li>
</ul>
]]></content>
    </entry>
</feed>