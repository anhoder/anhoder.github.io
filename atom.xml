<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>/</id>
    <title>anhoder的进阶日志</title>
    <updated>2021-07-31T13:20:33.850Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="/"/>
    <link rel="self" href="/atom.xml"/>
    <subtitle>一川烟草，满城风絮。</subtitle>
    <logo>/images/avatar.png</logo>
    <icon>/favicon.ico</icon>
    <rights>All rights reserved 2021, anhoder的进阶日志</rights>
    <entry>
        <title type="html"><![CDATA[autotools的使用]]></title>
        <id>/post/jCJO8375A/</id>
        <link href="/post/jCJO8375A/">
        </link>
        <updated>2021-07-25T16:07:41.000Z</updated>
        <summary type="html"><![CDATA[<p>最近深入学习一下PHP扩展开发以及C相关知识，就先从autotools开始吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近深入学习一下PHP扩展开发以及C相关知识，就先从autotools开始吧。</p>
<!-- more -->
<h2 id="autotools是什么">autotools是什么？</h2>
<p>autotools是一系列用于自动生成configure脚本的工具集。包括autoconf、automake、libtools。</p>
<p>最初，工程师们在软件开发完之后，通常会配套地编写相应的Makefile文件，用于编译安装自己的程序：</p>
<ol>
<li>编写Makefile文件</li>
<li><code>make</code></li>
<li><code>make install</code></li>
</ol>
<p>但是，随着软件大范围推广使用后，程序可能需要在不同的平台上进行编译安装，而不同平台之间的编译通常存在许多差异。为了避免安装时手动去调整Makefile，工程师们开始编写<code>configure</code>脚本来根据不同平台从模版文件生成Makefile、config.h(一些宏的定义)，Makefile的模版文件是Makefile.in、config.h的模版文件是config.h.in。安装软件的大致流程为：</p>
<ol>
<li>执行<code>configure</code>脚本生成Makefile、config.h</li>
<li><code>make &amp;&amp; make install</code></li>
</ol>
<p>此时，相关文件有三个：Makefile模版文件<code>Makefile.in</code>、config.h模版文件<code>config.h.in</code>、<code>configure</code>。</p>
<p>后来，人们觉得还是太麻烦，于是开发了<code>autoconf</code>用来自动生成<code>configure</code>脚本、<code>automake</code>用于生成Makefile.in模版文件、<code>autoheader</code>用于生成config.h.in模版文件。</p>
<blockquote>
<p>更多的一些介绍及流程，可以参照这篇博客<a href="https://blog.csdn.net/weixin_42398658/article/details/107629877">https://blog.csdn.net/weixin_42398658/article/details/107629877</a></p>
</blockquote>
<h2 id="简单使用">简单使用</h2>
<p>这里使用一段简单的C代码来做演示。</p>
<h4 id="1-编写源代码">1. 编写源代码</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<p>完成之后，可以直接手动编译并执行一下试试：<code>gcc main.c -o main &amp;&amp; ./main</code>。</p>
<h4 id="2-使用autoscan扫描源代码生成configurescan文件">2. 使用autoscan扫描源代码，生成configure.scan文件</h4>
<pre><code class="language-sh">autoscan
</code></pre>
<figure data-type="image" tabindex="1"><img src="/post-images/1627660831826.PNG" alt="" loading="lazy"></figure>
<blockquote>
<p>autoscan.log按名称推测，应该就是autoscan命令产生的相关日志。<br>
configure.scan是一个雏形文件，需要在其基础上进行修改保存为configure.ac。</p>
</blockquote>
<h4 id="3-configurescan复制为configureac并修改内容">3. configure.scan复制为configure.ac，并修改内容</h4>
<p>将configure.scan复制为configure.ac，并修改以下中文注释后内容：</p>
<pre><code>#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

AC_PREREQ([2.71])

# 基础信息
# AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
AC_INIT(helloworld, 1.0.0, anhoder@88.com)

AC_CONFIG_SRCDIR([main.c])
AC_CONFIG_HEADERS([config.h])

# 增加automake配置
AM_INIT_AUTOMAKE

# Checks for programs.
AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

# 生成Makefile
AC_CONFIG_FILES(Makefile)

AC_OUTPUT
</code></pre>
<h4 id="4-aclocal生成aclocalm4">4. aclocal生成aclocal.m4</h4>
<pre><code class="language-sh">aclocal
</code></pre>
<figure data-type="image" tabindex="2"><img src="/post-images/1627660851848.JPG" alt="" loading="lazy"></figure>
<h4 id="5-autoconf生成configure脚本">5. autoconf生成configure脚本</h4>
<pre><code class="language-sh">autoconf
</code></pre>
<figure data-type="image" tabindex="3"><img src="/post-images/1627660860091.JPG" alt="" loading="lazy"></figure>
<p>此时，configure脚本已经成功生成了。</p>
<h4 id="6-autoheader生成confighin">6. autoheader生成config.h.in</h4>
<pre><code class="language-sh">autoheader
</code></pre>
<figure data-type="image" tabindex="4"><img src="/post-images/1627660868315.JPG" alt="" loading="lazy"></figure>
<p>config.h.in文件也已生成。</p>
<h4 id="7-编写makefileam">7. 编写Makefile.am</h4>
<p>Makefile.am用于生成Makefile.in，需要手动编写，<a href="https://www.gnu.org/software/automake/manual/automake.html">官方文档</a>。</p>
<pre><code>bin_PROGRAMS=main
main_SOURCES=main.c
</code></pre>
<p>将上述内容写入到Makefile.am中，保存。</p>
<h4 id="8-automake生成makefilein">8. automake生成Makefile.in</h4>
<pre><code class="language-sh">automake
</code></pre>
<figure data-type="image" tabindex="5"><img src="/post-images/1627660879049.JPG" alt="" loading="lazy"></figure>
<p>出现了报错，需要加上<code>--add-missing</code>选项。</p>
<pre><code class="language-sh">automake --add-missing
</code></pre>
<figure data-type="image" tabindex="6"><img src="/post-images/1627660891520.JPG" alt="" loading="lazy"></figure>
<p>需要添加四个文件，手动创建再执行<code>automake --add-missing</code>即可：</p>
<pre><code class="language-sh">touch NEWS README AUTHORS ChangeLog
automake --add-missing
</code></pre>
<p>至此，三个文件（configure, Makefile.in, config.h.in）全部生成完成。</p>
<blockquote>
<p>查看configure，其实就是个shell脚本。</p>
</blockquote>
<h4 id="9-执行configure脚本-make">9. 执行configure脚本、make</h4>
<pre><code class="language-sh">./configure
make
</code></pre>
<figure data-type="image" tabindex="7"><img src="/post-images/1627660899653.JPG" alt="" loading="lazy"></figure>
<p>可以看到，configure脚本主要是在检查环境以及生成Makefile、config.h。</p>
<p>两个命令执行完成，即编译出了相应的二进制文件<code>main</code>，执行<code>./main</code>查看结果。</p>
<h2 id="总结">总结</h2>
<p>这里主要介绍了autotools的简单使用，为后续PHP扩展开发的学习做铺垫。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021 PHP部分面经]]></title>
        <id>/post/JeWf3QSkh/</id>
        <link href="/post/JeWf3QSkh/">
        </link>
        <updated>2021-06-14T15:27:14.000Z</updated>
        <summary type="html"><![CDATA[<p>前段时间辞职换工作，参加了一些面试，现在也入职了，趁着还不忙稍微整理一下面经（记录一些映像比较深的吧）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前段时间辞职换工作，参加了一些面试，现在也入职了，趁着还不忙稍微整理一下面经（记录一些映像比较深的吧）。</p>
<!-- more -->
<h2 id="广州-爱拍">广州-爱拍</h2>
<p>给我映像最深的就是它的笔试题了，整整4页，还是双面的，而且很多问题都有好几问的...<br>
勉强记得的几个题：</p>
<ul>
<li>TCP三次握手过程</li>
<li>TCP与UDP区别</li>
<li>session与cookie的区别</li>
<li>TCP发送数据包与接收数据包的过程</li>
<li>浏览器输入网址到显示页面其背后经历的过程</li>
<li>还有一些系统设计的题</li>
<li>算法：最长公共字串</li>
<li>...</li>
</ul>
<p>面试题记不清了，基本上是项目相关。</p>
<h2 id="广州-4399">广州-4399</h2>
<p>等了一会面试官才过来，看起来挺忙的😂</p>
<ol>
<li>Redis常用的数据结构，除了五种基本数据结构外还有什么数据结构？</li>
</ol>
<blockquote>
<p>string, list, hash, set, zset, HyperLogLog, GEO, bitmap</p>
</blockquote>
<ol start="2">
<li>Redis是单线程的吗？单线程是指哪个模块是单线程？为什么单线程还能保持超高性能？</li>
</ol>
<blockquote>
<p>Redis 6之前是单线程，之后是多线程；I/O模块；epoll I/O复用模型</p>
</blockquote>
<ol start="3">
<li>select, poll, epoll的区别？</li>
<li>远距离两地的MySQL数据同步，如何实现？异地多活有了解过吗？</li>
</ol>
<blockquote>
<p>没回答上来；听说过，没深入了解</p>
</blockquote>
<ol start="5">
<li>...</li>
</ol>
<p>第二面因为时间原因没参加了（HR一直让我在那等...）</p>
<h2 id="广州-爆米科技">广州-爆米科技</h2>
<ol>
<li>php-fpm是什么以及它的工作流程</li>
<li>cgi、fast-cgi的区别</li>
<li>MySQL执行一条SQL时的流程</li>
</ol>
<blockquote>
<p>大概是：权限校验-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;优化器进行优化-&gt;存储引擎查询数据</p>
</blockquote>
<ol start="4">
<li>Redis通过键批量获取值时，如果数据比较多会导致性能下降，如何解决？</li>
</ol>
<blockquote>
<p>将需要获取的键进行分片，依次获取</p>
</blockquote>
<ol start="5">
<li>PHP中对数组进行分片的函数</li>
</ol>
<blockquote>
<p>array_chunk</p>
</blockquote>
<ol start="6">
<li>...</li>
</ol>
<p>听面试官说，好像是转转的技术团队二次创业。比较满意的一家，可惜后面打算去深圳了，只能放弃了。</p>
<h2 id="广州-网易游戏">广州-网易游戏</h2>
<ol>
<li>Redis删除一个大数据键值时，有没有什么问题？</li>
<li>需要从三个物品A, B, C中随机取出一个，如何用一枚硬币做到等概率取？</li>
</ol>
<blockquote>
<p>最简单的就是抛两次，会有四种可能，取其中三种跟三个物品一一对应，如果是第四种就重新抛。</p>
</blockquote>
<ol start="3">
<li>接口性能比较差，如何排查？</li>
<li>让你实现一个连接池，如何实现？</li>
<li>OAuth 2.0安全问题</li>
<li>面了挺久的，问得比较深，只记得一点了...</li>
</ol>
<blockquote>
<p>后来到深圳也面了不少，但是很多都记不起来了，后续有想起来再更新吧。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL的json、jsonb、数组]]></title>
        <id>/post/kYHKCQzOh/</id>
        <link href="/post/kYHKCQzOh/">
        </link>
        <updated>2021-06-14T13:09:40.000Z</updated>
        <summary type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
<!-- more -->
<blockquote>
<p>PostgreSQL中单引号用于表示字符串值，双引号用于表示系统标识符，没有反引号`。</p>
</blockquote>
<h2 id="json-jsonb">JSON、JSONB</h2>
<h3 id="json和jsonb的异同"><code>json</code>和<code>jsonb</code>的异同</h3>
<p>在PostgreSQL中，<code>json</code>和<code>jsonb</code>都是用来存储<code>json</code>数据的。</p>
<p>使用<code>json</code>类型时，PostgreSQL会将输入的<code>json</code>文本存储起来，包括其中的空格以及键的顺序，在查询使用时才去解析。而<code>jsonb</code>类型会将输入的<code>json</code>文本解析为对应的二进制数据进行存储。<code>jsonb</code>类型相较<code>json</code>类型而言更高效，性能更好，且支持建立索引。</p>
<h3 id="json及jsonb的相关sql操作"><code>json</code>及<code>jsonb</code>的相关SQL操作</h3>
<h4 id="表的创建">表的创建</h4>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test (
    id int not null primary key,
    attr_json json not null,
    attr_jsonb jsonb not null
);
</code></pre>
<h4 id="数据插入">数据插入</h4>
<pre><code class="language-sql">INSERT INTO test (id, attr_json, attr_jsonb)
VALUES (1, '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}', '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}'),
       (2, '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}'),
       (3, '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}'),
       (4, '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}', '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}');
</code></pre>
<p>插入后的结果：</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1623679477303.png" alt="插入结果" loading="lazy"></figure>
<p>可见<code>jsonb</code>会对数据进行解析后，再进行存储，<code>json</code>则存储原输入。</p>
<h4 id="数据查询">数据查询</h4>
<pre><code class="language-sql">-- -&gt; 获取对象的属性，结果作为json对象；-&gt;&gt;获取对象的属性，结果作为文本
select attr_json-&gt;'son'-&gt;'age' as son_age, attr_json-&gt;&gt;'son' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="2"><img src="/post-images/1623680145772.png" alt="结果1" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- #&gt; 根据路径获取结果作为json对象；#&gt;&gt; 根据路径获取结果作为文本(json, jsonb结果一致)
select attr_json#&gt;'{son}'-&gt;'age' as son_age, attr_json#&gt;'{son,age}' as son_age2, attr_json#&gt;&gt;'{son}' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="3"><img src="/post-images/1623680312500.png" alt="结果2" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- @&gt;左边是否包含右边；&lt;@右边是否包含左边 (jsonb可用)
select * from test where attr_jsonb@&gt;'{&quot;age&quot;:18}';
</code></pre>
<figure data-type="image" tabindex="4"><img src="/post-images/1623680487862.png" alt="结果3" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ? 是否存在属性
select * from test where attr_jsonb ? 'name';
</code></pre>
<hr>
<pre><code class="language-sql">-- ?| 存在数组中任意一个属性则为true (jsonb可用)
select * from test where attr_jsonb ?| array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="5"><img src="/post-images/1623680779281.png" alt="结果4" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ?&amp; 同时存在数组中的所有属性则为true (jsonb可用)
select * from test where attr_jsonb ?&amp; array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="6"><img src="/post-images/1623680893730.png" alt="结果5" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ::为类型转换
select * from test where (attr_json-&gt;&gt;'age')::int&gt;20;
</code></pre>
<figure data-type="image" tabindex="7"><img src="/post-images/1623681132425.png" alt="结果6" loading="lazy"></figure>
<h4 id="数据更新">数据更新</h4>
<pre><code class="language-sql">-- jsonb_set(jsonb old_jsonb, text[] path, jsonb new_jsonb, bool create_if_missing) 更新jsonb 
update test set attr_jsonb=jsonb_set(attr_jsonb, '{son}', '{&quot;name&quot;:&quot;con&quot;,&quot;age&quot;:2}')
where (attr_jsonb#&gt;&gt;'{son,name}') = 'coco';
</code></pre>
<hr>
<pre><code class="language-sql">-- 根据路径删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb#-'{son,name}';
</code></pre>
<hr>
<pre><code class="language-sql">-- 删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb-'son' where attr_jsonb ? 'son';
</code></pre>
<h2 id="数组">数组</h2>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test_arr (
    id int not null primary key,
    arr int[] not null
);

-- 插入数据
insert into test_arr (id, arr) values (1, array[2,3,4]),(2, array[3,4,5]);

-- 数组合并
select array[1,2,3,4] || array[2,3,4,5]; -- 结果：{1,2,3,4,2,3,4,5}
select 2 || array[2,3,4,5]; -- 结果：{2,2,3,4,5}

-- 数组比较，每个元素依次比较大小
select array[1,2,3,4] &gt; array[1,2,3]; -- 结果: true
select array[1,2,3,4] &gt; array[1,2,4]; -- 结果: false

-- 数组包含关系
select array[1,2,3] @&gt; array[2,3]; -- 结果: true
select array[1,2,3] @&gt; array[2,3,4]; -- 结果: false

-- 数组是否有共同元素
select array[1,2,3] &amp;&amp; array[3,4,5]; -- 结果: true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[musicfox 2.0——golang重写版]]></title>
        <id>/post/NOO340v6g/</id>
        <link href="/post/NOO340v6g/">
        </link>
        <updated>2021-05-14T12:51:23.000Z</updated>
        <summary type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
<!-- more -->
<h2 id="存在的问题与方案">存在的问题与方案</h2>
<p>musicfox最开始是用Dart写的，工作原理大致是主进程fork一个mpg123的子进程，主进程处理UI渲染、用户交互及网络请求等，然后通过进程间管道通信，来控制mpg123子进程的音乐播放、暂停以及播放器的音量大小等。</p>
<p>这种模式下，会存在以下这些问题：</p>
<ul>
<li>依赖mpg123，需要用户手动安装mpg123</li>
<li>mpg123只能播放mp3音乐，网易云无损音质是flac格式，无法播放</li>
<li>进程间需要通过管道进行通信，Windows下不容易处理</li>
<li>Dart大多数三方包都是基于Flutter的，原生包不多</li>
<li>...</li>
</ul>
<p>为了解决这些问题，于是开始采用golang进行重写，优势主要是：</p>
<ul>
<li>golang支持更多平台的二进制编译</li>
<li>拥有丰富的第三方包，例如音频播放的<a href="https://github.com/faiface/beep">beep</a>、TUI渲染的<br>
<a href="https://github.com/charmbracelet/bubbletea">bubbletea</a>、本地数据库的<a href="https://github.com/boltdb/bolt">bolt</a>等等</li>
<li>不需要借助其他进程，所以不存在进程通信</li>
<li>支持mp3、flac、wav等格式音频文件的解码播放</li>
<li>goroutine + chan</li>
</ul>
<p>另外对我自己来说可以深入熟悉golang...</p>
<h2 id="使用go时遇到的问题">使用go时遇到的问题</h2>
<h3 id="协程泄漏">协程泄漏</h3>
<p>在使用golang过程中遇到比较严重的问题就是协程泄漏。例如下面的代码：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {
	c1 := make(chan struct{})
	for i := 0; i &lt; 10; i++ {
		go test(c1)
		fmt.Println(runtime.NumGoroutine())
	}
}

func test(c chan&lt;- struct{}) {
	c &lt;- struct{}{}
}
</code></pre>
<p>执行后会输出：</p>
<pre><code>2
3
4
5
6
7
8
9
10
11
</code></pre>
<p>可见，协程数一直在增加，这是因为没有消费者消费chan中的数据，所有子协程都阻塞在写chan的操作。</p>
<p>类似这种情况就会导致协程数不断增长，出现协程泄漏，内存占用不断上升。</p>
<h3 id="如何尽量避免协程泄漏">如何尽量避免协程泄漏</h3>
<ol>
<li>确保chan都会有相应的消费者、生产者，且生产速度和消费速度差不多</li>
<li>如果需要往chan中压数据或读数据，但又不确定是否有消费者或生产者，可以使用<code>select</code>结构避免阻塞</li>
<li>使用goroutine + chan处理，避免创建大量协程，例如：</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	// 获取data逻辑
	for _, v := range data {
		go test(v)
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(s string) {
	// 假装业务逻辑
	time.Sleep(time.Millisecond)
}
</code></pre>
<p>输出为: 101，也就是新开了100个协程，如果数据更多时，会产生更多协程。这种情况可以考虑创建固定数量的若干个协程，然后通过chan将数据投递给子协程进行处理，避免大量协程占用内存，如：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	c := make(chan string)

	for i := 0; i &lt; 5; i++ {
		go test(c)
	}

	for _, v := range data {
		c &lt;- v
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(c &lt;-chan string) {
	for _ = range c {
        // 业务逻辑
		time.Sleep(time.Millisecond)
	}
}
</code></pre>
<h3 id="协程泄漏排查">协程泄漏排查</h3>
<ol>
<li>runtime.NumGoroutine()查看协程数</li>
<li>使用gops排查，可以查看当前协程数、调用栈等</li>
</ol>
<h2 id="预览">预览</h2>
<figure data-type="image" tabindex="1"><img src="/post-images/1620999111458.png" alt="preview1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1620999246727.png" alt="preview2" loading="lazy"></figure>
<h2 id="安装">安装</h2>
<h3 id="mac">Mac</h3>
<p>提供两种方式安装：</p>
<h4 id="使用brew安装">使用brew安装</h4>
<pre><code class="language-sh">brew tap anhoder/go-musicfox &amp;&amp; brew install go-musicfox
</code></pre>
<p>如果你之前安装过musicfox，需要使用下列命令重新链接:</p>
<pre><code class="language-sh">brew unlink musicfox &amp;&amp; brew link --overwrite go-musicfox
</code></pre>
<h4 id="直接下载">直接下载</h4>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.mac">Mac可执行文件</a>，在iTerm或Terminal中打开</p>
<h3 id="linux">Linux</h3>
<p>身边没有Linux设备，而播放音乐依赖CGO，无法进行交叉编译，所以暂时没有可用的二进制文件</p>
<h3 id="windows">Windows</h3>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.exe">Windows可执行文件</a>，在命令行中运行即可。</p>
<p><strong>推荐使用Windows Terminal，UI及体验会好很多</strong></p>
<h2 id="快捷键">快捷键</h2>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td></td>
</tr>
<tr>
<td>r/R</td>
<td>重新渲染UI</td>
<td>Windows调整窗口大小后，没有事件触发，可以使用该方法手动重新渲染</td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="todo">TODO</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3141476"><label class="task-list-item-label" for="task-item-3141476"> 我的歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9719898"><label class="task-list-item-label" for="task-item-9719898"> 每日推荐歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2515555"><label class="task-list-item-label" for="task-item-2515555"> 每日推荐歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6510561"><label class="task-list-item-label" for="task-item-6510561"> 私人FM</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9899693"><label class="task-list-item-label" for="task-item-9899693"> 歌词显示</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8936173"><label class="task-list-item-label" for="task-item-8936173"> 欢迎界面</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3313857"><label class="task-list-item-label" for="task-item-3313857"> 搜索</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2341499"><label class="task-list-item-label" for="task-item-2341499"> 按歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6017305"><label class="task-list-item-label" for="task-item-6017305"> 按歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7682172"><label class="task-list-item-label" for="task-item-7682172"> 按歌词</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2482619"><label class="task-list-item-label" for="task-item-2482619"> 按歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8839457"><label class="task-list-item-label" for="task-item-8839457"> 按专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1051938"><label class="task-list-item-label" for="task-item-1051938"> 按用户</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4433164"><label class="task-list-item-label" for="task-item-4433164"> 排行榜</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5699988"><label class="task-list-item-label" for="task-item-5699988"> 精选歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1126561"><label class="task-list-item-label" for="task-item-1126561"> 最新专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-7066669"><label class="task-list-item-label" for="task-item-7066669"> 热门歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5482542"><label class="task-list-item-label" for="task-item-5482542"> 云盘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4874388"><label class="task-list-item-label" for="task-item-4874388"> 播放方式切换</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3275346"><label class="task-list-item-label" for="task-item-3275346"> 喜欢/取消喜欢</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3975617"><label class="task-list-item-label" for="task-item-3975617"> 心动模式/智能模式</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8170776"><label class="task-list-item-label" for="task-item-8170776"> 音乐电台</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4239830"><label class="task-list-item-label" for="task-item-4239830"> 配置文件</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6055436"><label class="task-list-item-label" for="task-item-6055436"> 通知功能</label></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个utools插件——hasids加解密]]></title>
        <id>/post/YMhNrwxuT/</id>
        <link href="/post/YMhNrwxuT/">
        </link>
        <updated>2021-03-22T12:07:53.000Z</updated>
        <summary type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
<!-- more -->
<p>utools是什么就不多说了，这里主要说一下<code>hashids</code>插件的使用。</p>
<blockquote>
<p>GitHub地址: <a href="https://github.com/anhoder/utools-hashids">https://github.com/anhoder/utools-hashids</a></p>
</blockquote>
<h2 id="添加hashids配置">添加hashids配置</h2>
<p>hashids加解密需要配置salt及最小长度，可以使用以下关键字进去添加配置的步骤:</p>
<ul>
<li>hadd</li>
<li>hash-add</li>
<li>hash添加配置</li>
</ul>
<figure data-type="image" tabindex="1"><img src="/post-images/1617624599510.png" alt="添加配置" loading="lazy"></figure>
<p>进入之后，依次输入<code>名称</code>-<code>salt</code>-<code>最小长度</code>即可保存配置。</p>
<blockquote>
<p>如果有多个环境配置，多次添加即可，<strong>名称不可重复</strong>。</p>
</blockquote>
<h2 id="hashids加密">hashids加密</h2>
<p>hashids加密有两种方式进入，一种是使用关键字：</p>
<ul>
<li>haen</li>
<li>hash-encode</li>
<li>hash编码</li>
</ul>
<p>进入之后，输入你想要加密的ID，列表中会显示你已有配置的加密结果，回车即可复制，如：</p>
<figure data-type="image" tabindex="2"><img src="/post-images/1617626324547.png" alt="hashids加密" loading="lazy"></figure>
<p>另外一种方法是直接在<code>utools</code>的主输入框内输入需要加密的ID，选择<code>hash编码</code>进入，回车即可复制。</p>
<blockquote>
<ol>
<li>如果你开启了utools的右键超级面板，就更方便了，只需要长按右键你的ID，选择<code>hash编码</code>即可。</li>
<li>如果你需要删除配置，在进入之后使用<code>control</code>+<code>enter</code>或<code>command</code>+<code>enter</code>即可删除选中的配置项。</li>
</ol>
</blockquote>
<h2 id="hashids解密">hashids解密</h2>
<p>解密和加密差不多，就不赘述了，关键字：</p>
<ul>
<li>hade</li>
<li>hash-decode</li>
<li>hash解码</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP中一些好用的技巧]]></title>
        <id>/post/O933qcq8E/</id>
        <link href="/post/O933qcq8E/">
        </link>
        <updated>2021-02-28T12:06:47.000Z</updated>
        <summary type="html"><![CDATA[<p>这里主要介绍一些我知道的PHP的使用技巧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里主要介绍一些我知道的PHP的使用技巧。</p>
<!-- more -->
<h2 id="1-php内置的web-server">1、PHP内置的Web Server</h2>
<p>首先，有个问题：</p>
<blockquote>
<p>如果你需要快速启动一个HTTP服务来调试PHP代码，你会怎么做？</p>
</blockquote>
<p><em>启动php-fpm或php-cgi进程监听9000端口，然后使用Nginx将Http请求通过FastCGI接口转发给php-fpm或php-cgi进程？</em></p>
<p>这不失为一种方法，但是并不算方便。</p>
<p>其实，PHP 5.4.0后就提供了一个内置的Web服务器，你可以执行这个命令来启动它:</p>
<pre><code class="language-sh">php -S 127.0.0.1:8080 a.php
</code></pre>
<p>然后就通过 http://127.0.0.1:8080 来进行访问了。</p>
<h2 id="2-执行php代码时生成debug信息">2、执行PHP代码时生成debug信息</h2>
<blockquote>
<p>在执行PHP代码时，你会用什么方法进行调试？</p>
</blockquote>
<p><em>var_dump、print_r直接输出？</em></p>
<p>除了直接输出，你还可以使用debug模式配合IDE来进行调试。在执行PHP代码时，加上<code>-e</code>参数，同时IDE开启debug监听（需要安装xdebug或yasd等调试类扩展，推荐yasd，它可以调试swoole协程）:</p>
<pre><code class="language-sh">php -e a.php

php -e artisan test:test
</code></pre>
<p>这样你就可以使用IDE的debug功能来调试你的PHP命令了。除此之外，还可以配合PHP的内置Web服务器一起使用：</p>
<pre><code class="language-sh">php -e -S 127.0.0.1:8080 a.php
</code></pre>
<h2 id="3-数组迭代">3、数组迭代</h2>
<blockquote>
<p>需要获取这个数组所有层级的子元素，你会怎么做？</p>
<pre><code class="language-php">$arr = [
  'key1' =&gt; 'value1',
  'key2' =&gt; [
      'key3' =&gt; 'value2',
      'key4' =&gt; [
          'value3',
          'value4',
      ]
  ],
  'key5' =&gt; 'value5'
];
</code></pre>
</blockquote>
<p><em>使用递归？</em></p>
<p>没错，可以使用递归。你也可以选择另外一种方式：</p>
<pre><code class="language-php">$arr = [
    'key1' =&gt; 'value1',
    'key2' =&gt; [
        'key3' =&gt; 'value2',
        'key4' =&gt; [
            'value3',
            'value4',
        ]
    ],
    'key5' =&gt; 'value5'
];

$it = new RecursiveArrayIterator($arr);
$recursiveIt = new RecursiveIteratorIterator($it);
foreach ($recursiveIt as $v) {
    var_dump($v);
}
</code></pre>
<h2 id="4-目录迭代">4、目录迭代</h2>
<blockquote>
<p>需要获取一个目录下所有层级的所有文件，你会怎么做？</p>
</blockquote>
<p><em>这样使用dir迭代？</em></p>
<pre><code class="language-php">function test($dir) {
    $dirHandle = dir($dir);
    while ($item = $dirHandle-&gt;read()) {
        if ($item == '.' || $item == '..') continue;
        $path = &quot;{$dir}/{$item}&quot;;
        if (is_dir($path)) {
            test($path);
        } else {
            var_dump($item);
        }
    }
}
</code></pre>
<p>你还可以用更简单的方法，同样也是PHP内置的迭代器:</p>
<pre><code class="language-php">$it = new RecursiveDirectoryIterator('./');
$reIt = new RecursiveIteratorIterator($it);

foreach ($reIt as $value) {
    var_dump($value);
}
</code></pre>
<h2 id="5-访问对象的私有属性">5、访问对象的私有属性</h2>
<blockquote>
<p>在使用一个库的对象时，想要访问该对象的私有属性，你会怎么做？</p>
</blockquote>
<p><em>?</em></p>
<p>可以使用<code>Closure</code>类的静态方法<code>bind</code>或非静态方法<code>bindTo</code>将函数绑定到该类的作用域下：</p>
<pre><code class="language-php">class A {
    private $name = 'The name of A';
}

$a = new A();

// 方法一
$closure = Closure::bind(function () use ($a) {
    var_dump($a-&gt;name);
}, null, A::class);

// 方法二，通过this访问
//$closure = Closure::bind(function () {
//    var_dump($this-&gt;name);
//}, $a, A::class);

$closure();
</code></pre>
<h2 id="6-fastcgi_request_finish">6、fastcgi_request_finish</h2>
<p>fastcgi_request_finish函数是PHP提供的在CGI模式下可用的方法。</p>
<p>调用此方法会将响应数据立即发送给用户，但不中断后续代码执行。例如：</p>
<pre><code class="language-php">echo 123;
echo 456;

fastcgi_finish_request(); // 此时将响应发送给用户

echo 789;

file_put_contents('a.txt', '789');
</code></pre>
<p>以上代码在CGI模式下执行，你会得到123456的响应数据，并且会生成a.txt文件，内容为789。</p>
<p>这个方法的主要用途就是跳过与响应无关的数据处理，提前返回数据给客户端，提高用户体验。</p>
<blockquote>
<p>仅在CGI模式下可用，其他模式下会报方法不存在的错误</p>
<p>Laravel中Response的send方法也是用到了这个函数</p>
</blockquote>
<h2 id="7-续">7、续...</h2>
<p><em>后续补充...</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中文手写体Excalidraw]]></title>
        <id>/post/8QqIK9WTM/</id>
        <link href="/post/8QqIK9WTM/">
        </link>
        <updated>2021-01-23T12:06:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="excalidraw">Excalidraw</h2>
<p>Excalidraw是一个开源的、用于绘制手绘风格草图的项目，GitHub地址为<a href="https://github.com/excalidraw/excalidraw">https://github.com/excalidraw/excalidraw</a>，用它制作的草图效果如下：</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1617677708342.png" alt="草图" loading="lazy"></figure>
<p>看起来还不错，但是由于这个项目诞生于国外，所以并不支持中文字体：</p>
<figure data-type="image" tabindex="2"><img src="/post-images/1617677730364.png" alt="草图2" loading="lazy"></figure>
<p>几个汉字可以说是格格不入了😂。</p>
<h2 id="替换字体">替换字体</h2>
<p>于是，我找了一些免费的手写字体尝试替换进去，最后找到一个效果还不错的——沐瑶随心手写体。</p>
<figure data-type="image" tabindex="3"><img src="/post-images/1617677746929.png" alt="草图3" loading="lazy"></figure>
<p>沐瑶随心手写体是完全免费，即使是商用。</p>
<blockquote>
<p>沐瑶是作者女儿的名字 WoW<br>
字体下载地址: <a href="https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html">https://www.zcool.com.cn/work/ZMjg5MjAwMDQ=.html</a></p>
</blockquote>
<h2 id="使用">使用</h2>
<p>如果你想要使用的话，可以访问: <a href="https://danlanhai.gitee.io/excalidraw/">https://danlanhai.gitee.io/excalidraw/</a>或<a href="https://anhoder.github.io/excalidraw/">https://anhoder.github.io/excalidraw/</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自己写个包——PHP8 Attribute收集器]]></title>
        <id>/post/dm-3SDHLz/</id>
        <link href="/post/dm-3SDHLz/">
        </link>
        <updated>2021-01-17T12:05:04.000Z</updated>
        <summary type="html"><![CDATA[<p>PHP8发布已经有一段时间了，新增了不少特性，其中我觉得比较好用的：一个是函数可以指定参数名传参，另外一个就是<strong>注解Attribute</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>PHP8发布已经有一段时间了，新增了不少特性，其中我觉得比较好用的：一个是函数可以指定参数名传参，另外一个就是<strong>注解Attribute</strong>。</p>
<!-- more -->
<h2 id="注解">注解</h2>
<p>在PHP8之前，PHP语法上是不支持注解的，只能通过反射来获取类、方法或属性的注释，然后通过解析注释来获取需要的元数据。最具代表性的就是注解包<a href="https://github.com/doctrine/annotations">doctrine/annotations</a>，很多框架都有在用。</p>
<p>使用方法：</p>
<pre><code class="language-php">use Doctrine\Common\Annotations\Annotation\Attribute;
use Doctrine\Common\Annotations\Annotation\Attributes;
use Doctrine\Common\Annotations\Annotation\Target;

/**
 * @Annotation
 * @Target(&quot;CLASS&quot;)
 * @Attributes({
 *     @Attribute(&quot;name&quot;, type=&quot;string&quot;, required=true),
 *     @Attribute(&quot;age&quot;, type=&quot;int&quot;)
 * })
 */
class Student
{
    /**
     * @var string
     */
    private $name;
    
    /**
     * @var int
     */
    private $age
}

/**
 * @Student(name=&quot;anhoder&quot;, age=18)
 */
class Anhoder
{
    
}
</code></pre>
<p>而在PHP8中，注解Attribute是这样的：</p>
<pre><code class="language-php">#[Attribute(Attribute::TARGET_CLASS)]
class Student
{
    public function __construct(private string $name, private int $age)
    {
    }
}

#[Student('anhoder', 18)]
class Anhoder
{

}
</code></pre>
<h2 id="收集注解attribute">收集注解Attribute</h2>
<p>PHP8的Attribute数据也需要通过反射来手动获取：</p>
<pre><code class="language-php">$reflection = new ReflectionClass(Anhoder::class);
var_dump($reflection-&gt;getAttributes());
// array(1) {
//   [0]=&gt;
//   object(ReflectionAttribute)#3 (0) {
//   }
// }
</code></pre>
<p>我们可以实现一个Attribute收集器，用于自动收集项目中或其他composer包中的注解信息。</p>
<h3 id="1-获取所有包的根目录及namespace">1. 获取所有包的根目录及namespace</h3>
<p>通过composer提供的ClassLoader自动加载类，我们获取到所有包的命名空间及对应的根目录：</p>
<pre><code class="language-php">// 获取Composer的自动加载类
function getComposerLoader()
{
    $loaders = spl_autoload_functions();

    foreach ($loaders as $loader) {
        if (is_array($loader) &amp;&amp; isset($loader[0]) &amp;&amp; $loader[0] instanceof ClassLoader) {
            return $loader[0];
        }
    }
    
    throw new NotFoundException('Composer class loader');
}

$composerLoader = getComposerLoader();

// 获取命令空间及目录
$composerLoader-&gt;getPrefixesPsr4();
</code></pre>
<h3 id="2-加载每个包下的annotationconfig类">2. 加载每个包下的AnnotationConfig类</h3>
<p>我们约定：在每个需要收集注解的包下，都放一个AnnotationConfig类，并实现AnnotationConfigInterface接口。用于获取该包下需要扫描的目录及命名空间。例如：</p>
<pre><code class="language-php">class AnnotationConfig implements AnnotationConfigInterface
{

    /**
     * @inheritDoc
     */
    public static function getAnnotationConfigs(): array
    {

        return [
            'scanDirs' =&gt; [
                __NAMESPACE__ =&gt; __DIR__,
            ],
        ];
    }
}
</code></pre>
<p>在以上约定条件下，我们需要遍历第一步获取到的根目录，判断其目录下是否有AnnotationConfig类，若有则调用getAnnotationConfigs方法获取其配置。</p>
<h3 id="3-解析-收集注解">3. 解析、收集注解</h3>
<p>最后一步，就是遍历每个目录下的文件及其对应的类，然后通过反射获取到类、方法、属性及常量的注解信息，并将这些信息存入容器数组中。</p>
<pre><code class="language-php">$namespace = rtrim($namespace, '\\');
$iterator = new RecursiveDirectoryIterator($dir);

foreach ($iterator as $splFileInfo) {
    $basename = $splFileInfo-&gt;getBasename();
    
    if (!$splFileInfo-&gt;isFile() || $splFileInfo-&gt;getExtension() != 'php') {
        // not php file
        continue;
    }

    // PHP File
    $className = $splFileInfo-&gt;getBasename('.' . $splFileInfo-&gt;getExtension());
    $class = &quot;{$namespace}\\{$className}&quot;;
    if (class_exists($class)) {
        $reflection = new ReflectionClass($class);
        $attributes = $reflection-&gt;getAttributes();
    }
}
</code></pre>
<h2 id="封装为composer包">封装为composer包</h2>
<p>以上代码都是简单的示例，实际还需要考虑更多，所以我将其做成了一个composer包——<a href="https://github.com/anhoder/annotations-collector">anhoder/annotations-collector</a>。简单的使用：</p>
<ol>
<li>
<p>安装</p>
<pre><code class="language-sh">composer require anhoder/annotations-collector
</code></pre>
</li>
<li>
<p>创建 <code>AnnotationConfig.php</code> 文件到你项目的根目录</p>
<pre><code class="language-php">class AnnotationConfig implements AnnotationConfigInterface
{

    public static function getAnnotationConfigs(): array
    {
        return [
            // The dirs need to be scanned
            'scanDirs' =&gt; [
                __NAMESPACE__ =&gt; __DIR__,
            ],
        ];
    }
}
</code></pre>
</li>
<li>
<p>添加Annotation及AnnotationHandler.</p>
<pre><code class="language-php">// Annotation
#[Attribute(Attribute::TARGET_CLASS)]
class ClassAnnotation
{
    public const TEST = 'test';

    private string $test;

    public function __construct(string $test)
    {
        $this-&gt;test = $test;
    }
}

// AnnotationHandler
#[AnnotationHandler(ClassAnnotation::class)]
class ClassAnnotationHandler extends AbstractAnnotationHandler
{
    public function handle()
    {
        // Your logic.
        var_dump($this);
    }
}
</code></pre>
</li>
<li>
<p>开始扫描</p>
<pre><code class="language-php">AnnotationHelper::scan();
</code></pre>
</li>
</ol>
<h2 id="附">附</h2>
<p>由于注解需要配合反射来使用，其相比正常代码性能较差，而且在php-fpm模式下，每次请求都需要重新获取注解信息，所以<strong>不推荐在php-fpm下使用注解</strong>，其<strong>更适合一些常驻内存型的项目</strong>，例如：Swoole、WorkerMan等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swoft内存泄漏排查]]></title>
        <id>/post/e-qWPg1ij/</id>
        <link href="/post/e-qWPg1ij/">
        </link>
        <updated>2021-01-16T12:04:00.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在公司使用swoft写了一个定时爬取数据的项目，上线后跟踪线上日志发现swoft的worker进程会<strong>出现周期性的内存溢出</strong>：</p>
<pre><code class="language-txt">Fatal error: Uncaught ErrorException: Allowed memory size of 268435456 bytes exhausted (tried to allocate 262144 bytes)
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>最近在公司使用swoft写了一个定时爬取数据的项目，上线后跟踪线上日志发现swoft的worker进程会<strong>出现周期性的内存溢出</strong>：</p>
<pre><code class="language-txt">Fatal error: Uncaught ErrorException: Allowed memory size of 268435456 bytes exhausted (tried to allocate 262144 bytes)
</code></pre>
<!-- more -->
<h2 id="一-分析">一、分析</h2>
<p>观察到线上worker进程的内存占用是随时间增长而逐渐上升的，所以排除单次执行导致内存溢出的情况，基本可以确定是项目中的某处代码<strong>存在内存泄漏</strong>。</p>
<p>因此，解决问题的关键就在于<strong>如何定位到项目中产生内存泄漏的位置</strong>。</p>
<h2 id="二-定位内存泄漏">二、定位内存泄漏</h2>
<h3 id="1-swoole-tracker">1、Swoole Tracker</h3>
<p><a href="https://business.swoole.com/tracker/index">Swoole Tracker</a>是Swoole官方提供的分析工具，可以用来检测项目中的内存泄漏问题（<a href="https://mp.weixin.qq.com/s/oAyToE4aNyU3-_PQ5ii3aw">使用方法</a>）。</p>
<h4 id="安装">安装</h4>
<p>Swoole Tracker的安装比较简单，因为它本身就是一个php的扩展，而且是已经编译好的，我们只需要将编译好的动态链接库文件(.so)放到php的扩展目录下，然后在php.ini中加上配置即可。</p>
<h4 id="使用">使用</h4>
<p>安装完Swoole Tracker扩展后，在相应的代码中加入Swoole Tracker提供的Hook函数，例如：</p>
<pre><code class="language-php">public function onPipeMessage(Server $server, int $srcWorkerId, $message): void
{
    trackerHookMalloc();
    // ...
}
</code></pre>
<p>接着启动服务，运行一段时间后，在docker容器内执行<code>php -r &quot;trackerAnalyzeLeak();&quot;</code>即可获取到服务运行时的内存申请信息、内存释放信息以及可能存在内存泄漏的位置。</p>
<h4 id="检测结果">检测结果</h4>
<p><a href="/post-images/memory_leak.txt">memory_leak.txt</a></p>
<blockquote>
<p>文件中含命令行颜色代码，可以在命令行使用<code>cat memory_leak.txt</code>查看</p>
</blockquote>
<p>以下是检测结果中可能存在内存泄漏的代码位置：</p>
<pre><code class="language-txt"> The Possible Leak As Malloc Size Keep Growth:
 /var/www/swoft_marketing_engine/vendor/swoft/server/src/Server.php:544 =&gt;  Growth Times : [29];  Growth Size : [181440]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:959 =&gt;  Growth Times : [8];  Growth Size : [2784]
 /var/www/swoft_marketing_engine/vendor/swoft/stdlib/src/Helper/ArrayHelper.php:997 =&gt;  Growth Times : [12];  Growth Size : [17920]
 /var/www/swoft_marketing_engine/vendor/swoft/bean/src/Container.php:413 =&gt;  Growth Times : [24];  Growth Size : [10752]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Database.php:252 =&gt;  Growth Times : [24];  Growth Size : [1536]
 /var/www/swoft_marketing_engine/vendor/swoft/db/src/Connection/Connection.php:370 =&gt;  Growth Times : [24];  Growth Size : [4608]
</code></pre>
<p>根据结果，<strong>发现是Swoft框架本身某个位置存在内存泄漏</strong>。</p>
<p>但是，检测结果中只有产生内存申请时的代码位置，还不能确定具体是什么地方未释放内存。</p>
<p>因此，只能换一种思路。</p>
<h3 id="2-valgrind">2、Valgrind</h3>
<p>尝试另外一款内存泄漏分析神器——valgrind。</p>
<p>使用后发现分析报告中只会出现相关的C/C++代码，无法定位到具体的PHP代码位置，放弃。</p>
<h3 id="3-memory_get_usage">3、memory_get_usage()</h3>
<p>使用几种内存泄漏分析工具都无果后，尝试使用最原始的方式——PHP的内置函数<code>memory_get_usage()</code>。</p>
<p>大致思路就是在需要调用的函数上下，加上<code>memory_get_usage()</code>函数，例如：</p>
<pre><code class="language-php">var_dump(memory_get_usage());
test();
var_dump(memory_get_usage());
</code></pre>
<p>因为，正常情况下，在函数调用完成后，Zend引擎会将对应的函数栈销毁，相应的内存会被释放。</p>
<blockquote>
<p>在使用时，有一些需要注意的点：</p>
<ol>
<li><code>memory_get_usage()</code>支持一个布尔类型的参数<code>real_usage</code>，表示是否获取真实内存大小，其中包括未被使用的内存空间。因为PHP引擎在申请内存时，会一次申请一大块内存，用于后续使用，以减少系统调用的次数。所以，在这里<strong>不要将它设置为true</strong>。</li>
<li>如果函数中存在循环引用（如：Swoft中ORM的join方法），在函数执行完成后，变量并不会被及时释放，输出内存占用会增加，但是这是正常的。因为当待释放变量达到一定数量或内存达到一定阈值时，PHP的GC才会统一释放掉这些的内存。</li>
</ol>
</blockquote>
<h4 id="检查结果">检查结果</h4>
<p>这种方法虽然费时费力，但效果还算不错。经过一段时间排查，成功定位到了两处内存泄漏：</p>
<ul>
<li>在协程中使用Redis时，Swoft未在协程结束后释放相应的Redis连接信息；</li>
<li>Swoft在处理pipeMessage事件结束后未触发协程结束事件，导致协程数据（MySQL、Redis连接信息等）未被释放。</li>
</ul>
<h2 id="三-解决方案">三、解决方案</h2>
<p>既然已经定位到内存泄漏的原因了，解决办法就不难了：</p>
<ul>
<li>协程结束后，手动unset Redis的连接信息；</li>
<li>在pipeMessgae事件结束后，手动触发协程结束事件，销毁对应协程产生的数据。</li>
</ul>
<h2 id="四-后续">四、后续</h2>
<p>经过以上处理后，<strong>截至目前，线上swoft项目的内存占用稳定在50M左右，未出现内存溢出错误</strong>。</p>
<p>此外，针对这两个问题，我在GitHub上向Swoft团队提交了两个相应的issue及修复PR，目前代码已被合并到master。</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1617677953995.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1617677966544.jpg" alt="" loading="lazy"></figure>
<h2 id="五-总结">五、总结</h2>
<p>其实，内存溢出、内存泄漏的情况并不容易发生（单次运行直接爆内存的除外emmm...），只要你：</p>
<ul>
<li>不轻易使用全局变量、静态变量；</li>
<li>如果不可避免的需要使用到全局变量、静态变量，一定要在用完后unset掉相应的数据。</li>
</ul>
<blockquote>
<p>另外，在排查过程中，用到的一个挺好用的查看内存占用的工具——smem，可以查看程序的USS、PSS、RSS👍。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发中常用的函数]]></title>
        <id>/post/B6gBPbA-S/</id>
        <link href="/post/B6gBPbA-S/">
        </link>
        <updated>2020-12-13T12:03:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="php函数相关">PHP函数相关</h2>
<pre><code class="language-c">
zend_parse_parameters()     // 解析函数参数
// 例如，s表示字符串, 解析一个字符串类型的参数到name, 及其长度到name_len: 
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;name, &amp;name_len) == FAILURE) {
    RETURN_NULL();
}

/* 解析参数时的类型代码 */
b: 布尔类型（对应c类型: zend_bool）
l: 整型（long）
d: 浮点型（double）
s: 字符串（char*, int）
r: 资源型（zval*）
a: 数组（zval*）
o: 对象（zval*）
z: zval（zval*）
</code></pre>
<blockquote>
<p>附：PHP 7中使用FAST_ZPP方式解析函数参数的宏：<br>
<img src="/post-images/1617678458821.jpg" alt="" loading="lazy"></p>
</blockquote>
<h2 id="数组操作">数组操作</h2>
<pre><code class="language-c">array_init(arr)                         // 初始化数组
add_next_index_null(zval*)              // 向数字索引的数组增加null
add_next_index_long(zval*, long)        // ...添加long类型
add_next_index_bool(zval*, 0|1)         // ...添加bool类型
add_next_index_double(zval*, double)  
add_next_index_string(zval*, char*, zend_bool)
add_next_index_zval(zval*, zval*)
// ...
</code></pre>
<p>更多操作数组的函数: <a href="https://www.php.net/manual/en/internals2.variables.arrays.php">https://www.php.net/manual/en/internals2.variables.arrays.php</a></p>
<blockquote>
<p>未完待续...</p>
</blockquote>
]]></content>
    </entry>
</feed>