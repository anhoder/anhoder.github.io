<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>/</id>
    <title>anhoder的进阶日志</title>
    <updated>2021-12-25T04:18:50.308Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="/"/>
    <link rel="self" href="/atom.xml"/>
    <subtitle>一川烟草，满城风絮。</subtitle>
    <logo>/images/avatar.png</logo>
    <icon>/favicon.ico</icon>
    <rights>All rights reserved 2021, anhoder的进阶日志</rights>
    <entry>
        <title type="html"><![CDATA[编码原则]]></title>
        <id>/post/zTHYobkMn/</id>
        <link href="/post/zTHYobkMn/">
        </link>
        <updated>2021-12-25T04:12:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-换位思考">1. 换位思考</h3>
<p>维护别人的代码时，应该站在前人角度考虑为什么这么写，而不是立马抱怨这代码有多丑陋、有多垃圾，有可能你在他的情境里不一定做得更好。</p>
<p>抱怨只会浪费时间与心情，并不能让代码质量变好，我们应该把时间花在思考如何优化这些代码上。</p>
<blockquote>
<p>我们总觉得烂代码是烂程序员写的，其实写这些代码的人本身都很正常，只是所在的环境很差。</p>
</blockquote>
<h3 id="2-不要过度依赖调试器">2. 不要过度依赖调试器</h3>
<p>虽然这与我现在的做法相悖（目前我遇到bug几乎都是打开debugger，打上断点然后单步调试，因为它能更快地帮我定位到问题），但我还是觉得很有道理。</p>
<p>因为如果线上出现问题，在线上接入debugger是不太现实的，所以在调试时，我们应该确保对这些代码逻辑十分熟悉，而不仅仅只是依赖于调试器。</p>
<p>我们可以遵守<code>20分钟法则</code>，也就是说，首先应该整理自己的思路，并通过查询日志，把程序的运行流程还原出来，如果20分钟还是找不到问题所在，再借助debugger把问题找出来。</p>
<p>并且找到问题之后，我们应该思考一下<strong>为什么不依赖调试器不能直接找到问题所在，是不是日志信息不够充分</strong>。</p>
<blockquote>
<p>调试器除不掉bug，它们只能把出现bug的过程慢速播放一遍，所以我们还是得通过重构来消除bug。</p>
</blockquote>
<h3 id="3-考虑代码性能">3. 考虑代码性能</h3>
<p>编写程序时，在保证代码逻辑正确的情况下，应该充分考虑代码的性能（时间复杂度、空间复杂度等），不能仅仅依赖增加硬件配置来改善速度。</p>
<blockquote>
<p>计算机软件业最大的成就是它一直都在把计算机硬件业努力取得的进步给抵消掉。</p>
</blockquote>
<h3 id="4-尽量少的代码">4. 尽量少的代码</h3>
<p>确保代码逻辑正确的情况下，缩减代码。</p>
<ul>
<li>
<p>代码越多可能出现bug的数量就越多</p>
</li>
<li>
<p>更多的代码意味着测试时需要更多的测试用例去覆盖各个代码分支</p>
</li>
<li>
<p>代码越多相应的维护难度就越高，毕竟每个人的精力都是有限的</p>
</li>
</ul>
<blockquote>
<p>less is more</p>
</blockquote>
<h3 id="5-可读性">5. 可读性</h3>
<p>思考自己的代码水平，并保证自己的代码风格、代码质量保持在团队的平均水平，让团队大多数人能理解你的代码。更高水平的需要保证代码更通俗，较低水平的需要增强自己的代码能力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发——类]]></title>
        <id>/post/AeTXbWbCO/</id>
        <link href="/post/AeTXbWbCO/">
        </link>
        <updated>2021-08-08T10:22:10.000Z</updated>
        <content type="html"><![CDATA[<p>这篇开始在扩展中实现PHP的类，先定个目标，实现如下的PHP类：</p>
<pre><code class="language-php">&lt;?php

class Person {
    public const MALE = 1;
    public const FEMALE = 2;

    private $name;
    private $age;

    public function __construct(string $name, string $age)
    {
        $this-&gt;name = $name;
        $this-&gt;age = $age;
    }

    public function setName(string $name)
    {
        $this-&gt;name = $name;
    }

    public function getName(): string
    {
        return $this-&gt;name;
    }
}
</code></pre>
<h2 id="相关结构体-宏及函数">相关结构体、宏及函数</h2>
<ul>
<li>zend_class_entry: 类入口</li>
<li>PHP_METHOD: 声明类的方法</li>
<li>zend_update_property: 更新类的属性</li>
<li>zend_read_property: 获取类的属性</li>
<li>PHP_ME: 类方法的参数信息</li>
<li>INIT_CLASS_ENTRY: 初始化zend_class_entry</li>
<li>zend_register_internal_class: 向zend中注册类</li>
<li>zend_declare_property: 声明属性</li>
</ul>
<h2 id="实现person类">实现Person类</h2>
<h3 id="1-声明类入口-实现类方法">1. 声明类入口、实现类方法</h3>
<pre><code class="language-c">// 类入口
zend_class_entry *person_ce;


// __construct(string name, int age)
PHP_METHOD(Person, __construct)
{
    zend_string *name;
    zend_long age;

    ZEND_PARSE_PARAMETERS_START(2, 2)
        Z_PARAM_STR(name)
        Z_PARAM_LONG(age)
    ZEND_PARSE_PARAMETERS_END();

    // 更新属性
    zend_update_property_str(person_ce, getThis(), &quot;name&quot;, sizeof(&quot;name&quot;)-1, name);
    zend_update_property_long(person_ce, getThis(), &quot;age&quot;, sizeof(&quot;age&quot;)-1, age);

    zend_string_release(name);
}

// getName(): string
PHP_METHOD(Person, getName)
{
    zval rv, *name;

    name = zend_read_property(person_ce, getThis(), &quot;name&quot;, sizeof(&quot;name&quot;)-1, 0, &amp;rv);

    RETURN_STR(Z_STR_P(name))
}

// setName(string name)
PHP_METHOD(Person, setName)
{
    zend_string *name;

    ZEND_PARSE_PARAMETERS_START(1, 1)
        Z_PARAM_STR(name)
    ZEND_PARSE_PARAMETERS_END();

    zend_update_property_str(person_ce, getThis(), &quot;name&quot;, sizeof(&quot;name&quot;)-1, name);

    zend_string_release(name);
}
</code></pre>
<h3 id="2-方法参数信息">2. 方法参数信息</h3>
<pre><code class="language-c">ZEND_BEGIN_ARG_INFO(arginfo_person_construct, 0)
    ZEND_ARG_TYPE_INFO(0, name, IS_STRING, 0)
    ZEND_ARG_TYPE_INFO(0, age, IS_LONG, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_person_setname, 0)
    ZEND_ARG_TYPE_INFO(0, name, IS_STRING, 0)
ZEND_END_ARG_INFO()
</code></pre>
<h3 id="3-方法入口">3. 方法入口</h3>
<p>与普通函数一样，都是使用<code>zend_function_entry</code>结构体作为入口，不同的只是把宏换成了<code>PHP_ME</code>。</p>
<pre><code class="language-c">zend_function_entry person_methods[] = {
    // ZEND_ACC_PUBLIC, 方法访问权限都为public
    PHP_ME(Person, __construct, arginfo_person_construct, ZEND_ACC_PUBLIC)
    PHP_ME(Person, getName, NULL, ZEND_ACC_PUBLIC)
    PHP_ME(Person, setName, arginfo_person_setname, ZEND_ACC_PUBLIC)

    PHP_FE_END
};
</code></pre>
<h3 id="4-向zend注册类">4. 向Zend注册类</h3>
<p>最后在扩展初始化的Hook中，将类注册到Zend中。</p>
<pre><code class="language-c">PHP_MINIT_FUNCTION(ext_test)
{
    // 初始化zend_class_entry，将方法绑定到类中
    zend_class_entry ce;
    INIT_CLASS_ENTRY(ce, &quot;Person&quot;, person_methods)

    // 注册类
    person_ce = zend_register_internal_class(&amp;ce);

    // 声明类常量
    zend_declare_class_constant_long(person_ce, &quot;MALE&quot;, sizeof(&quot;MALE&quot;)-1, 1);
    zend_declare_class_constant_long(person_ce, &quot;FEMALE&quot;, sizeof(&quot;FEMALE&quot;)-1, 2);

    // 声明类的属性及访问权限
    zend_declare_property_null(person_ce, &quot;name&quot;, sizeof(&quot;name&quot;)-1, ZEND_ACC_PRIVATE);
    zend_declare_property_null(person_ce, &quot;age&quot;, sizeof(&quot;age&quot;)-1, ZEND_ACC_PRIVATE);
}
</code></pre>
<p>至此，类的实现基本完成，大致步骤为：</p>
<ol>
<li>声明类入口</li>
<li>实现相关的方法</li>
<li>声明方法参数信息</li>
<li>声明方法入口</li>
<li>在扩展初始化的Hook中注册到Zend中</li>
</ol>
<h2 id="测试php代码">测试PHP代码</h2>
<pre><code class="language-php">&lt;?php

$person = new Person('anhoder', 18);
var_dump($person-&gt;getName());
$person-&gt;setName('alan');
var_dump($person);
</code></pre>
<p>输出代码：</p>
<pre><code>string(7) &quot;anhoder&quot;
object(Person)#1 (2) {
  [&quot;name&quot;:&quot;Person&quot;:private]=&gt;
  string(4) &quot;alan&quot;
  [&quot;age&quot;:&quot;Person&quot;:private]=&gt;
  int(18)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发——函数]]></title>
        <id>/post/yBxcxmgZ6/</id>
        <link href="/post/yBxcxmgZ6/">
        </link>
        <updated>2021-08-01T11:38:46.000Z</updated>
        <content type="html"><![CDATA[<p>这里了解一下扩展开发中PHP函数是如何实现的，包括参数解析、返回结果等。</p>
<h2 id="0-函数相关宏">0. 函数相关宏</h2>
<p>开始之前，先了解一下PHP中一些与函数相关的结构或宏。</p>
<h3 id="函数定义php_functionname">函数定义：<code>PHP_FUNCTION(name)</code></h3>
<p><code>PHP_FUNCTION</code>是一个用于定义PHP函数头的宏，使用方法：</p>
<pre><code class="language-c">PHP_FUNCTION(func_name)
{
    // 函数体
}
</code></pre>
<blockquote>
<p>这里顺便讲一下<code>PHP_FUNCTION</code>, <code>ZEND_FUNCTION</code>, <code>PHP_METHOD</code>, <code>ZEND_METHOD</code>的关系。</p>
<ul>
<li><code>PHP_FUNCTION</code>用于定义PHP函数，<code>PHP_METHOD</code>用于定义类的方法。</li>
<li><code>ZEND_FUNCTION</code>与<code>PHP_FUNCTION</code>是等效的，<code>PHP_FUNCTION</code>只是<code>ZEND_FUNCTION</code>的别名，<code>PHP_METHOD</code>与<code>ZEND_METHOD</code>也是这样的关系。</li>
</ul>
</blockquote>
<h3 id="函数参数zend_begin_arg_infoname-_unused-zend_end_arg_info-zend_arg_infopass_by_ref-name">函数参数：<code>ZEND_BEGIN_ARG_INFO(name, _unused)</code>、<code>ZEND_END_ARG_INFO()</code>、<code>ZEND_ARG_INFO(pass_by_ref, name)</code></h3>
<p><code>ZEND_BEGIN_ARG_INFO</code>与<code>ZEND_END_ARG_INFO</code>是配对使用的，用于声明参数组，它们的宏展开为：</p>
<pre><code class="language-c">// ZEND_BEGIN_ARG_INFO(name, _unused)展开（_unused其实没有被使用到）
static const zend_internal_arg_info name[] = { \
		{ (const char*)(zend_uintptr_t)(required_num_args), 0, return_reference, 0 },

// ZEND_END_ARG_INFO()展开
};
</code></pre>
<p>可以看到，它们在一起实际是声明了一个zend_internal_arg_info数组，用于存储一系列参数信息。</p>
<p>而<code>ZEND_ARG_INFO</code>则是在<code>ZEND_BEGIN_ARG_INFO</code>与<code>ZEND_END_ARG_INFO</code>之间，用于初始化一个zend_internal_arg_info，定义某个具体的参数，它的宏定义为：</p>
<pre><code class="language-c">#define ZEND_ARG_INFO(pass_by_ref, name)    { #name, 0, pass_by_ref, 0},
</code></pre>
<blockquote>
<p>ZEND_ARG_INFO用于声明普通参数，复杂参数需要使用另外的宏：</p>
<ul>
<li>ZEND_ARG_OBJ_INFO —— 对象</li>
<li>ZEND_ARG_ARRAY_INFO —— 数组<br>
...</li>
</ul>
</blockquote>
<h3 id="函数入口zend_function_entry结构体-php_fename-arg_info">函数入口：<code>zend_function_entry</code>结构体、<code>PHP_FE(name, arg_info)</code></h3>
<p><code>zend_function_entry</code>是用于向Zend引擎中注册函数的载体，每个需要提供给PHP的函数都对应一个<code>zend_function_entry</code>。</p>
<p>使用：</p>
<pre><code class="language-c">// 这是一段ext_sket脚手架生成的代码
// zend_function_entry数组
static const zend_function_entry ext_test_functions[] = {
    // 函数
    PHP_FE(ext_test_test1,		arginfo_ext_test_test1)
	PHP_FE_END
};

zend_module_entry ext_test_module_entry = {
	STANDARD_MODULE_HEADER,
	&quot;ext_test&quot;,					/* Extension name */
	ext_test_functions,			// 向Zend引擎中注册一系列函数
	NULL,							/* PHP_MINIT - Module initialization */
	NULL,							/* PHP_MSHUTDOWN - Module shutdown */
	PHP_RINIT(ext_test),			/* PHP_RINIT - Request initialization */
	NULL,							/* PHP_RSHUTDOWN - Request shutdown */
	PHP_MINFO(ext_test),			/* PHP_MINFO - Module info */
	PHP_EXT_TEST_VERSION,		/* Version */
	STANDARD_MODULE_PROPERTIES
};
</code></pre>
<p><code>PHP_FE</code>就是用于初始化一个<code>zend_function_entry</code>结构体的。需要传入两个参数：函数名及参数信息zend_internal_arg_info[]。</p>
<h3 id="参数解析zend_parse_parameters_none-zend_parse_parameters_startmin_num_args-max_num_args-zend_parse_parameters_end-z_param_optional-z_param_">参数解析：<code>ZEND_PARSE_PARAMETERS_NONE()</code>、<code>ZEND_PARSE_PARAMETERS_START(min_num_args, max_num_args)</code>、<code>ZEND_PARSE_PARAMETERS_END()</code>、<code>Z_PARAM_OPTIONAL</code>、<code>Z_PARAM_*</code></h3>
<p>这一类宏用在函数体内，即<code>PHP_FUNCTION</code>中。</p>
<ul>
<li><code>ZEND_PARSE_PARAMETERS_NONE()</code>: 无需要参数</li>
<li><code>ZEND_PARSE_PARAMETERS_START(min_num_args, max_num_args)</code>: 开始参数解析，min_num_args最少参数数量，max_num_args最大参数数量</li>
<li><code>ZEND_PARSE_PARAMETERS_END()</code>: 结束参数解析，与<code>ZEND_PARSE_PARAMETERS_START</code>成对使用</li>
<li><code>Z_PARAM_OPTIONAL</code>: 表示参数可选</li>
<li><code>Z_PARAM_*</code>: 具体参数</li>
</ul>
<p>使用方法：</p>
<pre><code class="language-c">// 无参数函数
PHP_FUNCITON(test_func)
{
    ZEND_PARSE_PARAMETERS_NONE();
    zend_printf(&quot;test&quot;); // zend_printf与php_printf等效，PHP在启动时会将php_printf赋值给zend_printf指针
}

PHP_FUNCTION(test_func2)
{
    ZEND_PARSE_PARAMETERS_START(1, 2)
        Z_PARAM_S
        Z_PARAM_OPTIONAL()
    ZEND_PARSE_PARAMETERS_END();
}
</code></pre>
<h2 id="1-无参无返回值函数">1. 无参无返回值函数</h2>
<pre><code class="language-c">// ...

// test_func1(): void
PHP_FUNCTION(test_func1)
{
	ZEND_PARSE_PARAMETERS_NONE();

	php_printf(&quot;Hello world!&quot;);
}

// ...

ZEND_BEGIN_ARG_INFO(arginfo_test_func1, 0)
ZEND_END_ARG_INFO()

static const zend_function_entry ext_test_functions[] = {
    PHP_FE(test_func1,		arginfo_test_func1)
	PHP_FE_END
};

// ...
</code></pre>
<pre><code class="language-php">test_func1(); // 输出Hello world!
</code></pre>
<h2 id="2-带固定类型参数且有返回值的函数">2. 带固定类型参数，且有返回值的函数</h2>
<pre><code class="language-c">// test_func2(int id, string name=&quot;anhoder&quot;): string
PHP_FUNCTION(test_func2)
{
    zend_long id;
    zend_string *name, *res;
    name = zend_string_init(&quot;anhoder&quot;, strlen(&quot;anhoder&quot;), 0);

    ZEND_PARSE_PARAMETERS_START(1, 2)
        Z_PARAM_LONG(id)
        Z_PARAM_OPTIONAL
        Z_PARAM_STR(name)
    ZEND_PARSE_PARAMETERS_END();

    res = zend_strpprintf(0, &quot;%lld: %s\n&quot;, id, ZSTR_VAL(name));

    RETVAL_STR(res);

    zend_string_release(name);
    zend_string_release(res);
}

// ...

ZEND_BEGIN_ARG_INFO(arginfo_test_func2, 0)
	ZEND_ARG_TYPE_INFO(0, id, IS_LONG, 0)
    ZEND_ARG_TYPE_INFO(0, name, IS_STRING, 0)
ZEND_END_ARG_INFO()

static const zend_function_entry ext_test_functions[] = {
    PHP_FE(test_func2,		arginfo_test_func2)
	PHP_FE_END
};

// ...
</code></pre>
<h2 id="3-参数传引用的函数">3. 参数传引用的函数</h2>
<pre><code class="language-c">// test_func3(array &amp;$arr): void
PHP_FUNCTION(test_func3)
{
    zval *arr;

    ZEND_PARSE_PARAMETERS_START(1, 1)
        Z_PARAM_ARRAY_EX2(arr, 0, 1, 0)
    ZEND_PARSE_PARAMETERS_END();

    add_assoc_long(arr, &quot;key&quot;, 123);
    add_index_string(arr, 4, &quot;name&quot;);
}

ZEND_BEGIN_ARG_INFO(arginfo_test_func3, 0)
    ZEND_ARG_TYPE_INFO(1, arr, IS_ARRAY, 0)
ZEND_END_ARG_INFO()

static const zend_function_entry ext_test_functions[] = {
    PHP_FE(test_func3,		arginfo_test_func3)
	PHP_FE_END
};
</code></pre>
<h2 id="4-参数传对象-callable的函数">4. 参数传对象、callable的函数</h2>
<pre><code class="language-c">// mixed test_func4(callable, ...args)
PHP_FUNCTION(test_func4)
{
    zval result;
    zend_fcall_info fci;
    zend_fcall_info_cache fcc;

    ZEND_PARSE_PARAMETERS_START(2, -1)
        Z_PARAM_FUNC(fci, fcc)
        Z_PARAM_VARIADIC('*', fci.params, fci.param_count)
    ZEND_PARSE_PARAMETERS_END();

    fci.retval = &amp;result;

    if (zend_call_function(&amp;fci, &amp;fcc) != SUCCESS) {
        return;
    }

    RETURN_ZVAL(&amp;result, 1, 0);
}

ZEND_BEGIN_ARG_INFO(arginfo_test_func4, 0)
    ZEND_ARG_TYPE_INFO(0, callable, IS_CALLABLE, 0)
    ZEND_ARG_INFO(0, args)
ZEND_END_ARG_INFO()

static const zend_function_entry ext_test_functions[] = {
    PHP_FE(test_func4,		arginfo_test_func4)
	PHP_FE_END
};
</code></pre>
<h2 id="以上几个函数的php测试代码">以上几个函数的PHP测试代码</h2>
<pre><code class="language-php">&lt;?php

test_func1();

var_dump(test_func2(1));
var_dump(test_func2(2, 'test'));

$arr = [1,2];
test_func3($arr);
var_dump($arr);


$callback = function (...$args) {
    foreach ($args as $arg) {
        var_dump($arg);
    }
};
test_func4($callback, 1, 2, 3, 'str1', 'str2');
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发——准备]]></title>
        <id>/post/2es0g0FAq/</id>
        <link href="/post/2es0g0FAq/">
        </link>
        <updated>2021-08-01T07:37:24.000Z</updated>
        <summary type="html"><![CDATA[<p>在开发扩展之前，需要做一些准备工作：脚手架使用、环境配置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在开发扩展之前，需要做一些准备工作：脚手架使用、环境配置。</p>
<!-- more -->
<h2 id="生成基本骨架">生成基本骨架</h2>
<p>首先，我们需要使用官方提供的<code>ext_skel</code>脚本来生成扩展的大致骨架和基础代码。</p>
<pre><code class="language-sh">./ext_skel.php --ext ext_test # ext_test为扩展名称
</code></pre>
<p>这个脚本在php源码中可以找到，具体路径为<code>php-src/ext/ext_skel</code>。</p>
<blockquote>
<p>php 7.3之前是用shell写的脚本，之后是用php写的。</p>
</blockquote>
<p>执行完上述命令后，就会生成扩展骨架：</p>
<pre><code class="language-sh">ext_test/
├── config.m4       # unix编译配置
├── config.w32      # windows编译配置
├── ext_test.c      # 主要c代码
├── php_ext_test.h  # 主要头文件
└── tests           # 测试
    ├── 001.phpt
    ├── 002.phpt
    └── 003.phpt
</code></pre>
<h2 id="环境配置">环境配置</h2>
<p>这里我是用JetBrains家的CLion作为开发环境，具体配置步骤为：</p>
<h3 id="1-创建cmakeliststxt文件">1. 创建<code>CMakeLists.txt</code>文件</h3>
<figure data-type="image" tabindex="1"><img src="/post-images/1627807380037.png" alt="" loading="lazy"></figure>
<p>点击<code>Create CMakeLists.txt</code>会生成如下的文件内容：</p>
<pre><code class="language-c">cmake_minimum_required(VERSION 3.20)
project(ext_test C)

set(CMAKE_C_STANDARD 11)

include_directories(.)

add_executable(ext_test
        ext_test.c
        php_ext_test.h)
</code></pre>
<h3 id="2-加载php头文件">2. 加载PHP头文件</h3>
<p>此时打开C文件<code>ext_test.c</code>会有一些报红，我们需要在CMakeLists.txt中增加如下代码，将PHP的头文件也加载进来即可：</p>
<pre><code class="language-c">include_directories(/usr/local/include/php)
include_directories(/usr/local/include/php/main)
include_directories(/usr/local/include/php/Zend)
</code></pre>
<p>准备工作完成了，后面就会开始实现扩展的一些具体功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP扩展开发——EXPECTED与UNEXPECTED]]></title>
        <id>/post/c3xK30m15/</id>
        <link href="/post/c3xK30m15/">
        </link>
        <updated>2021-07-31T16:32:55.000Z</updated>
        <summary type="html"><![CDATA[<p>在PHP扩展开发中，经常会看到<code>EXPECTED</code>与<code>UNEXPECTED</code>两个宏的使用，但是却不清楚它们的用途，这次就来拨开它们的面纱。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在PHP扩展开发中，经常会看到<code>EXPECTED</code>与<code>UNEXPECTED</code>两个宏的使用，但是却不清楚它们的用途，这次就来拨开它们的面纱。</p>
<!-- more -->
<p>首先举个在PHP底层中使用到<code>EXPECTED</code>与<code>UNEXPECTED</code>的例子：</p>
<pre><code class="language-c">if (UNEXPECTED(_num_args &lt; _min_num_args) || \
    (UNEXPECTED(_num_args &gt; _max_num_args) &amp;&amp; \
        EXPECTED(_max_num_args &gt;= 0))) { \
    if (!(_flags &amp; ZEND_PARSE_PARAMS_QUIET)) { \
        if (_flags &amp; ZEND_PARSE_PARAMS_THROW) { \
            zend_wrong_parameters_count_exception(_min_num_args, _max_num_args); \
        } else { \
            zend_wrong_parameters_count_error(_min_num_args, _max_num_args); \
        } \
    } \
    error_code = ZPP_ERROR_FAILURE; \
    break; \
} \
</code></pre>
<p>这是Zend提供用于解析函数参数的一个宏的部分代码，大致代码逻辑就是判断参数数量是否不正确。在<code>zend_API.h</code>中，<code>EXPECTED</code>和<code>UNEXPECTED</code>是这样定义的：</p>
<pre><code class="language-c">#if PHP_HAVE_BUILTIN_EXPECT
# define EXPECTED(condition)   __builtin_expect(!!(condition), 1)
# define UNEXPECTED(condition) __builtin_expect(!!(condition), 0)
#else
# define EXPECTED(condition)   (condition)
# define UNEXPECTED(condition) (condition)
#endif
</code></pre>
<p>可以发现它们其实是对<code>__builtin_expect</code>函数的一个封装，所以最终就是要搞清楚<code>__builtin_expect</code>到底是干嘛的。</p>
<blockquote>
<p>__builtin_expect()是GCC v2.96版本引入的内建函数，提供给程序员做分支预测。</p>
</blockquote>
<p>简单来说，就是程序员告诉编译器，后续的条件判断中可能性最大的条件分支是什么，方便编译器针对代码进行优化，将可能性最大的分支代码放在前面，降低指令跳转的可能性，以优化性能。例如：</p>
<pre><code class="language-c">// 假如有a变量
if (EXPECTED(a == 0)) {
    // ...
} else {
    // ...
}
</code></pre>
<p>以上代码表示，a == 0的可能性更大，即更有可能执行if分支代码，此时，编译器就会将if分支代码放在前面。反之，如果使用<code>UNEXPECTED</code>，就会将else分支代码放在前面。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[autotools的使用]]></title>
        <id>/post/jCJO8375A/</id>
        <link href="/post/jCJO8375A/">
        </link>
        <updated>2021-07-25T16:07:41.000Z</updated>
        <summary type="html"><![CDATA[<p>最近深入学习一下PHP扩展开发以及C相关知识，就先从autotools开始吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近深入学习一下PHP扩展开发以及C相关知识，就先从autotools开始吧。</p>
<!-- more -->
<h2 id="autotools是什么">autotools是什么？</h2>
<p>autotools是一系列用于自动生成configure脚本的工具集。包括autoconf、automake、libtools。</p>
<p>最初，工程师们在软件开发完之后，通常会配套地编写相应的Makefile文件，用于编译安装自己的程序：</p>
<ol>
<li>编写Makefile文件</li>
<li><code>make</code></li>
<li><code>make install</code></li>
</ol>
<p>但是，随着软件大范围推广使用后，程序可能需要在不同的平台上进行编译安装，而不同平台之间的编译通常存在许多差异。为了避免安装时手动去调整Makefile，工程师们开始编写<code>configure</code>脚本来根据不同平台从模版文件生成Makefile、config.h(一些宏的定义)，Makefile的模版文件是Makefile.in、config.h的模版文件是config.h.in。安装软件的大致流程为：</p>
<ol>
<li>执行<code>configure</code>脚本生成Makefile、config.h</li>
<li><code>make &amp;&amp; make install</code></li>
</ol>
<p>此时，相关文件有三个：Makefile模版文件<code>Makefile.in</code>、config.h模版文件<code>config.h.in</code>、<code>configure</code>。</p>
<p>后来，人们觉得还是太麻烦，于是开发了<code>autoconf</code>用来自动生成<code>configure</code>脚本、<code>automake</code>用于生成Makefile.in模版文件、<code>autoheader</code>用于生成config.h.in模版文件。</p>
<blockquote>
<p>更多的一些介绍及流程，可以参照这篇博客<a href="https://blog.csdn.net/weixin_42398658/article/details/107629877">https://blog.csdn.net/weixin_42398658/article/details/107629877</a></p>
</blockquote>
<h2 id="简单使用">简单使用</h2>
<p>这里使用一段简单的C代码来做演示。</p>
<h4 id="1-编写源代码">1. 编写源代码</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<p>完成之后，可以直接手动编译并执行一下试试：<code>gcc main.c -o main &amp;&amp; ./main</code>。</p>
<h4 id="2-使用autoscan扫描源代码生成configurescan文件">2. 使用autoscan扫描源代码，生成configure.scan文件</h4>
<pre><code class="language-sh">autoscan
</code></pre>
<figure data-type="image" tabindex="1"><img src="/post-images/1627660831826.PNG" alt="" loading="lazy"></figure>
<blockquote>
<p>autoscan.log按名称推测，应该就是autoscan命令产生的相关日志。<br>
configure.scan是一个雏形文件，需要在其基础上进行修改保存为configure.ac。</p>
</blockquote>
<h4 id="3-configurescan复制为configureac并修改内容">3. configure.scan复制为configure.ac，并修改内容</h4>
<p>将configure.scan复制为configure.ac，并修改以下中文注释后内容：</p>
<pre><code>#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

AC_PREREQ([2.71])

# 基础信息
# AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
AC_INIT(helloworld, 1.0.0, anhoder@88.com)

AC_CONFIG_SRCDIR([main.c])
AC_CONFIG_HEADERS([config.h])

# 增加automake配置
AM_INIT_AUTOMAKE

# Checks for programs.
AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

# 生成Makefile
AC_CONFIG_FILES(Makefile)

AC_OUTPUT
</code></pre>
<h4 id="4-aclocal生成aclocalm4">4. aclocal生成aclocal.m4</h4>
<pre><code class="language-sh">aclocal
</code></pre>
<figure data-type="image" tabindex="2"><img src="/post-images/1627660851848.JPG" alt="" loading="lazy"></figure>
<h4 id="5-autoconf生成configure脚本">5. autoconf生成configure脚本</h4>
<pre><code class="language-sh">autoconf
</code></pre>
<figure data-type="image" tabindex="3"><img src="/post-images/1627660860091.JPG" alt="" loading="lazy"></figure>
<p>此时，configure脚本已经成功生成了。</p>
<h4 id="6-autoheader生成confighin">6. autoheader生成config.h.in</h4>
<pre><code class="language-sh">autoheader
</code></pre>
<figure data-type="image" tabindex="4"><img src="/post-images/1627660868315.JPG" alt="" loading="lazy"></figure>
<p>config.h.in文件也已生成。</p>
<h4 id="7-编写makefileam">7. 编写Makefile.am</h4>
<p>Makefile.am用于生成Makefile.in，需要手动编写，<a href="https://www.gnu.org/software/automake/manual/automake.html">官方文档</a>。</p>
<pre><code>bin_PROGRAMS=main
main_SOURCES=main.c
</code></pre>
<p>将上述内容写入到Makefile.am中，保存。</p>
<h4 id="8-automake生成makefilein">8. automake生成Makefile.in</h4>
<pre><code class="language-sh">automake
</code></pre>
<figure data-type="image" tabindex="5"><img src="/post-images/1627660879049.JPG" alt="" loading="lazy"></figure>
<p>出现了报错，需要加上<code>--add-missing</code>选项。</p>
<pre><code class="language-sh">automake --add-missing
</code></pre>
<figure data-type="image" tabindex="6"><img src="/post-images/1627660891520.JPG" alt="" loading="lazy"></figure>
<p>需要添加四个文件，手动创建再执行<code>automake --add-missing</code>即可：</p>
<pre><code class="language-sh">touch NEWS README AUTHORS ChangeLog
automake --add-missing
</code></pre>
<p>至此，三个文件（configure, Makefile.in, config.h.in）全部生成完成。</p>
<blockquote>
<p>查看configure，其实就是个shell脚本。</p>
</blockquote>
<h4 id="9-执行configure脚本-make">9. 执行configure脚本、make</h4>
<pre><code class="language-sh">./configure
make
</code></pre>
<figure data-type="image" tabindex="7"><img src="/post-images/1627660899653.JPG" alt="" loading="lazy"></figure>
<p>可以看到，configure脚本主要是在检查环境以及生成Makefile、config.h。</p>
<p>两个命令执行完成，即编译出了相应的二进制文件<code>main</code>，执行<code>./main</code>查看结果。</p>
<h2 id="总结">总结</h2>
<p>这里主要介绍了autotools的简单使用，为后续PHP扩展开发的学习做铺垫。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021 PHP部分面经]]></title>
        <id>/post/JeWf3QSkh/</id>
        <link href="/post/JeWf3QSkh/">
        </link>
        <updated>2021-06-14T15:27:14.000Z</updated>
        <summary type="html"><![CDATA[<p>前段时间辞职换工作，参加了一些面试，现在也入职了，趁着还不忙稍微整理一下面经（记录一些映像比较深的吧）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前段时间辞职换工作，参加了一些面试，现在也入职了，趁着还不忙稍微整理一下面经（记录一些映像比较深的吧）。</p>
<!-- more -->
<h2 id="广州-爱拍">广州-爱拍</h2>
<p>给我映像最深的就是它的笔试题了，整整4页，还是双面的，而且很多问题都有好几问的...<br>
勉强记得的几个题：</p>
<ul>
<li>TCP三次握手过程</li>
<li>TCP与UDP区别</li>
<li>session与cookie的区别</li>
<li>TCP发送数据包与接收数据包的过程</li>
<li>浏览器输入网址到显示页面其背后经历的过程</li>
<li>还有一些系统设计的题</li>
<li>算法：最长公共字串</li>
<li>...</li>
</ul>
<p>面试题记不清了，基本上是项目相关。</p>
<h2 id="广州-4399">广州-4399</h2>
<p>等了一会面试官才过来，看起来挺忙的😂</p>
<ol>
<li>Redis常用的数据结构，除了五种基本数据结构外还有什么数据结构？</li>
</ol>
<blockquote>
<p>string, list, hash, set, zset, HyperLogLog, GEO, bitmap</p>
</blockquote>
<ol start="2">
<li>Redis是单线程的吗？单线程是指哪个模块是单线程？为什么单线程还能保持超高性能？</li>
</ol>
<blockquote>
<p>Redis 6之前是单线程，之后是多线程；I/O模块；epoll I/O复用模型</p>
</blockquote>
<ol start="3">
<li>select, poll, epoll的区别？</li>
<li>远距离两地的MySQL数据同步，如何实现？异地多活有了解过吗？</li>
</ol>
<blockquote>
<p>没回答上来；听说过，没深入了解</p>
</blockquote>
<ol start="5">
<li>...</li>
</ol>
<p>第二面因为时间原因没参加了（HR一直让我在那等...）</p>
<h2 id="广州-爆米科技">广州-爆米科技</h2>
<ol>
<li>php-fpm是什么以及它的工作流程</li>
<li>cgi、fast-cgi的区别</li>
<li>MySQL执行一条SQL时的流程</li>
</ol>
<blockquote>
<p>大概是：权限校验-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;优化器进行优化-&gt;存储引擎查询数据</p>
</blockquote>
<ol start="4">
<li>Redis通过键批量获取值时，如果数据比较多会导致性能下降，如何解决？</li>
</ol>
<blockquote>
<p>将需要获取的键进行分片，依次获取</p>
</blockquote>
<ol start="5">
<li>PHP中对数组进行分片的函数</li>
</ol>
<blockquote>
<p>array_chunk</p>
</blockquote>
<ol start="6">
<li>...</li>
</ol>
<p>听面试官说，好像是转转的技术团队二次创业。比较满意的一家，可惜后面打算去深圳了，只能放弃了。</p>
<h2 id="广州-网易游戏">广州-网易游戏</h2>
<ol>
<li>Redis删除一个大数据键值时，有没有什么问题？</li>
<li>需要从三个物品A, B, C中随机取出一个，如何用一枚硬币做到等概率取？</li>
</ol>
<blockquote>
<p>最简单的就是抛两次，会有四种可能，取其中三种跟三个物品一一对应，如果是第四种就重新抛。</p>
</blockquote>
<ol start="3">
<li>接口性能比较差，如何排查？</li>
<li>让你实现一个连接池，如何实现？</li>
<li>OAuth 2.0安全问题</li>
<li>面了挺久的，问得比较深，只记得一点了...</li>
</ol>
<blockquote>
<p>后来到深圳也面了不少，但是很多都记不起来了，后续有想起来再更新吧。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL的json、jsonb、数组]]></title>
        <id>/post/kYHKCQzOh/</id>
        <link href="/post/kYHKCQzOh/">
        </link>
        <updated>2021-06-14T13:09:40.000Z</updated>
        <summary type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近工作中接触到PostgreSQL，所以稍微学习下它的几种数据类型：<code>json</code>、<code>jsonb</code>、数组以及相对应的数据查询。</p>
<!-- more -->
<blockquote>
<p>PostgreSQL中单引号用于表示字符串值，双引号用于表示系统标识符，没有反引号`。</p>
</blockquote>
<h2 id="json-jsonb">JSON、JSONB</h2>
<h3 id="json和jsonb的异同"><code>json</code>和<code>jsonb</code>的异同</h3>
<p>在PostgreSQL中，<code>json</code>和<code>jsonb</code>都是用来存储<code>json</code>数据的。</p>
<p>使用<code>json</code>类型时，PostgreSQL会将输入的<code>json</code>文本存储起来，包括其中的空格以及键的顺序，在查询使用时才去解析。而<code>jsonb</code>类型会将输入的<code>json</code>文本解析为对应的二进制数据进行存储。<code>jsonb</code>类型相较<code>json</code>类型而言更高效，性能更好，且支持建立索引。</p>
<h3 id="json及jsonb的相关sql操作"><code>json</code>及<code>jsonb</code>的相关SQL操作</h3>
<h4 id="表的创建">表的创建</h4>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test (
    id int not null primary key,
    attr_json json not null,
    attr_jsonb jsonb not null
);
</code></pre>
<h4 id="数据插入">数据插入</h4>
<pre><code class="language-sql">INSERT INTO test (id, attr_json, attr_jsonb)
VALUES (1, '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}', '{&quot;name&quot;:&quot;anhoder&quot;,&quot;age&quot;:18}'),
       (2, '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;jane&quot;,&quot;age&quot;:34,&quot;son&quot;: {&quot;name&quot;:&quot;coco&quot;,&quot;age&quot;:1}}'),
       (3, '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}', '{&quot;name&quot;:&quot;alan&quot;,&quot;age&quot;:35,&quot;son&quot;: {&quot;name&quot;:&quot;coney&quot;,&quot;age&quot;:1}}'),
       (4, '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}', '{&quot;name&quot;:&quot;jojo&quot;,&quot;age&quot;:26}');
</code></pre>
<p>插入后的结果：</p>
<figure data-type="image" tabindex="1"><img src="/post-images/1623679477303.png" alt="插入结果" loading="lazy"></figure>
<p>可见<code>jsonb</code>会对数据进行解析后，再进行存储，<code>json</code>则存储原输入。</p>
<h4 id="数据查询">数据查询</h4>
<pre><code class="language-sql">-- -&gt; 获取对象的属性，结果作为json对象；-&gt;&gt;获取对象的属性，结果作为文本
select attr_json-&gt;'son'-&gt;'age' as son_age, attr_json-&gt;&gt;'son' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="2"><img src="/post-images/1623680145772.png" alt="结果1" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- #&gt; 根据路径获取结果作为json对象；#&gt;&gt; 根据路径获取结果作为文本(json, jsonb结果一致)
select attr_json#&gt;'{son}'-&gt;'age' as son_age, attr_json#&gt;'{son,age}' as son_age2, attr_json#&gt;&gt;'{son}' as son_text from test;
</code></pre>
<figure data-type="image" tabindex="3"><img src="/post-images/1623680312500.png" alt="结果2" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- @&gt;左边是否包含右边；&lt;@右边是否包含左边 (jsonb可用)
select * from test where attr_jsonb@&gt;'{&quot;age&quot;:18}';
</code></pre>
<figure data-type="image" tabindex="4"><img src="/post-images/1623680487862.png" alt="结果3" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ? 是否存在属性
select * from test where attr_jsonb ? 'name';
</code></pre>
<hr>
<pre><code class="language-sql">-- ?| 存在数组中任意一个属性则为true (jsonb可用)
select * from test where attr_jsonb ?| array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="5"><img src="/post-images/1623680779281.png" alt="结果4" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ?&amp; 同时存在数组中的所有属性则为true (jsonb可用)
select * from test where attr_jsonb ?&amp; array ['son', 'name'];
</code></pre>
<figure data-type="image" tabindex="6"><img src="/post-images/1623680893730.png" alt="结果5" loading="lazy"></figure>
<hr>
<pre><code class="language-sql">-- ::为类型转换
select * from test where (attr_json-&gt;&gt;'age')::int&gt;20;
</code></pre>
<figure data-type="image" tabindex="7"><img src="/post-images/1623681132425.png" alt="结果6" loading="lazy"></figure>
<h4 id="数据更新">数据更新</h4>
<pre><code class="language-sql">-- jsonb_set(jsonb old_jsonb, text[] path, jsonb new_jsonb, bool create_if_missing) 更新jsonb 
update test set attr_jsonb=jsonb_set(attr_jsonb, '{son}', '{&quot;name&quot;:&quot;con&quot;,&quot;age&quot;:2}')
where (attr_jsonb#&gt;&gt;'{son,name}') = 'coco';
</code></pre>
<hr>
<pre><code class="language-sql">-- 根据路径删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb#-'{son,name}';
</code></pre>
<hr>
<pre><code class="language-sql">-- 删除属性 (jsonb可用)
update test set attr_jsonb=attr_jsonb-'son' where attr_jsonb ? 'son';
</code></pre>
<h2 id="数组">数组</h2>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE test_arr (
    id int not null primary key,
    arr int[] not null
);

-- 插入数据
insert into test_arr (id, arr) values (1, array[2,3,4]),(2, array[3,4,5]);

-- 数组合并
select array[1,2,3,4] || array[2,3,4,5]; -- 结果：{1,2,3,4,2,3,4,5}
select 2 || array[2,3,4,5]; -- 结果：{2,2,3,4,5}

-- 数组比较，每个元素依次比较大小
select array[1,2,3,4] &gt; array[1,2,3]; -- 结果: true
select array[1,2,3,4] &gt; array[1,2,4]; -- 结果: false

-- 数组包含关系
select array[1,2,3] @&gt; array[2,3]; -- 结果: true
select array[1,2,3] @&gt; array[2,3,4]; -- 结果: false

-- 数组是否有共同元素
select array[1,2,3] &amp;&amp; array[3,4,5]; -- 结果: true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[musicfox 2.0——golang重写版]]></title>
        <id>/post/NOO340v6g/</id>
        <link href="/post/NOO340v6g/">
        </link>
        <updated>2021-05-14T12:51:23.000Z</updated>
        <summary type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>musicfox 2.0终于完成了，没有太多的功能变更，主要使用golang进行重写，优化了用户体验（主要是Windows下）。</p>
<!-- more -->
<h2 id="存在的问题与方案">存在的问题与方案</h2>
<p>musicfox最开始是用Dart写的，工作原理大致是主进程fork一个mpg123的子进程，主进程处理UI渲染、用户交互及网络请求等，然后通过进程间管道通信，来控制mpg123子进程的音乐播放、暂停以及播放器的音量大小等。</p>
<p>这种模式下，会存在以下这些问题：</p>
<ul>
<li>依赖mpg123，需要用户手动安装mpg123</li>
<li>mpg123只能播放mp3音乐，网易云无损音质是flac格式，无法播放</li>
<li>进程间需要通过管道进行通信，Windows下不容易处理</li>
<li>Dart大多数三方包都是基于Flutter的，原生包不多</li>
<li>...</li>
</ul>
<p>为了解决这些问题，于是开始采用golang进行重写，优势主要是：</p>
<ul>
<li>golang支持更多平台的二进制编译</li>
<li>拥有丰富的第三方包，例如音频播放的<a href="https://github.com/faiface/beep">beep</a>、TUI渲染的<br>
<a href="https://github.com/charmbracelet/bubbletea">bubbletea</a>、本地数据库的<a href="https://github.com/boltdb/bolt">bolt</a>等等</li>
<li>不需要借助其他进程，所以不存在进程通信</li>
<li>支持mp3、flac、wav等格式音频文件的解码播放</li>
<li>goroutine + chan</li>
</ul>
<p>另外对我自己来说可以深入熟悉golang...</p>
<h2 id="使用go时遇到的问题">使用go时遇到的问题</h2>
<h3 id="协程泄漏">协程泄漏</h3>
<p>在使用golang过程中遇到比较严重的问题就是协程泄漏。例如下面的代码：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {
	c1 := make(chan struct{})
	for i := 0; i &lt; 10; i++ {
		go test(c1)
		fmt.Println(runtime.NumGoroutine())
	}
}

func test(c chan&lt;- struct{}) {
	c &lt;- struct{}{}
}
</code></pre>
<p>执行后会输出：</p>
<pre><code>2
3
4
5
6
7
8
9
10
11
</code></pre>
<p>可见，协程数一直在增加，这是因为没有消费者消费chan中的数据，所有子协程都阻塞在写chan的操作。</p>
<p>类似这种情况就会导致协程数不断增长，出现协程泄漏，内存占用不断上升。</p>
<h3 id="如何尽量避免协程泄漏">如何尽量避免协程泄漏</h3>
<ol>
<li>确保chan都会有相应的消费者、生产者，且生产速度和消费速度差不多</li>
<li>如果需要往chan中压数据或读数据，但又不确定是否有消费者或生产者，可以使用<code>select</code>结构避免阻塞</li>
<li>使用goroutine + chan处理，避免创建大量协程，例如：</li>
</ol>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	// 获取data逻辑
	for _, v := range data {
		go test(v)
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(s string) {
	// 假装业务逻辑
	time.Sleep(time.Millisecond)
}
</code></pre>
<p>输出为: 101，也就是新开了100个协程，如果数据更多时，会产生更多协程。这种情况可以考虑创建固定数量的若干个协程，然后通过chan将数据投递给子协程进行处理，避免大量协程占用内存，如：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

func main() {
	var data [100]string
	c := make(chan string)

	for i := 0; i &lt; 5; i++ {
		go test(c)
	}

	for _, v := range data {
		c &lt;- v
	}

	fmt.Println(runtime.NumGoroutine())
}

func test(c &lt;-chan string) {
	for _ = range c {
        // 业务逻辑
		time.Sleep(time.Millisecond)
	}
}
</code></pre>
<h3 id="协程泄漏排查">协程泄漏排查</h3>
<ol>
<li>runtime.NumGoroutine()查看协程数</li>
<li>使用gops排查，可以查看当前协程数、调用栈等</li>
</ol>
<h2 id="预览">预览</h2>
<figure data-type="image" tabindex="1"><img src="/post-images/1620999111458.png" alt="preview1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="/post-images/1620999246727.png" alt="preview2" loading="lazy"></figure>
<h2 id="安装">安装</h2>
<h3 id="mac">Mac</h3>
<p>提供两种方式安装：</p>
<h4 id="使用brew安装">使用brew安装</h4>
<pre><code class="language-sh">brew tap anhoder/go-musicfox &amp;&amp; brew install go-musicfox
</code></pre>
<p>如果你之前安装过musicfox，需要使用下列命令重新链接:</p>
<pre><code class="language-sh">brew unlink musicfox &amp;&amp; brew link --overwrite go-musicfox
</code></pre>
<h4 id="直接下载">直接下载</h4>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.mac">Mac可执行文件</a>，在iTerm或Terminal中打开</p>
<h3 id="linux">Linux</h3>
<p>身边没有Linux设备，而播放音乐依赖CGO，无法进行交叉编译，所以暂时没有可用的二进制文件</p>
<h3 id="windows">Windows</h3>
<p>下载<a href="https://github.com/anhoder/go-musicfox/releases/latest/download/musicfox.exe">Windows可执行文件</a>，在命令行中运行即可。</p>
<p><strong>推荐使用Windows Terminal，UI及体验会好很多</strong></p>
<h2 id="快捷键">快捷键</h2>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h/H/LEFT</td>
<td>左</td>
<td></td>
</tr>
<tr>
<td>l/L/RIGHT</td>
<td>右</td>
<td></td>
</tr>
<tr>
<td>k/K/UP</td>
<td>上</td>
<td></td>
</tr>
<tr>
<td>j/J/DOWN</td>
<td>下</td>
<td></td>
</tr>
<tr>
<td>q/Q</td>
<td>退出</td>
<td></td>
</tr>
<tr>
<td>space</td>
<td>暂停/播放</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>上一曲</td>
<td></td>
</tr>
<tr>
<td>]</td>
<td>下一曲</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减小音量</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>加大音量</td>
<td></td>
</tr>
<tr>
<td>n/N/ENTER</td>
<td>进入选中的菜单</td>
<td></td>
</tr>
<tr>
<td>b/B/ESC</td>
<td>返回上级菜单</td>
<td></td>
</tr>
<tr>
<td>w/W</td>
<td>退出并退出登录</td>
<td></td>
</tr>
<tr>
<td>p</td>
<td>切换播放方式</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>心动模式(仅在歌单中时有效)</td>
<td></td>
</tr>
<tr>
<td>r/R</td>
<td>重新渲染UI</td>
<td>Windows调整窗口大小后，没有事件触发，可以使用该方法手动重新渲染</td>
</tr>
<tr>
<td>,</td>
<td>喜欢当前播放歌曲</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>喜欢当前选中歌曲</td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>当前播放歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>当前选中歌曲移除出喜欢</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td>标记当前播放歌曲为不喜欢</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>标记当前选中歌曲为不喜欢</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="todo">TODO</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6305889"><label class="task-list-item-label" for="task-item-6305889"> 我的歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9587384"><label class="task-list-item-label" for="task-item-9587384"> 每日推荐歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5370772"><label class="task-list-item-label" for="task-item-5370772"> 每日推荐歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9764477"><label class="task-list-item-label" for="task-item-9764477"> 私人FM</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6019587"><label class="task-list-item-label" for="task-item-6019587"> 歌词显示</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-165212"><label class="task-list-item-label" for="task-item-165212"> 欢迎界面</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-776526"><label class="task-list-item-label" for="task-item-776526"> 搜索</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4033926"><label class="task-list-item-label" for="task-item-4033926"> 按歌曲</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4041768"><label class="task-list-item-label" for="task-item-4041768"> 按歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5736241"><label class="task-list-item-label" for="task-item-5736241"> 按歌词</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6601854"><label class="task-list-item-label" for="task-item-6601854"> 按歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5563139"><label class="task-list-item-label" for="task-item-5563139"> 按专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6870812"><label class="task-list-item-label" for="task-item-6870812"> 按用户</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4804249"><label class="task-list-item-label" for="task-item-4804249"> 排行榜</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-5820611"><label class="task-list-item-label" for="task-item-5820611"> 精选歌单</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2381293"><label class="task-list-item-label" for="task-item-2381293"> 最新专辑</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6382509"><label class="task-list-item-label" for="task-item-6382509"> 热门歌手</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-559473"><label class="task-list-item-label" for="task-item-559473"> 云盘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4346373"><label class="task-list-item-label" for="task-item-4346373"> 播放方式切换</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3971769"><label class="task-list-item-label" for="task-item-3971769"> 喜欢/取消喜欢</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-4991467"><label class="task-list-item-label" for="task-item-4991467"> 心动模式/智能模式</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6433356"><label class="task-list-item-label" for="task-item-6433356"> 音乐电台</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1488671"><label class="task-list-item-label" for="task-item-1488671"> 配置文件</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5224567"><label class="task-list-item-label" for="task-item-5224567"> 通知功能</label></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个utools插件——hasids加解密]]></title>
        <id>/post/YMhNrwxuT/</id>
        <link href="/post/YMhNrwxuT/">
        </link>
        <updated>2021-03-22T12:07:53.000Z</updated>
        <summary type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>工作中用到了hashids加密算法，开发测试时经常需要对某个ID或hashid进行加密、解密，为了提高效率，周末花了点时间基于<code>otp</code>封装了一个utools插件——<code>hashids</code>。</p>
<!-- more -->
<p>utools是什么就不多说了，这里主要说一下<code>hashids</code>插件的使用。</p>
<blockquote>
<p>GitHub地址: <a href="https://github.com/anhoder/utools-hashids">https://github.com/anhoder/utools-hashids</a></p>
</blockquote>
<h2 id="添加hashids配置">添加hashids配置</h2>
<p>hashids加解密需要配置salt及最小长度，可以使用以下关键字进去添加配置的步骤:</p>
<ul>
<li>hadd</li>
<li>hash-add</li>
<li>hash添加配置</li>
</ul>
<figure data-type="image" tabindex="1"><img src="/post-images/1617624599510.png" alt="添加配置" loading="lazy"></figure>
<p>进入之后，依次输入<code>名称</code>-<code>salt</code>-<code>最小长度</code>即可保存配置。</p>
<blockquote>
<p>如果有多个环境配置，多次添加即可，<strong>名称不可重复</strong>。</p>
</blockquote>
<h2 id="hashids加密">hashids加密</h2>
<p>hashids加密有两种方式进入，一种是使用关键字：</p>
<ul>
<li>haen</li>
<li>hash-encode</li>
<li>hash编码</li>
</ul>
<p>进入之后，输入你想要加密的ID，列表中会显示你已有配置的加密结果，回车即可复制，如：</p>
<figure data-type="image" tabindex="2"><img src="/post-images/1617626324547.png" alt="hashids加密" loading="lazy"></figure>
<p>另外一种方法是直接在<code>utools</code>的主输入框内输入需要加密的ID，选择<code>hash编码</code>进入，回车即可复制。</p>
<blockquote>
<ol>
<li>如果你开启了utools的右键超级面板，就更方便了，只需要长按右键你的ID，选择<code>hash编码</code>即可。</li>
<li>如果你需要删除配置，在进入之后使用<code>control</code>+<code>enter</code>或<code>command</code>+<code>enter</code>即可删除选中的配置项。</li>
</ol>
</blockquote>
<h2 id="hashids解密">hashids解密</h2>
<p>解密和加密差不多，就不赘述了，关键字：</p>
<ul>
<li>hade</li>
<li>hash-decode</li>
<li>hash解码</li>
</ul>
]]></content>
    </entry>
</feed>